// ===================================================================
// ZynPEG Zig Subset Grammar
// ===================================================================
//
// Phase 2: Zig subset grammar for Zyntax compiler infrastructure
// Target: Structs, functions, control flow, basic generics
//
// Reference: https://ziglang.org/documentation/master/
// Status: Week 1 - Basic structure (primitives, literals, expressions)
//
// ===================================================================

// ===== Program Structure =====

program = { SOI ~ declaration* ~ EOI }

declaration = {
    const_decl
  | var_decl
  | fn_decl
  | struct_decl
  | enum_decl
}

// ===== Declarations =====

const_decl = { "const" ~ identifier ~ (":" ~ type_expr)? ~ "=" ~ expr ~ ";" }
var_decl   = { "var" ~ identifier ~ (":" ~ type_expr)? ~ "=" ~ expr ~ ";" }

fn_decl = {
    "fn" ~ identifier ~
    "(" ~ fn_params? ~ ")" ~ type_expr ~
    block
}

fn_params = { fn_param ~ ("," ~ fn_param)* }
fn_param  = { comptime_param | regular_param }
comptime_param = { "comptime" ~ identifier ~ ":" ~ "type" }
regular_param  = { identifier ~ ":" ~ type_expr }

struct_decl = {
    "const" ~ identifier ~ "=" ~ "struct" ~ "{" ~
    field_decl* ~
    "}" ~ ";"
}

field_decl = { identifier ~ ":" ~ type_expr ~ "," }

// Enum declaration: const Color = enum { red, green, blue };
enum_decl = {
    "const" ~ identifier ~ "=" ~ "enum" ~ ("(" ~ type_expr ~ ")")? ~ "{" ~
    enum_variant ~ ("," ~ enum_variant)* ~ ","? ~
    "}" ~ ";"
}

// Enum variant: red, green = 1, blue
enum_variant = { identifier ~ ("=" ~ expr)? }

// ===== Type Expressions =====

type_expr = {
    primitive_type
  | identifier              // Named type (struct name, type alias)
  | array_type              // []T or [N]T
  | pointer_type            // *T
  | optional_type           // ?T
  | error_union_type        // !T
}

primitive_type = {
    "i8" | "i16" | "i32" | "i64" | "i128"
  | "u8" | "u16" | "u32" | "u64" | "u128"
  | "f32" | "f64"
  | "bool"
  | "void"
}

array_type   = { "[" ~ integer_literal? ~ "]" ~ type_expr }
pointer_type = { "*" ~ type_expr }
optional_type = { "?" ~ type_expr }
error_union_type = { "!" ~ type_expr }

// ===== Statements =====

statement = {
    const_decl
  | var_decl
  | assignment
  | if_stmt
  | while_stmt
  | for_stmt
  | break_stmt
  | continue_stmt
  | return_stmt
  | defer_stmt
  | errdefer_stmt
  | expr_stmt
}

// Defer: execute at end of scope (LIFO order)
defer_stmt = { "defer" ~ (block | expr_stmt) }

// Errdefer: execute only if scope exits with error
errdefer_stmt = { "errdefer" ~ (block | expr_stmt) }

// Assignment supports: identifier, array index (arr[i]), field access (obj.field)
assignment = { assign_target ~ "=" ~ expr ~ ";" }
assign_target = { identifier ~ ("[" ~ expr ~ "]")* }
return_stmt = { "return" ~ expr? ~ ";" }
expr_stmt = { expr ~ ";" }

if_stmt = {
    if_let_stmt
  | if_regular_stmt
}

// if let pattern unwrapping: if (let pattern = expr) { ... }
if_let_stmt = {
    "if" ~ "(" ~ "let" ~ pattern ~ "=" ~ expr ~ ")" ~ block ~
    ("else" ~ (if_stmt | block))?
}

// Regular if statement: if (condition) { ... }
if_regular_stmt = {
    "if" ~ "(" ~ expr ~ ")" ~ block ~
    ("else" ~ (if_stmt | block))?
}

while_stmt = {
    "while" ~ "(" ~ expr ~ ")" ~ block
}

for_stmt = {
    "for" ~ "(" ~ identifier ~ "in" ~ expr ~ ")" ~ block
}

break_stmt = { "break" ~ ";" }

continue_stmt = { "continue" ~ ";" }

block = { "{" ~ statement* ~ "}" }

// ===== Expressions =====
// Precedence (lowest to highest):
// 1. orelse (optional unwrap with default)
// 2. catch (error unwrap with default/handler)
// 3. Logical OR
// 4. Logical AND
// 5. Equality (==, !=)
// 6. Comparison (<, >, <=, >=)
// 7. Bitwise OR (|)
// 8. Bitwise XOR (^)
// 9. Bitwise AND (&)
// 10. Bit shift (<<, >>)
// 11. Addition/Subtraction
// 12. Multiplication/Division/Modulo
// 13. Unary (-, !, ~, &, *)
// 14. Postfix (., [], ())
// 15. Primary (literals, identifiers, parentheses)

expr = { orelse_expr }

orelse_expr = { catch_expr ~ (orelse_op ~ catch_expr)* }
catch_expr  = { logical_or ~ (catch_op ~ logical_or)* }
logical_or  = { logical_and ~ (log_or_op ~ logical_and)* }
logical_and = { equality ~ (log_and_op ~ equality)* }
equality    = { comparison ~ (eq_op ~ comparison)* }
comparison  = { bitwise_or ~ (cmp_op ~ bitwise_or)* }
bitwise_or  = { bitwise_xor ~ (bit_or_op ~ bitwise_xor)* }
bitwise_xor = { bitwise_and ~ (bit_xor_op ~ bitwise_and)* }
bitwise_and = { bit_shift ~ (bit_and_op ~ bit_shift)* }
bit_shift   = { addition ~ (shift_op ~ addition)* }
addition    = { multiplication ~ (add_op ~ multiplication)* }
multiplication = { unary ~ (mul_op ~ unary)* }

unary = {
    unary_op ~ unary
  | postfix
}

postfix = {
    primary ~ postfix_op*
}

postfix_op = {
    "." ~ identifier          // Field access
  | "[" ~ expr ~ "]"          // Array indexing
  | "(" ~ args? ~ ")"         // Function call
}

args = { expr ~ ("," ~ expr)* }

primary = {
    literal
  | struct_literal
  | switch_expr
  | try_expr
  | lambda_expr
  | "(" ~ expr ~ ")"
  | identifier
}

// ===== Lambda/Closure Expression =====
// Syntax: |params| body or |params| { block }
lambda_expr = {
    "|" ~ lambda_params? ~ "|" ~ (block | expr)
}

lambda_params = { lambda_param ~ ("," ~ lambda_param)* }
lambda_param = { identifier ~ (":" ~ type_expr)? }

// ===== Try Expression =====
try_expr = { "try" ~ postfix }

// ===== Switch Expression =====

switch_expr = {
    "switch" ~ "(" ~ expr ~ ")" ~ "{" ~
    switch_case ~ ("," ~ switch_case)* ~ ","? ~
    "}"
}

switch_case = {
    switch_pattern ~ "=>" ~ expr
}

switch_pattern = {
    integer_literal           // Single value: 1 => ...
  | switch_else               // Default case
  | identifier                // Enum variant or named value
}

switch_else = { "else" }

// ===== Literals =====

literal = {
    bool_literal
  | integer_literal
  | float_literal
  | string_literal
  | array_literal
}

bool_literal    = { "true" | "false" }
integer_literal = @{ "-"? ~ ASCII_DIGIT+ }
float_literal   = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
string_literal  = { "\"" ~ string_inner ~ "\"" }
string_inner    = @{ (!("\"" | "\\") ~ ANY)* }

array_literal = { "[" ~ "_" ~ "]" ~ type_expr ~ "{" ~ (expr ~ ("," ~ expr)*)? ~ "}" }

struct_literal = {
    identifier ~ "{" ~ struct_field_init? ~ ("," ~ struct_field_init)* ~ ","? ~ "}"
}

struct_field_init = { "." ~ identifier ~ "=" ~ expr }

// ===== Patterns =====

pattern = {
    wildcard_pattern
  | identifier_pattern
  | literal_pattern
  | enum_pattern
}

// Wildcard pattern: _
wildcard_pattern = { "_" }

// Identifier binding pattern: x, mut x
identifier_pattern = { ("mut" ~ identifier) | identifier }

// Literal pattern: 42, true, "hello"
literal_pattern = { literal }

// Enum/Optional pattern: Some(x), None, Ok(value), Err(e)
enum_pattern = {
    identifier ~ "(" ~ pattern ~ ")"
}

// ===== Identifiers =====

identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// ===== Operators =====

// Optional/Error handling operators
orelse_op  = { "orelse" }
catch_op   = { "catch" }

// Logical operators
log_or_op  = { "or" }
log_and_op = { "and" }

// Comparison operators
cmp_op     = { "<=" | ">=" | "<" | ">" }
eq_op      = { "==" | "!=" }

// Bitwise operators
bit_or_op  = { "|" }
bit_xor_op = { "^" }
bit_and_op = { "&" }
shift_op   = { "<<" | ">>" }

// Arithmetic operators
add_op     = { "+" | "-" }
mul_op     = { "*" | "/" | "%" }

// Unary operators
unary_op   = { "-" | "!" | "~" }

// ===== Whitespace and Comments =====

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT    = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n" }
