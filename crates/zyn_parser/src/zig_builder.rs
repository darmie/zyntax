//! # Zig TypedAST Builder
//!
//! Converts pest parse trees (from zig.pest) to Zyntax TypedAST.
//!
//! Phase 2 Week 1: Basic structure (primitives, literals, simple expressions)

use pest::iterators::{Pair, Pairs};
use zyntax_typed_ast::{
    TypedASTBuilder, TypedNode, TypedProgram, TypedExpression, Type, TypeId,
    InternedString, Span, TypeRegistry, Visibility, CallingConvention,
    ParamInfo, AsyncKind, NullabilityKind, Mutability,
    typed_ast::{
        TypedDeclaration, TypedStatement, TypedBlock, TypedFunction,
        TypedParameter, TypedClass, TypedField, TypedStructLiteral,
        TypedFieldInit, TypedFieldAccess, TypedFor, TypedPattern,
        TypedIndex, TypedMatch, TypedMatchArm, TypedMatchExpr, TypedLiteralPattern,
        TypedLiteral, typed_node,
    },
};
use std::collections::HashMap;

/// Parser rule enum generated by pest_derive
#[derive(pest_derive::Parser)]
#[grammar = "zig.pest"]
pub struct ZigParser;

// Make the pest-generated Rule enum available to users of this module
pub mod zig_parser {
    pub use super::Rule;
}

/// Error type for AST building
#[derive(Debug, thiserror::Error)]
pub enum BuildError {
    #[error("Parse error: {0}")]
    Parse(String),

    #[error("Invalid number literal: {0}")]
    ParseNumber(String),

    #[error("Unexpected rule: expected {expected}, got {got}")]
    UnexpectedRule { expected: String, got: String },

    #[error("Type not found: {0}")]
    TypeNotFound(String),

    #[error("Internal error: {0}")]
    Internal(String),
}

pub type BuildResult<T> = Result<T, BuildError>;

/// Scope for variable and type resolution
#[derive(Debug, Clone)]
struct Scope {
    /// Variables in this scope
    variables: HashMap<InternedString, Type>,
}

impl Scope {
    fn new() -> Self {
        Self {
            variables: HashMap::new(),
        }
    }
}

/// Zig TypedAST builder
pub struct ZigBuilder {
    /// Underlying TypedAST builder
    builder: TypedASTBuilder,

    /// Registered struct types (name -> TypeId)
    struct_types: HashMap<InternedString, zyntax_typed_ast::TypeId>,

    /// Registered type aliases
    type_aliases: HashMap<InternedString, Type>,

    /// Function signatures for forward references
    function_signatures: HashMap<InternedString, Type>,

    /// Scope stack for variable resolution
    scopes: Vec<Scope>,
}

impl ZigBuilder {
    pub fn new() -> Self {
        Self {
            builder: TypedASTBuilder::new(),
            struct_types: HashMap::new(),
            type_aliases: HashMap::new(),
            function_signatures: HashMap::new(),
            scopes: vec![Scope::new()], // Global scope
        }
    }

    /// Get the type registry
    pub fn registry(&self) -> &TypeRegistry {
        &self.builder.registry
    }

    /// Intern a string
    pub fn intern(&mut self, s: &str) -> InternedString {
        self.builder.intern(s)
    }

    // ===== Top-Level Building =====

    /// Build a complete program from pest pairs
    pub fn build_program(&mut self, pairs: Pairs<Rule>) -> BuildResult<TypedProgram> {
        let mut declarations = Vec::new();
        let mut program_span = Span::new(0, 0);

        for pair in pairs {
            match pair.as_rule() {
                Rule::program => {
                    let span_range = pair.as_span();
                    program_span = Span::new(span_range.start(), span_range.end());

                    for inner_pair in pair.into_inner() {
                        match inner_pair.as_rule() {
                            Rule::declaration => {
                                declarations.push(self.build_declaration(inner_pair)?);
                            }
                            Rule::EOI => break,
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
        }

        Ok(TypedProgram {
            declarations,
            span: program_span,
        })
    }

    /// Build a declaration (const, var, fn, struct)
    fn build_declaration(&mut self, pair: Pair<Rule>) -> BuildResult<TypedNode<TypedDeclaration>> {
        let span_range = pair.as_span();
        let span = Span::new(span_range.start(), span_range.end());

        let inner = pair.into_inner().next().ok_or_else(|| {
            BuildError::Internal("Empty declaration".to_string())
        })?;

        match inner.as_rule() {
            Rule::const_decl => self.build_const_decl(inner, span),
            Rule::var_decl => self.build_var_decl(inner, span),
            Rule::fn_decl => self.build_fn_decl(inner, span),
            Rule::struct_decl => self.build_struct_decl(inner, span),
            _ => Err(BuildError::UnexpectedRule {
                expected: "declaration".to_string(),
                got: format!("{:?}", inner.as_rule()),
            }),
        }
    }

    // ===== Declaration Builders =====

    fn build_const_decl(&mut self, pair: Pair<Rule>, span: Span) -> BuildResult<TypedNode<TypedDeclaration>> {
        let mut inner = pair.into_inner();

        // const identifier : type_expr? = expr ;
        let name = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing name in const_decl".to_string())
        })?;
        let name_str = name.as_str();
        let interned_name = self.intern(name_str);

        // Check if next is type or expression
        let next = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing type or value in const_decl".to_string())
        })?;

        let (ty, init_expr) = match next.as_rule() {
            Rule::type_expr => {
                // Has explicit type annotation
                let ty = self.build_type_expr(next)?;
                let expr_pair = inner.next().ok_or_else(|| {
                    BuildError::Internal("Missing initializer in const_decl".to_string())
                })?;
                let expr = self.build_expression(expr_pair)?;
                (ty, expr)
            }
            Rule::expr => {
                // No type annotation, infer from expression
                let expr = self.build_expression(next)?;
                let ty = expr.ty.clone();
                (ty, expr)
            }
            _ => return Err(BuildError::UnexpectedRule {
                expected: "type_expr or expr".to_string(),
                got: format!("{:?}", next.as_rule()),
            }),
        };

        // Add to current scope
        self.current_scope().variables.insert(interned_name, ty.clone());

        // Create variable declaration
        let var_decl = self.builder.variable_declaration(
            name_str,
            ty.clone(),
            zyntax_typed_ast::Mutability::Immutable,
            Some(init_expr),
            zyntax_typed_ast::Visibility::Private,
            span,
        );

        Ok(var_decl)
    }

    fn build_var_decl(&mut self, pair: Pair<Rule>, span: Span) -> BuildResult<TypedNode<TypedDeclaration>> {
        let mut inner = pair.into_inner();

        // var identifier : type_expr? = expr ;
        let name = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing name in var_decl".to_string())
        })?;
        let name_str = name.as_str();
        let interned_name = self.intern(name_str);

        let next = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing type or value in var_decl".to_string())
        })?;

        let (ty, init_expr) = match next.as_rule() {
            Rule::type_expr => {
                let ty = self.build_type_expr(next)?;
                let expr_pair = inner.next().ok_or_else(|| {
                    BuildError::Internal("Missing initializer in var_decl".to_string())
                })?;
                let expr = self.build_expression(expr_pair)?;
                (ty, expr)
            }
            Rule::expr => {
                let expr = self.build_expression(next)?;
                let ty = expr.ty.clone();
                (ty, expr)
            }
            _ => return Err(BuildError::UnexpectedRule {
                expected: "type_expr or expr".to_string(),
                got: format!("{:?}", next.as_rule()),
            }),
        };

        // Add to current scope
        self.current_scope().variables.insert(interned_name, ty.clone());

        // Create variable declaration
        let var_decl = self.builder.variable_declaration(
            name_str,
            ty.clone(),
            zyntax_typed_ast::Mutability::Mutable,
            Some(init_expr),
            zyntax_typed_ast::Visibility::Private,
            span,
        );

        Ok(var_decl)
    }

    fn build_fn_decl(&mut self, pair: Pair<Rule>, span: Span) -> BuildResult<TypedNode<TypedDeclaration>> {
        use zyntax_typed_ast::typed_ast::TypedTypeParam;

        let mut inner = pair.into_inner();

        // Parse function name
        let name_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing function name".to_string())
        })?;
        let name = self.builder.intern(name_pair.as_str());

        // Parse parameters (optional)
        let mut params = Vec::new();
        let mut type_params = Vec::new();
        let mut next = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing function parameters or return type".to_string())
        })?;

        if next.as_rule() == Rule::fn_params {
            let (tp, p) = self.build_fn_params(next)?;
            type_params = tp;
            params = p;
            next = inner.next().ok_or_else(|| {
                BuildError::Internal("Missing return type".to_string())
            })?;
        }

        // Parse return type
        let return_type = self.build_type_expr(next)?;

        // Parse body (block)
        let body_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing function body".to_string())
        })?;

        // Enter new scope for function parameters
        self.enter_scope();

        // Add parameters to scope
        for param in &params {
            self.current_scope().variables.insert(param.name, param.ty.clone());
        }

        let body = self.build_block(body_pair)?;

        // Exit function scope
        self.exit_scope();

        // Store function signature for later reference (function calls)
        let fn_type = Type::Function {
            params: params.iter().map(|p| ParamInfo {
                name: Some(p.name),
                ty: p.ty.clone(),
                is_optional: false,
                is_varargs: false,
                is_keyword_only: false,
                is_positional_only: false,
                is_out: false,
                is_ref: false,
                is_inout: false,
            }).collect(),
            return_type: Box::new(return_type.clone()),
            is_varargs: false,
            has_named_params: false,
            has_default_params: false,
            async_kind: AsyncKind::Sync,
            calling_convention: CallingConvention::Default,
            nullability: NullabilityKind::NonNull,
        };
        self.function_signatures.insert(name, fn_type);

        // Create TypedFunction
        let typed_fn = TypedFunction {
            name,
            type_params,
            params,
            return_type,
            body: Some(body),
            visibility: Visibility::Private,
            is_async: false,
            is_external: false,
            calling_convention: CallingConvention::Default,
            link_name: None,
        };

        Ok(TypedNode {
            node: TypedDeclaration::Function(typed_fn),
            ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit),
            span,
        })
    }

    fn build_fn_params(&mut self, pair: Pair<Rule>) -> BuildResult<(Vec<zyntax_typed_ast::typed_ast::TypedTypeParam>, Vec<TypedParameter>)> {
        use zyntax_typed_ast::typed_ast::TypedTypeParam;

        let mut type_params = Vec::new();
        let mut params = Vec::new();

        for param_pair in pair.into_inner() {
            if param_pair.as_rule() == Rule::fn_param {
                let mut inner = param_pair.into_inner();
                let first = inner.next().ok_or_else(|| {
                    BuildError::Internal("Empty fn_param".to_string())
                })?;

                match first.as_rule() {
                    Rule::comptime_param => {
                        // comptime T: type -> type parameter
                        let comptime_span = first.as_span();
                        let mut comptime_inner = first.into_inner();
                        let name_pair = comptime_inner.next().ok_or_else(|| {
                            BuildError::Internal("Missing comptime parameter name".to_string())
                        })?;
                        let name = self.builder.intern(name_pair.as_str());

                        type_params.push(TypedTypeParam {
                            name,
                            bounds: vec![],
                            default: None,
                            span: Span::new(comptime_span.start(), comptime_span.end()),
                        });

                        // Also add to scope as a type variable
                        self.current_scope().variables.insert(
                            name,
                            Type::TypeVar(zyntax_typed_ast::TypeVar::unbound(name))
                        );
                    }
                    Rule::regular_param => {
                        // Regular parameter
                        params.push(self.build_regular_param(first)?);
                    }
                    _ => {
                        return Err(BuildError::UnexpectedRule {
                            expected: "comptime_param or regular_param".to_string(),
                            got: format!("{:?}", first.as_rule()),
                        });
                    }
                }
            }
        }

        Ok((type_params, params))
    }

    fn build_regular_param(&mut self, pair: Pair<Rule>) -> BuildResult<TypedParameter> {
        let span_range = pair.as_span();
        let span = Span::new(span_range.start(), span_range.end());

        let mut inner = pair.into_inner();

        // Parse parameter name
        let name_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing parameter name".to_string())
        })?;
        let name = self.builder.intern(name_pair.as_str());

        // Parse parameter type
        let type_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing parameter type".to_string())
        })?;
        let ty = self.build_type_expr(type_pair)?;

        // Use the helper method to create a regular parameter
        Ok(TypedParameter::regular(
            name,
            ty,
            Mutability::Immutable,  // Zig params are immutable by default
            span,
        ))
    }

    fn build_struct_decl(&mut self, pair: Pair<Rule>, span: Span) -> BuildResult<TypedNode<TypedDeclaration>> {
        let mut inner = pair.into_inner();

        // Skip "const" keyword (already consumed by parser)
        // Parse struct name
        let name_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing struct name".to_string())
        })?;
        let name = self.builder.intern(name_pair.as_str());

        // Parse fields
        let mut fields = Vec::new();
        for field_pair in inner {
            if field_pair.as_rule() == Rule::field_decl {
                fields.push(self.build_field_decl(field_pair)?);
            }
        }

        // Register struct type in the registry
        let type_id = TypeId::next();
        self.struct_types.insert(name, type_id);

        // Create TypedClass (Zyntax uses Class for struct-like types)
        let typed_class = TypedClass {
            name,
            type_params: Vec::new(),  // No generics yet
            extends: None,
            implements: Vec::new(),
            fields,
            methods: Vec::new(),
            constructors: Vec::new(),
            visibility: Visibility::Private,
            is_abstract: false,
            is_final: false,
            span,
        };

        Ok(TypedNode {
            node: TypedDeclaration::Class(typed_class),
            ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit),
            span,
        })
    }

    fn build_field_decl(&mut self, pair: Pair<Rule>) -> BuildResult<TypedField> {
        let span_range = pair.as_span();
        let span = Span::new(span_range.start(), span_range.end());

        let mut inner = pair.into_inner();

        // Parse field name
        let name_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing field name".to_string())
        })?;
        let name = self.builder.intern(name_pair.as_str());

        // Parse field type
        let type_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing field type".to_string())
        })?;
        let ty = self.build_type_expr(type_pair)?;

        Ok(TypedField {
            name,
            ty,
            initializer: None,  // Zig struct fields don't have default values in declaration
            visibility: Visibility::Public,  // Zig struct fields are public by default
            mutability: Mutability::Mutable,  // Fields are mutable
            is_static: false,
            span,
        })
    }

    // ===== Type Expression Builders =====

    fn build_type_expr(&mut self, pair: Pair<Rule>) -> BuildResult<Type> {
        let inner = pair.into_inner().next().ok_or_else(|| {
            BuildError::Internal("Empty type_expr".to_string())
        })?;

        match inner.as_rule() {
            Rule::primitive_type => self.build_primitive_type(inner),
            Rule::identifier => {
                let name = self.intern(inner.as_str());
                // Look up in struct types or type aliases
                if let Some(_type_id) = self.struct_types.get(&name) {
                    // Return named type
                    Ok(Type::Named {
                        id: *_type_id,
                        type_args: vec![],
                        const_args: vec![],
                        variance: vec![],
                        nullability: zyntax_typed_ast::NullabilityKind::NonNull,
                    })
                } else if let Some(alias_ty) = self.type_aliases.get(&name) {
                    Ok(alias_ty.clone())
                } else {
                    Err(BuildError::TypeNotFound(inner.as_str().to_string()))
                }
            }
            Rule::array_type => {
                // Grammar: "[" ~ integer_literal? ~ "]" ~ type_expr
                let mut inner_pairs = inner.into_inner();

                // First pair is either integer_literal (size) or type_expr
                let first = inner_pairs.next().unwrap();
                let (size, element_type) = if first.as_rule() == Rule::integer_literal {
                    // Sized array: [N]T
                    let size_value = first.as_str().parse::<u64>()
                        .map_err(|_| BuildError::ParseNumber(first.as_str().to_string()))?;
                    let elem_ty = self.build_type_expr(inner_pairs.next().unwrap())?;
                    (Some(zyntax_typed_ast::ConstValue::UInt(size_value)), elem_ty)
                } else {
                    // Dynamic array: []T
                    let elem_ty = self.build_type_expr(first)?;
                    (None, elem_ty)
                };

                Ok(Type::Array {
                    element_type: Box::new(element_type),
                    size,
                    nullability: zyntax_typed_ast::NullabilityKind::NonNull,
                })
            }
            Rule::pointer_type => {
                let element_type = self.build_type_expr(inner.into_inner().next().unwrap())?;
                Ok(Type::Reference {
                    ty: Box::new(element_type),
                    mutability: zyntax_typed_ast::Mutability::Immutable,
                    lifetime: None,
                    nullability: zyntax_typed_ast::NullabilityKind::NonNull,
                })
            }
            Rule::optional_type => {
                // Grammar: "?" ~ type_expr
                let inner_type = self.build_type_expr(inner.into_inner().next().unwrap())?;

                // In Zig, ?T is represented as Option<T>
                // Using TypedAST's Optional type which maps to Option<T> in HIR
                Ok(Type::Optional(Box::new(inner_type)))
            }
            Rule::error_union_type => {
                // Grammar: "!" ~ type_expr
                let value_type = self.build_type_expr(inner.into_inner().next().unwrap())?;

                // In Zig, !T is an error union type representing Result<T, Error>
                // Using TypedAST's Result type which maps to Result<T, E> in HIR
                // Error type defaults to i32 (error codes)
                let error_ty = Type::Primitive(zyntax_typed_ast::PrimitiveType::I32);
                Ok(Type::Result {
                    ok_type: Box::new(value_type),
                    err_type: Box::new(error_ty),
                })
            }
            _ => Err(BuildError::UnexpectedRule {
                expected: "type_expr".to_string(),
                got: format!("{:?}", inner.as_rule()),
            }),
        }
    }

    fn build_primitive_type(&mut self, pair: Pair<Rule>) -> BuildResult<Type> {
        use zyntax_typed_ast::PrimitiveType;

        let type_str = pair.as_str();
        let prim_type = match type_str {
            "i8" => PrimitiveType::I8,
            "i16" => PrimitiveType::I16,
            "i32" => PrimitiveType::I32,
            "i64" => PrimitiveType::I64,
            "i128" => PrimitiveType::I128,
            "u8" => PrimitiveType::U8,
            "u16" => PrimitiveType::U16,
            "u32" => PrimitiveType::U32,
            "u64" => PrimitiveType::U64,
            "u128" => PrimitiveType::U128,
            "f32" => PrimitiveType::F32,
            "f64" => PrimitiveType::F64,
            "bool" => PrimitiveType::Bool,
            "void" => PrimitiveType::Unit,
            _ => return Err(BuildError::Parse(format!("Unknown primitive type: {}", type_str))),
        };

        Ok(Type::Primitive(prim_type))
    }

    // ===== Statement Builders =====

    fn build_statement(&mut self, pair: Pair<Rule>) -> BuildResult<TypedNode<TypedStatement>> {
        let span_range = pair.as_span();
        let span = Span::new(span_range.start(), span_range.end());

        let inner = pair.into_inner().next().ok_or_else(|| {
            BuildError::Internal("Empty statement".to_string())
        })?;

        match inner.as_rule() {
            Rule::const_decl | Rule::var_decl => {
                // Both const and var declarations create Let statements
                let is_const = inner.as_rule() == Rule::const_decl;
                let mutability = if is_const {
                    zyntax_typed_ast::Mutability::Immutable
                } else {
                    zyntax_typed_ast::Mutability::Mutable
                };

                let mut decl_inner = inner.into_inner();
                let name_pair = decl_inner.next().ok_or_else(|| {
                    BuildError::Internal("Missing name in declaration".to_string())
                })?;
                let name_str = name_pair.as_str();
                let interned_name = self.intern(name_str);

                let next = decl_inner.next().ok_or_else(|| {
                    BuildError::Internal("Missing type or value".to_string())
                })?;

                let (ty, init_expr) = match next.as_rule() {
                    Rule::type_expr => {
                        let ty = self.build_type_expr(next)?;
                        let expr_pair = decl_inner.next().ok_or_else(|| {
                            BuildError::Internal("Missing initializer".to_string())
                        })?;
                        let expr = self.build_expression(expr_pair)?;
                        (ty, expr)
                    }
                    Rule::expr => {
                        let expr = self.build_expression(next)?;
                        let ty = expr.ty.clone();
                        (ty, expr)
                    }
                    _ => return Err(BuildError::UnexpectedRule {
                        expected: "type_expr or expr".to_string(),
                        got: format!("{:?}", next.as_rule()),
                    }),
                };

                // Add to current scope
                self.current_scope().variables.insert(interned_name, ty.clone());

                // Create Let statement
                let let_stmt = TypedStatement::Let(zyntax_typed_ast::typed_ast::TypedLet {
                    name: interned_name,
                    ty: ty.clone(),
                    mutability,
                    initializer: Some(Box::new(init_expr)),
                    span,
                });

                Ok(TypedNode {
                    node: let_stmt,
                    ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit),
                    span,
                })
            }
            Rule::assignment => self.build_assignment(inner, span),
            Rule::return_stmt => self.build_return_stmt(inner, span),
            Rule::expr_stmt => self.build_expr_stmt(inner, span),
            Rule::if_stmt => self.build_if_stmt(inner, span),
            Rule::while_stmt => self.build_while_stmt(inner, span),
            Rule::for_stmt => self.build_for_stmt(inner, span),
            Rule::break_stmt => self.build_break_stmt(span),
            Rule::continue_stmt => self.build_continue_stmt(span),
            _ => Err(BuildError::UnexpectedRule {
                expected: "statement".to_string(),
                got: format!("{:?}", inner.as_rule()),
            }),
        }
    }

    fn build_assignment(&mut self, pair: Pair<Rule>, span: Span) -> BuildResult<TypedNode<TypedStatement>> {
        let mut inner = pair.into_inner();

        // identifier = expr ;
        let name_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing variable name in assignment".to_string())
        })?;
        let name_str = name_pair.as_str();
        let interned_name = self.intern(name_str);

        let value_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing value in assignment".to_string())
        })?;
        let value = self.build_expression(value_pair)?;

        // Look up variable in scope to get its type
        let var_type = self.lookup_variable_type(interned_name)?;

        // Create assignment as a binary expression with Assign operator
        let target = TypedNode {
            node: TypedExpression::Variable(interned_name),
            ty: var_type.clone(),
            span,
        };

        let assign_expr = self.builder.binary(
            zyntax_typed_ast::BinaryOp::Assign,
            target,
            value,
            var_type,
            span,
        );

        // Wrap in expression statement
        Ok(TypedNode {
            node: TypedStatement::Expression(Box::new(assign_expr)),
            ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit),
            span,
        })
    }

    fn build_return_stmt(&mut self, pair: Pair<Rule>, span: Span) -> BuildResult<TypedNode<TypedStatement>> {
        let mut inner = pair.into_inner();

        // return expr? ;
        let return_value = if let Some(expr_pair) = inner.next() {
            Some(Box::new(self.build_expression(expr_pair)?))
        } else {
            None
        };

        Ok(TypedNode {
            node: TypedStatement::Return(return_value),
            ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit),
            span,
        })
    }

    fn build_expr_stmt(&mut self, pair: Pair<Rule>, span: Span) -> BuildResult<TypedNode<TypedStatement>> {
        let expr_pair = pair.into_inner().next().ok_or_else(|| {
            BuildError::Internal("Empty expression statement".to_string())
        })?;

        let expr = self.build_expression(expr_pair)?;

        Ok(TypedNode {
            node: TypedStatement::Expression(Box::new(expr)),
            ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit),
            span,
        })
    }

    fn build_if_stmt(&mut self, pair: Pair<Rule>, span: Span) -> BuildResult<TypedNode<TypedStatement>> {
        let mut inner = pair.into_inner();

        // if_stmt can be either if_let_stmt or if_regular_stmt
        let first = inner.next().ok_or_else(|| {
            BuildError::Internal("Empty if statement".to_string())
        })?;

        match first.as_rule() {
            Rule::if_let_stmt => self.build_if_let_stmt(first, span),
            Rule::if_regular_stmt => self.build_if_regular_stmt(first, span),
            _ => Err(BuildError::UnexpectedRule {
                expected: "if_let_stmt or if_regular_stmt".to_string(),
                got: format!("{:?}", first.as_rule()),
            }),
        }
    }

    fn build_if_regular_stmt(&mut self, pair: Pair<Rule>, span: Span) -> BuildResult<TypedNode<TypedStatement>> {
        let mut inner = pair.into_inner();

        // if ( condition ) block (else (if_stmt | block))?
        let condition_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing condition in if statement".to_string())
        })?;
        let condition = self.build_expression(condition_pair)?;

        let then_block_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing then block in if statement".to_string())
        })?;
        let then_block = self.build_block(then_block_pair)?;

        // Check for else clause
        let else_block = if let Some(else_pair) = inner.next() {
            match else_pair.as_rule() {
                Rule::if_stmt => {
                    // else if - convert to nested if in a block
                    let nested_if = self.build_if_stmt(else_pair, span)?;
                    Some(TypedBlock {
                        statements: vec![nested_if],
                        span,
                    })
                }
                Rule::block => {
                    // else block
                    Some(self.build_block(else_pair)?)
                }
                _ => None,
            }
        } else {
            None
        };

        let if_stmt = TypedStatement::If(zyntax_typed_ast::typed_ast::TypedIf {
            condition: Box::new(condition),
            then_block,
            else_block,
            span,
        });

        Ok(TypedNode {
            node: if_stmt,
            ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit),
            span,
        })
    }

    fn build_if_let_stmt(&mut self, pair: Pair<Rule>, span: Span) -> BuildResult<TypedNode<TypedStatement>> {
        let mut inner = pair.into_inner();

        // if ( let pattern = expr ) block (else (if_stmt | block))?
        let pattern_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing pattern in if let statement".to_string())
        })?;
        let pattern = self.build_pattern(pattern_pair)?;

        eprintln!("[AST] if-let pattern: {:?}", pattern.node);

        let scrutinee_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing expression in if let statement".to_string())
        })?;
        let scrutinee = self.build_expression(scrutinee_pair)?;

        eprintln!("[AST] if-let scrutinee: {:?}", scrutinee.node);

        // For Optional types, if-let with identifier pattern means "unwrap Some(x)"
        // Convert: if (let x = opt) â†’ match opt { Some(x) => ..., None => ... }
        let actual_pattern = if let Type::Optional(_) = &scrutinee.ty {
            if let TypedPattern::Identifier { name, mutability } = pattern.node {
                // Wrap identifier in Some enum pattern
                let optional_name = self.builder.intern("Optional");
                let some_name = self.builder.intern("Some");
                TypedNode {
                    node: TypedPattern::Enum {
                        name: optional_name,
                        variant: some_name,
                        fields: vec![TypedNode {
                            node: TypedPattern::Identifier { name, mutability },
                            ty: pattern.ty.clone(),
                            span: pattern.span,
                        }],
                    },
                    ty: scrutinee.ty.clone(),
                    span: pattern.span,
                }
            } else {
                pattern
            }
        } else {
            pattern
        };

        eprintln!("[AST] if-let actual pattern: {:?}", actual_pattern.node);

        // Note: Pattern bindings will be handled by the SSA layer when processing
        // the match arms. We don't add them here because they only exist in the
        // successful match arm, not before the match.

        let then_block_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing then block in if let statement".to_string())
        })?;
        let then_block = self.build_block(then_block_pair)?;

        // Check for else clause
        let else_block = if let Some(else_pair) = inner.next() {
            match else_pair.as_rule() {
                Rule::if_stmt => {
                    // else if - convert to nested if in a block
                    let nested_if = self.build_if_stmt(else_pair, span)?;
                    Some(TypedBlock {
                        statements: vec![nested_if],
                        span,
                    })
                }
                Rule::block => {
                    // else block
                    Some(self.build_block(else_pair)?)
                }
                _ => None,
            }
        } else {
            None
        };

        // Convert if let to match expression wrapped in a statement
        // match scrutinee { pattern => then_block, _ => else_block }
        let match_arms = if let Some(else_blk) = else_block {
            vec![
                TypedMatchArm {
                    pattern: Box::new(actual_pattern.clone()),
                    guard: None,
                    body: Box::new(TypedNode {
                        node: TypedExpression::Block(then_block),
                        ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit),
                        span,
                    }),
                },
                TypedMatchArm {
                    pattern: Box::new(TypedNode {
                        node: TypedPattern::Wildcard,
                        ty: scrutinee.ty.clone(),
                        span,
                    }),
                    guard: None,
                    body: Box::new(TypedNode {
                        node: TypedExpression::Block(else_blk),
                        ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit),
                        span,
                    }),
                },
            ]
        } else {
            vec![
                TypedMatchArm {
                    pattern: Box::new(actual_pattern),
                    guard: None,
                    body: Box::new(TypedNode {
                        node: TypedExpression::Block(then_block),
                        ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit),
                        span,
                    }),
                },
                TypedMatchArm {
                    pattern: Box::new(TypedNode {
                        node: TypedPattern::Wildcard,
                        ty: scrutinee.ty.clone(),
                        span,
                    }),
                    guard: None,
                    body: Box::new(TypedNode {
                        node: TypedExpression::Block(TypedBlock {
                            statements: vec![],
                            span,
                        }),
                        ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit),
                        span,
                    }),
                },
            ]
        };

        let match_stmt = TypedStatement::Match(TypedMatch {
            scrutinee: Box::new(scrutinee),
            arms: match_arms,
        });

        Ok(TypedNode {
            node: match_stmt,
            ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit),
            span,
        })
    }

    fn build_while_stmt(&mut self, pair: Pair<Rule>, span: Span) -> BuildResult<TypedNode<TypedStatement>> {
        let mut inner = pair.into_inner();

        // while ( condition ) block
        let condition_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing condition in while statement".to_string())
        })?;
        let condition = self.build_expression(condition_pair)?;

        let body_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing body in while statement".to_string())
        })?;
        let body = self.build_block(body_pair)?;

        let while_stmt = TypedStatement::While(zyntax_typed_ast::typed_ast::TypedWhile {
            condition: Box::new(condition),
            body,
            span,
        });

        Ok(TypedNode {
            node: while_stmt,
            ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit),
            span,
        })
    }

    fn build_for_stmt(&mut self, pair: Pair<Rule>, span: Span) -> BuildResult<TypedNode<TypedStatement>> {
        let mut inner = pair.into_inner();

        // for ( identifier in expr ) block
        let var_name_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing loop variable in for statement".to_string())
        })?;
        let var_name = self.builder.intern(var_name_pair.as_str());

        let iterator_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing iterator expression in for statement".to_string())
        })?;
        let iterator = self.build_expression(iterator_pair)?;

        // Enter new scope for loop variable
        self.enter_scope();

        // Add loop variable to scope (type inferred from iterator)
        // For now, default to i32
        self.current_scope().variables.insert(var_name, Type::Primitive(zyntax_typed_ast::PrimitiveType::I32));

        let body_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing body in for statement".to_string())
        })?;
        let body = self.build_block(body_pair)?;

        // Exit loop scope
        self.exit_scope();

        // Create pattern for loop variable (simple identifier pattern)
        let pattern = TypedPattern::Identifier {
            name: var_name,
            mutability: Mutability::Immutable,
        };

        let for_stmt = TypedStatement::For(TypedFor {
            pattern: Box::new(TypedNode {
                node: pattern,
                ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::I32),
                span,
            }),
            iterator: Box::new(iterator),
            body,
        });

        Ok(TypedNode {
            node: for_stmt,
            ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit),
            span,
        })
    }

    fn build_break_stmt(&mut self, span: Span) -> BuildResult<TypedNode<TypedStatement>> {
        Ok(TypedNode {
            node: TypedStatement::Break(None),  // No break value for now
            ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit),
            span,
        })
    }

    fn build_continue_stmt(&mut self, span: Span) -> BuildResult<TypedNode<TypedStatement>> {
        Ok(TypedNode {
            node: TypedStatement::Continue,
            ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit),
            span,
        })
    }

    fn build_block(&mut self, pair: Pair<Rule>) -> BuildResult<TypedBlock> {
        let span_range = pair.as_span();
        let span = Span::new(span_range.start(), span_range.end());

        // Enter new scope for block
        self.enter_scope();

        let mut statements = Vec::new();
        for stmt_pair in pair.into_inner() {
            statements.push(self.build_statement(stmt_pair)?);
        }

        // Exit scope
        self.exit_scope();

        Ok(TypedBlock { statements, span })
    }

    // Helper to look up variable type from scope
    fn lookup_variable_type(&self, name: InternedString) -> BuildResult<Type> {
        // Search scopes from innermost to outermost
        for scope in self.scopes.iter().rev() {
            if let Some(ty) = scope.variables.get(&name) {
                return Ok(ty.clone());
            }
        }

        Err(BuildError::TypeNotFound(format!("Variable not found: {:?}", name)))
    }

    // ===== Expression Builders =====

    fn build_expression(&mut self, pair: Pair<Rule>) -> BuildResult<TypedNode<TypedExpression>> {
        // Entry point - delegates to logical_or (lowest precedence)
        let inner = pair.into_inner().next().ok_or_else(|| {
            BuildError::Internal("Empty expression".to_string())
        })?;
        self.build_logical_or(inner)
    }

    fn build_logical_or(&mut self, pair: Pair<Rule>) -> BuildResult<TypedNode<TypedExpression>> {
        self.build_binary_expr_chain(pair, Rule::logical_and, "or")
    }

    fn build_logical_and(&mut self, pair: Pair<Rule>) -> BuildResult<TypedNode<TypedExpression>> {
        self.build_binary_expr_chain(pair, Rule::equality, "and")
    }

    fn build_equality(&mut self, pair: Pair<Rule>) -> BuildResult<TypedNode<TypedExpression>> {
        self.build_binary_expr_chain(pair, Rule::comparison, "==")
    }

    fn build_comparison(&mut self, pair: Pair<Rule>) -> BuildResult<TypedNode<TypedExpression>> {
        self.build_binary_expr_chain(pair, Rule::addition, "<")
    }

    fn build_addition(&mut self, pair: Pair<Rule>) -> BuildResult<TypedNode<TypedExpression>> {
        self.build_binary_expr_chain(pair, Rule::multiplication, "+")
    }

    fn build_multiplication(&mut self, pair: Pair<Rule>) -> BuildResult<TypedNode<TypedExpression>> {
        self.build_binary_expr_chain(pair, Rule::unary, "*")
    }

    /// Generic binary expression chain builder (handles left-associative operators)
    fn build_binary_expr_chain(
        &mut self,
        pair: Pair<Rule>,
        operand_rule: Rule,
        _op_hint: &str, // For debugging
    ) -> BuildResult<TypedNode<TypedExpression>> {
        let mut inner_pairs = pair.into_inner();

        // Get first operand
        let first = inner_pairs.next().ok_or_else(|| {
            BuildError::Internal("Empty binary expression chain".to_string())
        })?;

        let mut left = match operand_rule {
            Rule::logical_and => self.build_logical_and(first)?,
            Rule::equality => self.build_equality(first)?,
            Rule::comparison => self.build_comparison(first)?,
            Rule::addition => self.build_addition(first)?,
            Rule::multiplication => self.build_multiplication(first)?,
            Rule::unary => self.build_unary(first)?,
            _ => return Err(BuildError::Internal(format!("Unexpected operand rule: {:?}", operand_rule))),
        };

        // Process operators and operands
        while let Some(op_pair) = inner_pairs.next() {
            let op_str = op_pair.as_str();
            let right_pair = inner_pairs.next().ok_or_else(|| {
                BuildError::Internal("Missing right operand in binary expression".to_string())
            })?;

            let right = match operand_rule {
                Rule::logical_and => self.build_logical_and(right_pair)?,
                Rule::equality => self.build_equality(right_pair)?,
                Rule::comparison => self.build_comparison(right_pair)?,
                Rule::addition => self.build_addition(right_pair)?,
                Rule::multiplication => self.build_multiplication(right_pair)?,
                Rule::unary => self.build_unary(right_pair)?,
                _ => return Err(BuildError::Internal(format!("Unexpected operand rule: {:?}", operand_rule))),
            };

            let op = self.convert_binary_op(op_str)?;
            // Infer result type from left operand for now
            let result_type = left.ty.clone();
            let span = Span::new(0, 0);
            left = self.builder.binary(op, left, right, result_type, span);
        }

        Ok(left)
    }

    fn build_unary(&mut self, pair: Pair<Rule>) -> BuildResult<TypedNode<TypedExpression>> {
        let mut inner = pair.into_inner();
        let first = inner.next().ok_or_else(|| {
            BuildError::Internal("Empty unary expression".to_string())
        })?;

        match first.as_rule() {
            Rule::unary_op => {
                // Unary operator followed by operand
                let op_str = first.as_str();
                let operand_pair = inner.next().ok_or_else(|| {
                    BuildError::Internal("Missing operand in unary expression".to_string())
                })?;
                let operand = self.build_unary(operand_pair)?;
                let op = self.convert_unary_op(op_str)?;
                let result_type = operand.ty.clone();
                let span = Span::new(0, 0);
                Ok(self.builder.unary(op, operand, result_type, span))
            }
            Rule::postfix => {
                // Postfix expression
                self.build_postfix(first)
            }
            _ => Err(BuildError::UnexpectedRule {
                expected: "unary or postfix".to_string(),
                got: format!("{:?}", first.as_rule()),
            }),
        }
    }

    fn build_postfix(&mut self, pair: Pair<Rule>) -> BuildResult<TypedNode<TypedExpression>> {
        let mut inner = pair.into_inner();
        let primary_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Empty postfix expression".to_string())
        })?;

        let mut expr = self.build_primary(primary_pair)?;

        // Process postfix operators (field access, indexing, calls)
        for postfix_op in inner {
            expr = self.build_postfix_op(expr, postfix_op)?;
        }

        Ok(expr)
    }

    fn build_postfix_op(&mut self, base: TypedNode<TypedExpression>, pair: Pair<Rule>) -> BuildResult<TypedNode<TypedExpression>> {
        let span_range = pair.as_span();
        let span = Span::new(span_range.start(), span_range.end());

        let mut inner = pair.into_inner();
        let first_opt = inner.next();

        // Determine the type of postfix operation based on the first inner element
        match first_opt {
            Some(first) => {
                match first.as_rule() {
                    Rule::identifier => {
                        // Field access: base.field
                        let field_name = self.builder.intern(first.as_str());

                        // Determine field type (simplified - just use i32 for now)
                        // TODO: Proper field type lookup from struct definition
                        let field_type = Type::Primitive(zyntax_typed_ast::PrimitiveType::I32);

                        let field_access = TypedFieldAccess {
                            object: Box::new(base),
                            field: field_name,
                        };

                        Ok(TypedNode {
                            node: TypedExpression::Field(field_access),
                            ty: field_type,
                            span,
                        })
                    }
                    Rule::expr => {
                        // Array indexing: base[expr]
                        let index_expr = self.build_expression(first)?;

                        // Extract element type from array type
                        let element_type = match &base.ty {
                            Type::Array { element_type, .. } => (**element_type).clone(),
                            _ => {
                                // Not an array type - default to i32 for robustness
                                Type::Primitive(zyntax_typed_ast::PrimitiveType::I32)
                            }
                        };

                        let index = TypedIndex {
                            object: Box::new(base),
                            index: Box::new(index_expr),
                        };

                        Ok(TypedNode {
                            node: TypedExpression::Index(index),
                            ty: element_type,
                            span,
                        })
                    }
                    Rule::args => {
                        // Function call: base(args)
                        let args = self.build_args(first)?;

                        // Determine return type from function signature
                        let return_type = if let TypedExpression::Variable(fn_name) = &base.node {
                            // Look up function signature
                            if let Some(Type::Function { return_type, .. }) = self.function_signatures.get(fn_name) {
                                (**return_type).clone()
                            } else {
                                // Unknown function - default to i32 for now
                                Type::Primitive(zyntax_typed_ast::PrimitiveType::I32)
                            }
                        } else {
                            // Complex callee expression - use base type if it's a function
                            match &base.ty {
                                Type::Function { return_type, .. } => (**return_type).clone(),
                                _ => Type::Primitive(zyntax_typed_ast::PrimitiveType::I32),
                            }
                        };

                        let call_expr = TypedExpression::Call(zyntax_typed_ast::typed_ast::TypedCall {
                            callee: Box::new(base),
                            positional_args: args,
                            named_args: Vec::new(),
                            type_args: Vec::new(),
                        });

                        Ok(TypedNode {
                            node: call_expr,
                            ty: return_type,
                            span,
                        })
                    }
                    _ => {
                        Err(BuildError::Internal(format!("Unknown postfix_op inner rule: {:?}", first.as_rule())))
                    }
                }
            }
            None => {
                // Empty inner means function call with no arguments: base()
                // Determine return type from function signature
                let return_type = if let TypedExpression::Variable(fn_name) = &base.node {
                    if let Some(Type::Function { return_type, .. }) = self.function_signatures.get(fn_name) {
                        (**return_type).clone()
                    } else {
                        Type::Primitive(zyntax_typed_ast::PrimitiveType::I32)
                    }
                } else {
                    match &base.ty {
                        Type::Function { return_type, .. } => (**return_type).clone(),
                        _ => Type::Primitive(zyntax_typed_ast::PrimitiveType::I32),
                    }
                };

                let call_expr = TypedExpression::Call(zyntax_typed_ast::typed_ast::TypedCall {
                    callee: Box::new(base),
                    positional_args: Vec::new(),
                    named_args: Vec::new(),
                    type_args: Vec::new(),
                });

                Ok(TypedNode {
                    node: call_expr,
                    ty: return_type,
                    span,
                })
            }
        }
    }

    fn build_args(&mut self, pair: Pair<Rule>) -> BuildResult<Vec<TypedNode<TypedExpression>>> {
        let mut args = Vec::new();

        for expr_pair in pair.into_inner() {
            if expr_pair.as_rule() == Rule::expr {
                args.push(self.build_expression(expr_pair)?);
            }
        }

        Ok(args)
    }

    fn build_struct_literal(&mut self, pair: Pair<Rule>) -> BuildResult<TypedNode<TypedExpression>> {
        let span_range = pair.as_span();
        let span = Span::new(span_range.start(), span_range.end());

        let mut inner = pair.into_inner();

        // Parse struct name
        let name_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing struct name in literal".to_string())
        })?;
        let name = self.builder.intern(name_pair.as_str());

        // Parse field initializers
        let mut fields = Vec::new();
        for field_pair in inner {
            if field_pair.as_rule() == Rule::struct_field_init {
                fields.push(self.build_struct_field_init(field_pair)?);
            }
        }

        // Lookup struct type
        let struct_type = if let Some(type_id) = self.struct_types.get(&name) {
            Type::Named {
                id: *type_id,
                type_args: Vec::new(),
                const_args: Vec::new(),
                variance: Vec::new(),
                nullability: NullabilityKind::NonNull,
            }
        } else {
            // Unknown struct - create a placeholder type
            Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit)
        };

        let struct_lit = TypedStructLiteral {
            name,
            fields,
        };

        Ok(TypedNode {
            node: TypedExpression::Struct(struct_lit),
            ty: struct_type,
            span,
        })
    }

    fn build_struct_field_init(&mut self, pair: Pair<Rule>) -> BuildResult<TypedFieldInit> {
        let mut inner = pair.into_inner();

        // Parse field name (after the '.')
        let name_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing field name in init".to_string())
        })?;
        let name = self.builder.intern(name_pair.as_str());

        // Parse field value expression
        let value_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing field value in init".to_string())
        })?;
        let value = Box::new(self.build_expression(value_pair)?);

        Ok(TypedFieldInit {
            name,
            value,
        })
    }

    fn build_primary(&mut self, pair: Pair<Rule>) -> BuildResult<TypedNode<TypedExpression>> {
        let inner = pair.into_inner().next().ok_or_else(|| {
            BuildError::Internal("Empty primary expression".to_string())
        })?;

        match inner.as_rule() {
            Rule::literal => self.build_literal(inner),
            Rule::identifier => {
                let name = inner.as_str();
                let span_range = inner.as_span();
                let span = Span::new(span_range.start(), span_range.end());

                // Intern the name ONCE to ensure consistent symbols
                let interned_name = self.builder.intern(name);

                // Look up variable type from scope
                let ty = self.lookup_variable_type(interned_name)
                    .unwrap_or_else(|_| {
                        // If not found, default to i32 (for literals in expressions)
                        Type::Primitive(zyntax_typed_ast::PrimitiveType::I32)
                    });

                // Use the pre-interned name directly
                Ok(typed_node(TypedExpression::Variable(interned_name), ty, span))
            }
            Rule::expr => {
                // Parenthesized expression
                self.build_expression(inner)
            }
            Rule::struct_literal => {
                self.build_struct_literal(inner)
            }
            Rule::switch_expr => {
                self.build_switch_expr(inner)
            }
            _ => Err(BuildError::UnexpectedRule {
                expected: "primary".to_string(),
                got: format!("{:?}", inner.as_rule()),
            }),
        }
    }

    fn convert_binary_op(&mut self, op_str: &str) -> BuildResult<zyntax_typed_ast::BinaryOp> {
        use zyntax_typed_ast::BinaryOp;

        let op = match op_str {
            "+" => BinaryOp::Add,
            "-" => BinaryOp::Sub,
            "*" => BinaryOp::Mul,
            "/" => BinaryOp::Div,
            "%" => BinaryOp::Rem,
            "==" => BinaryOp::Eq,
            "!=" => BinaryOp::Ne,
            "<" => BinaryOp::Lt,
            "<=" => BinaryOp::Le,
            ">" => BinaryOp::Gt,
            ">=" => BinaryOp::Ge,
            "and" => BinaryOp::And,
            "or" => BinaryOp::Or,
            _ => return Err(BuildError::Parse(format!("Unknown binary operator: {}", op_str))),
        };

        Ok(op)
    }

    fn convert_unary_op(&mut self, op_str: &str) -> BuildResult<zyntax_typed_ast::UnaryOp> {
        use zyntax_typed_ast::UnaryOp;

        let op = match op_str {
            "-" => UnaryOp::Minus,
            "!" => UnaryOp::Not,
            _ => return Err(BuildError::Parse(format!("Unknown unary operator: {}", op_str))),
        };

        Ok(op)
    }

    // ===== Literal Builders =====

    fn build_literal(&mut self, pair: Pair<Rule>) -> BuildResult<TypedNode<TypedExpression>> {
        let span_range = pair.as_span();
        let span = Span::new(span_range.start(), span_range.end());

        let inner = pair.into_inner().next().ok_or_else(|| {
            BuildError::Internal("Empty literal".to_string())
        })?;

        match inner.as_rule() {
            Rule::bool_literal => self.build_bool_literal(inner, span),
            Rule::integer_literal => self.build_integer_literal(inner, span),
            Rule::float_literal => self.build_float_literal(inner, span),
            Rule::string_literal => self.build_string_literal(inner, span),
            Rule::array_literal => self.build_array_literal(inner, span),
            _ => Err(BuildError::UnexpectedRule {
                expected: "literal".to_string(),
                got: format!("{:?}", inner.as_rule()),
            }),
        }
    }

    fn build_bool_literal(&mut self, pair: Pair<Rule>, span: Span) -> BuildResult<TypedNode<TypedExpression>> {
        let value = pair.as_str() == "true";
        Ok(self.builder.bool_literal(value, span))
    }

    fn build_integer_literal(&mut self, pair: Pair<Rule>, span: Span) -> BuildResult<TypedNode<TypedExpression>> {
        let text = pair.as_str();
        let value: i128 = text.parse()
            .map_err(|_| BuildError::ParseNumber(text.to_string()))?;
        Ok(self.builder.int_literal(value, span))
    }

    fn build_float_literal(&mut self, pair: Pair<Rule>, span: Span) -> BuildResult<TypedNode<TypedExpression>> {
        let text = pair.as_str();
        let value: f64 = text.parse()
            .map_err(|_| BuildError::ParseNumber(text.to_string()))?;

        // For now, convert float to int (Phase 1 limitation)
        // TODO: Add proper float support in Week 2
        let int_value = value as i128;
        Ok(self.builder.int_literal(int_value, span))
    }

    fn build_string_literal(&mut self, pair: Pair<Rule>, span: Span) -> BuildResult<TypedNode<TypedExpression>> {
        // Extract the string_inner content
        let inner = pair.into_inner().next().ok_or_else(|| {
            BuildError::Internal("Empty string literal".to_string())
        })?;

        let text = inner.as_str();
        Ok(self.builder.string_literal(text, span))
    }

    fn build_array_literal(&mut self, pair: Pair<Rule>, span: Span) -> BuildResult<TypedNode<TypedExpression>> {
        // Grammar: "[" ~ "_" ~ "]" ~ type_expr ~ "{" ~ (expr ~ ("," ~ expr)*)? ~ "}"
        // Note: Pest only returns parsed sub-rules, not literal tokens like "[", "_", "]", "{"
        // So inner will be: [type_expr, expr, expr, ...]
        let mut inner = pair.into_inner();

        // First inner pair is the type_expr
        let type_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing type in array literal".to_string())
        })?;
        let element_type = self.build_type_expr(type_pair)?;

        // Remaining inner pairs are the array element expressions
        let mut elements = Vec::new();
        for expr_pair in inner {
            let expr = self.build_expression(expr_pair)?;
            elements.push(expr);
        }

        // Build the full array type with inferred size
        let array_size = elements.len() as u64;
        let array_type = Type::Array {
            element_type: Box::new(element_type),
            size: Some(zyntax_typed_ast::ConstValue::UInt(array_size)),
            nullability: zyntax_typed_ast::NullabilityKind::NonNull,
        };

        Ok(self.builder.array_literal(elements, array_type, span))
    }

    // ===== Pattern Matching =====

    fn build_pattern(&mut self, pair: Pair<Rule>) -> BuildResult<TypedNode<TypedPattern>> {
        let span_range = pair.as_span();
        let span = Span::new(span_range.start(), span_range.end());

        let inner = pair.into_inner().next().ok_or_else(|| {
            BuildError::Internal("Empty pattern".to_string())
        })?;

        match inner.as_rule() {
            Rule::wildcard_pattern => {
                Ok(TypedNode {
                    node: TypedPattern::Wildcard,
                    ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit), // Will be refined
                    span,
                })
            }
            Rule::identifier_pattern => {
                let mut parts = inner.into_inner();
                let first = parts.next().ok_or_else(|| {
                    BuildError::Internal("Empty identifier pattern".to_string())
                })?;

                // Check if it's "mut identifier" or just "identifier"
                let (mutability, name_str) = if first.as_str() == "mut" {
                    let name_pair = parts.next().ok_or_else(|| {
                        BuildError::Internal("Missing identifier after mut".to_string())
                    })?;
                    (Mutability::Mutable, name_pair.as_str())
                } else {
                    (Mutability::Immutable, first.as_str())
                };

                let name = self.intern(name_str);

                Ok(TypedNode {
                    node: TypedPattern::Identifier { name, mutability },
                    ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit), // Will be refined
                    span,
                })
            }
            Rule::literal_pattern => {
                // Build the literal inside
                let lit_pair = inner.into_inner().next().ok_or_else(|| {
                    BuildError::Internal("Empty literal pattern".to_string())
                })?;

                let lit_expr = self.build_literal(lit_pair)?;

                // Convert TypedExpression::Literal to TypedPattern::Literal
                let pattern_lit = match &lit_expr.node {
                    TypedExpression::Literal(TypedLiteral::Integer(i)) => {
                        TypedLiteralPattern::Integer(*i)
                    }
                    TypedExpression::Literal(TypedLiteral::Bool(b)) => {
                        TypedLiteralPattern::Bool(*b)
                    }
                    TypedExpression::Literal(TypedLiteral::String(s)) => {
                        TypedLiteralPattern::String(*s)
                    }
                    TypedExpression::Literal(TypedLiteral::Float(f)) => {
                        TypedLiteralPattern::Float(*f)
                    }
                    TypedExpression::Literal(TypedLiteral::Char(c)) => {
                        TypedLiteralPattern::Char(*c)
                    }
                    TypedExpression::Literal(TypedLiteral::Unit) => {
                        TypedLiteralPattern::Unit
                    }
                    _ => return Err(BuildError::Internal("Invalid literal in pattern".to_string())),
                };

                Ok(TypedNode {
                    node: TypedPattern::Literal(pattern_lit),
                    ty: lit_expr.ty,
                    span,
                })
            }
            Rule::enum_pattern => {
                // identifier ( pattern )
                let mut parts = inner.into_inner();

                let variant_name_pair = parts.next().ok_or_else(|| {
                    BuildError::Internal("Missing variant name in enum pattern".to_string())
                })?;
                let variant_name = self.intern(variant_name_pair.as_str());

                let inner_pattern_pair = parts.next().ok_or_else(|| {
                    BuildError::Internal("Missing inner pattern in enum pattern".to_string())
                })?;
                let inner_pattern = self.build_pattern(inner_pattern_pair)?;

                Ok(TypedNode {
                    node: TypedPattern::Enum {
                        name: variant_name, // Use variant name as both enum and variant for now
                        variant: variant_name,
                        fields: vec![inner_pattern],
                    },
                    ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit), // Will be refined
                    span,
                })
            }
            _ => Err(BuildError::UnexpectedRule {
                expected: "pattern variant".to_string(),
                got: format!("{:?}", inner.as_rule()),
            }),
        }
    }

    fn add_pattern_bindings(&mut self, pattern: &TypedPattern, scrutinee_ty: &Type) {
        match pattern {
            TypedPattern::Identifier { name, .. } => {
                // For optional types, extract the inner type
                let binding_type = match scrutinee_ty {
                    Type::Optional(inner_ty) => (**inner_ty).clone(),
                    Type::Result { ok_type, .. } => (**ok_type).clone(),
                    _ => scrutinee_ty.clone(),
                };
                self.current_scope().variables.insert(*name, binding_type);
            }
            TypedPattern::Enum { fields, .. } => {
                // Recursively add bindings from nested patterns
                for field_pattern in fields {
                    self.add_pattern_bindings(&field_pattern.node, scrutinee_ty);
                }
            }
            TypedPattern::Tuple(patterns) => {
                for pattern_node in patterns {
                    self.add_pattern_bindings(&pattern_node.node, scrutinee_ty);
                }
            }
            TypedPattern::Array(patterns) => {
                for pattern_node in patterns {
                    self.add_pattern_bindings(&pattern_node.node, scrutinee_ty);
                }
            }
            // Other patterns don't bind variables
            _ => {}
        }
    }

    // ===== Scope Management =====

    fn enter_scope(&mut self) {
        self.scopes.push(Scope::new());
    }

    fn exit_scope(&mut self) {
        self.scopes.pop();
    }

    fn current_scope(&mut self) -> &mut Scope {
        self.scopes.last_mut().expect("No scope available")
    }

    fn build_switch_expr(&mut self, pair: Pair<Rule>) -> BuildResult<TypedNode<TypedExpression>> {
        let span_range = pair.as_span();
        let span = Span::new(span_range.start(), span_range.end());
        let mut inner = pair.into_inner();

        // Parse scrutinee expression
        let scrutinee_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Missing scrutinee in switch expression".to_string())
        })?;
        let scrutinee = self.build_expression(scrutinee_pair)?;

        // Parse switch cases
        let mut arms = Vec::new();
        for case_pair in inner {
            if case_pair.as_rule() == Rule::switch_case {
                let mut case_inner = case_pair.into_inner();

                // Parse pattern
                let pattern_pair = case_inner.next().ok_or_else(|| {
                    BuildError::Internal("Missing pattern in switch case".to_string())
                })?;

                let pattern = self.build_switch_pattern(pattern_pair, &scrutinee.ty)?;

                // Parse body expression
                let body_pair = case_inner.next().ok_or_else(|| {
                    BuildError::Internal("Missing body in switch case".to_string())
                })?;
                let body = self.build_expression(body_pair)?;

                arms.push(TypedMatchArm {
                    pattern: Box::new(pattern),
                    guard: None,
                    body: Box::new(body),
                });
            }
        }

        // Infer result type from first arm's body
        let result_ty = arms.first()
            .map(|arm| arm.body.ty.clone())
            .unwrap_or(Type::Primitive(zyntax_typed_ast::PrimitiveType::Unit));

        // Convert switch to match expression
        let match_expr = TypedExpression::Match(TypedMatchExpr {
            scrutinee: Box::new(scrutinee),
            arms,
        });

        Ok(typed_node(match_expr, result_ty, span))
    }

    fn build_switch_pattern(
        &mut self,
        pair: Pair<Rule>,
        scrutinee_ty: &Type,
    ) -> BuildResult<TypedNode<TypedPattern>> {
        let span_range = pair.as_span();
        let span = Span::new(span_range.start(), span_range.end());
        let mut inner = pair.into_inner();

        let pattern_pair = inner.next().ok_or_else(|| {
            BuildError::Internal("Empty switch pattern".to_string())
        })?;

        let pattern = match pattern_pair.as_rule() {
            Rule::integer_literal => {
                // Literal pattern: 1 => expr
                // Parse the integer directly
                let text = pattern_pair.as_str();
                let value: i128 = text.parse()
                    .map_err(|_| BuildError::ParseNumber(text.to_string()))?;
                TypedPattern::Literal(TypedLiteralPattern::Integer(value))
            }
            Rule::switch_else => {
                // Wildcard pattern for else
                TypedPattern::Wildcard
            }
            Rule::identifier => {
                // Enum variant pattern
                let name_str = pattern_pair.as_str();
                let variant_name = self.builder.intern(name_str);
                TypedPattern::Enum {
                    name: variant_name,
                    variant: variant_name,
                    fields: vec![],
                }
            }
            _ => {
                return Err(BuildError::UnexpectedRule {
                    expected: "switch_pattern".to_string(),
                    got: format!("{:?}", pattern_pair.as_rule()),
                });
            }
        };

        Ok(typed_node(pattern, scrutinee_ty.clone(), span))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use pest::Parser;

    #[test]
    fn test_parse_empty_program() {
        let source = "";
        let pairs = ZigParser::parse(Rule::program, source).unwrap();
        let mut builder = ZigBuilder::new();
        let program = builder.build_program(pairs).unwrap();
        assert_eq!(program.declarations.len(), 0);
    }

    #[test]
    fn test_parse_bool_literal() {
        let source = "true";
        let result = ZigParser::parse(Rule::bool_literal, source);
        assert!(result.is_ok());

        let source = "false";
        let result = ZigParser::parse(Rule::bool_literal, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_integer_literal() {
        let source = "42";
        let result = ZigParser::parse(Rule::integer_literal, source);
        assert!(result.is_ok());

        let source = "-123";
        let result = ZigParser::parse(Rule::integer_literal, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_float_literal() {
        let source = "3.14";
        let result = ZigParser::parse(Rule::float_literal, source);
        assert!(result.is_ok());

        let source = "-2.71";
        let result = ZigParser::parse(Rule::float_literal, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_string_literal() {
        let source = r#""hello world""#;
        let result = ZigParser::parse(Rule::string_literal, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_primitive_types() {
        let types = vec!["i32", "u64", "f32", "bool", "void"];
        for ty in types {
            let result = ZigParser::parse(Rule::primitive_type, ty);
            assert!(result.is_ok(), "Failed to parse type: {}", ty);
        }
    }

    #[test]
    fn test_build_primitive_types() {
        let mut builder = ZigBuilder::new();

        let pairs = ZigParser::parse(Rule::primitive_type, "i32").unwrap();
        let ty = builder.build_primitive_type(pairs.into_iter().next().unwrap()).unwrap();
        assert!(matches!(ty, Type::Primitive(zyntax_typed_ast::PrimitiveType::I32)));

        let pairs = ZigParser::parse(Rule::primitive_type, "bool").unwrap();
        let ty = builder.build_primitive_type(pairs.into_iter().next().unwrap()).unwrap();
        assert!(matches!(ty, Type::Primitive(zyntax_typed_ast::PrimitiveType::Bool)));
    }

    #[test]
    fn test_build_integer_literal() {
        let mut builder = ZigBuilder::new();

        let pairs = ZigParser::parse(Rule::integer_literal, "42").unwrap();
        let pair = pairs.into_iter().next().unwrap();
        let span = Span::new(0, 2);
        let expr = builder.build_integer_literal(pair, span).unwrap();

        // Verify it's an integer literal
        use zyntax_typed_ast::typed_ast::{TypedExpression, TypedLiteral};
        assert!(matches!(expr.node, TypedExpression::Literal(TypedLiteral::Integer(42))));
    }

    #[test]
    fn test_build_bool_literal() {
        let mut builder = ZigBuilder::new();

        let pairs = ZigParser::parse(Rule::bool_literal, "true").unwrap();
        let pair = pairs.into_iter().next().unwrap();
        let span = Span::new(0, 4);
        let expr = builder.build_bool_literal(pair, span).unwrap();

        // Verify it's a bool literal
        use zyntax_typed_ast::typed_ast::{TypedExpression, TypedLiteral};
        assert!(matches!(expr.node, TypedExpression::Literal(TypedLiteral::Bool(true))));
    }

    #[test]
    fn test_parse_binary_expr() {
        let source = "2 + 3";
        let result = ZigParser::parse(Rule::expr, source);
        assert!(result.is_ok());

        let source = "10 * 5 - 3";
        let result = ZigParser::parse(Rule::expr, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_comparison() {
        let source = "x < 10";
        let result = ZigParser::parse(Rule::expr, source);
        assert!(result.is_ok());

        let source = "a == b";
        let result = ZigParser::parse(Rule::expr, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_logical() {
        let source = "true and false";
        let result = ZigParser::parse(Rule::expr, source);
        assert!(result.is_ok());

        let source = "x > 5 or y < 10";
        let result = ZigParser::parse(Rule::expr, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_unary() {
        let source = "-42";
        let result = ZigParser::parse(Rule::expr, source);
        assert!(result.is_ok());

        let source = "!flag";
        let result = ZigParser::parse(Rule::expr, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_parenthesized() {
        let source = "(2 + 3) * 4";
        let result = ZigParser::parse(Rule::expr, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_build_simple_binary() {
        let mut builder = ZigBuilder::new();

        let source = "2 + 3";
        let pairs = ZigParser::parse(Rule::expr, source).unwrap();
        let expr = builder.build_expression(pairs.into_iter().next().unwrap()).unwrap();

        // Verify it's a binary expression
        use zyntax_typed_ast::typed_ast::TypedExpression;
        assert!(matches!(expr.node, TypedExpression::Binary(_)));
    }

    #[test]
    fn test_build_unary_minus() {
        let mut builder = ZigBuilder::new();

        let source = "-42";
        let pairs = ZigParser::parse(Rule::expr, source).unwrap();
        let expr = builder.build_expression(pairs.into_iter().next().unwrap()).unwrap();

        // Verify it's a unary expression
        use zyntax_typed_ast::typed_ast::TypedExpression;
        assert!(matches!(expr.node, TypedExpression::Unary(_)));
    }

    #[test]
    fn test_operator_precedence() {
        // Test that "1 + 2 * 3" is parsed correctly (multiplication before addition)
        let source = "1 + 2 * 3";
        let result = ZigParser::parse(Rule::expr, source);
        assert!(result.is_ok());

        // Should parse as: 1 + (2 * 3)
        // The grammar structure ensures this via precedence levels
    }

    // ===== Statement Tests =====

    #[test]
    fn test_parse_const_decl() {
        let source = "const x = 42;";
        let result = ZigParser::parse(Rule::const_decl, source);
        assert!(result.is_ok());

        let source = "const y: i32 = 10;";
        let result = ZigParser::parse(Rule::const_decl, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_var_decl() {
        let source = "var x = 42;";
        let result = ZigParser::parse(Rule::var_decl, source);
        assert!(result.is_ok());

        let source = "var y: i32 = 10;";
        let result = ZigParser::parse(Rule::var_decl, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_assignment() {
        let source = "x = 42;";
        let result = ZigParser::parse(Rule::assignment, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_return() {
        let source = "return 42;";
        let result = ZigParser::parse(Rule::return_stmt, source);
        assert!(result.is_ok());

        let source = "return;";
        let result = ZigParser::parse(Rule::return_stmt, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_block() {
        let source = "{ const x = 1; const y = 2; }";
        let result = ZigParser::parse(Rule::block, source);
        assert!(result.is_ok());

        let source = "{}";
        let result = ZigParser::parse(Rule::block, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_build_const_decl() {
        let mut builder = ZigBuilder::new();

        let source = "const x = 42;";
        let pairs = ZigParser::parse(Rule::const_decl, source).unwrap();
        let pair = pairs.into_iter().next().unwrap();
        let span = Span::new(0, source.len());

        // Build the const decl through statement builder
        let stmt_pair = ZigParser::parse(Rule::statement, source).unwrap().into_iter().next().unwrap();
        let stmt = builder.build_statement(stmt_pair).unwrap();

        // Verify it's a Let statement
        use zyntax_typed_ast::typed_ast::TypedStatement;
        assert!(matches!(stmt.node, TypedStatement::Let(_)));

        // Verify variable was added to scope
        let name = builder.intern("x");
        assert!(builder.lookup_variable_type(name).is_ok());
    }

    #[test]
    fn test_build_block_with_scope() {
        let mut builder = ZigBuilder::new();

        let source = "{ const x = 1; const y = 2; }";
        let pairs = ZigParser::parse(Rule::block, source).unwrap();
        let block = builder.build_block(pairs.into_iter().next().unwrap()).unwrap();

        // Verify block has 2 statements
        assert_eq!(block.statements.len(), 2);

        // Variables should NOT be in scope after block exits
        let x_name = builder.intern("x");
        assert!(builder.lookup_variable_type(x_name).is_err());
    }

    #[test]
    fn test_variable_scope_lookup() {
        let mut builder = ZigBuilder::new();

        // Add variable to scope
        let x_name = builder.intern("x");
        let ty = Type::Primitive(zyntax_typed_ast::PrimitiveType::I32);
        builder.current_scope().variables.insert(x_name, ty.clone());

        // Should be able to look it up
        let looked_up = builder.lookup_variable_type(x_name).unwrap();
        assert_eq!(looked_up, ty);

        // Unknown variable should fail
        let y_name = builder.intern("y");
        assert!(builder.lookup_variable_type(y_name).is_err());
    }

    // ===== Control Flow Tests =====

    #[test]
    fn test_parse_if_stmt() {
        let source = "if (x > 0) { return 1; }";
        let result = ZigParser::parse(Rule::if_stmt, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_if_else() {
        let source = "if (x > 0) { return 1; } else { return 0; }";
        let result = ZigParser::parse(Rule::if_stmt, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_if_else_if() {
        let source = "if (x > 0) { return 1; } else if (x < 0) { return -1; } else { return 0; }";
        let result = ZigParser::parse(Rule::if_stmt, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_while() {
        let source = "while (i < 10) { i = i + 1; }";
        let result = ZigParser::parse(Rule::while_stmt, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_build_if_stmt() {
        let mut builder = ZigBuilder::new();

        let source = "if (true) { const x = 1; }";
        let pairs = ZigParser::parse(Rule::if_stmt, source).unwrap();
        let pair = pairs.into_iter().next().unwrap();
        let span = Span::new(0, source.len());
        let stmt = builder.build_if_stmt(pair, span).unwrap();

        // Verify it's an If statement
        use zyntax_typed_ast::typed_ast::TypedStatement;
        assert!(matches!(stmt.node, TypedStatement::If(_)));
    }

    #[test]
    fn test_build_if_else() {
        let mut builder = ZigBuilder::new();

        let source = "if (true) { const x = 1; } else { const y = 2; }";
        let pairs = ZigParser::parse(Rule::if_stmt, source).unwrap();
        let pair = pairs.into_iter().next().unwrap();
        let span = Span::new(0, source.len());
        let stmt = builder.build_if_stmt(pair, span).unwrap();

        // Verify it's an If statement
        use zyntax_typed_ast::typed_ast::TypedStatement;
        if let TypedStatement::If(if_stmt) = &stmt.node {
            assert!(if_stmt.else_block.is_some());
        } else {
            panic!("Expected If statement");
        }
    }

    #[test]
    fn test_build_while() {
        let mut builder = ZigBuilder::new();

        let source = "while (true) { const x = 1; }";
        let pairs = ZigParser::parse(Rule::while_stmt, source).unwrap();
        let pair = pairs.into_iter().next().unwrap();
        let span = Span::new(0, source.len());
        let stmt = builder.build_while_stmt(pair, span).unwrap();

        // Verify it's a While statement
        use zyntax_typed_ast::typed_ast::TypedStatement;
        assert!(matches!(stmt.node, TypedStatement::While(_)));
    }

    #[test]
    fn test_nested_control_flow() {
        // Test parsing nested if and while
        let source = "if (true) { while (false) { const x = 1; } }";
        let result = ZigParser::parse(Rule::if_stmt, source);
        assert!(result.is_ok());
    }

    // ===== Function Tests =====

    #[test]
    fn test_parse_fn_decl_no_params() {
        let source = "fn foo() i32 { return 42; }";
        let result = ZigParser::parse(Rule::fn_decl, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_fn_decl_with_params() {
        let source = "fn add(x: i32, y: i32) i32 { return x + y; }";
        let result = ZigParser::parse(Rule::fn_decl, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_fn_decl_void_return() {
        let source = "fn print_hello() void { const x = 1; }";
        let result = ZigParser::parse(Rule::fn_decl, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_build_fn_decl_no_params() {
        let mut builder = ZigBuilder::new();

        let source = "fn foo() i32 { return 42; }";
        let pairs = ZigParser::parse(Rule::fn_decl, source).unwrap();
        let pair = pairs.into_iter().next().unwrap();
        let span = Span::new(0, source.len());
        let decl = builder.build_fn_decl(pair, span).unwrap();

        // Verify it's a Function declaration
        use zyntax_typed_ast::typed_ast::TypedDeclaration;
        if let TypedDeclaration::Function(func) = &decl.node {
            assert_eq!(func.params.len(), 0);
            assert_eq!(func.return_type, Type::Primitive(zyntax_typed_ast::PrimitiveType::I32));
        } else {
            panic!("Expected Function declaration");
        }
    }

    #[test]
    fn test_build_fn_decl_with_params() {
        let mut builder = ZigBuilder::new();

        let source = "fn add(x: i32, y: i32) i32 { return 10; }";
        let pairs = ZigParser::parse(Rule::fn_decl, source).unwrap();
        let pair = pairs.into_iter().next().unwrap();
        let span = Span::new(0, source.len());
        let decl = builder.build_fn_decl(pair, span).unwrap();

        // Verify it's a Function declaration
        use zyntax_typed_ast::typed_ast::TypedDeclaration;
        if let TypedDeclaration::Function(func) = &decl.node {
            assert_eq!(func.params.len(), 2);
            assert_eq!(func.params[0].ty, Type::Primitive(zyntax_typed_ast::PrimitiveType::I32));
            assert_eq!(func.params[1].ty, Type::Primitive(zyntax_typed_ast::PrimitiveType::I32));
            assert_eq!(func.return_type, Type::Primitive(zyntax_typed_ast::PrimitiveType::I32));
        } else {
            panic!("Expected Function declaration");
        }
    }

    #[test]
    fn test_build_fn_decl_stores_signature() {
        let mut builder = ZigBuilder::new();

        let source = "fn add(x: i32, y: i32) i32 { return 10; }";
        let pairs = ZigParser::parse(Rule::fn_decl, source).unwrap();
        let pair = pairs.into_iter().next().unwrap();
        let span = Span::new(0, source.len());
        builder.build_fn_decl(pair, span).unwrap();

        // Verify function signature was stored
        let add_name = builder.intern("add");
        assert!(builder.function_signatures.contains_key(&add_name));
    }

    #[test]
    fn test_parse_function_call_no_args() {
        let source = "foo()";
        let result = ZigParser::parse(Rule::expr, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_function_call_with_args() {
        let source = "add(1, 2)";
        let result = ZigParser::parse(Rule::expr, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_function_call_nested() {
        let source = "add(mul(2, 3), 4)";
        let result = ZigParser::parse(Rule::expr, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_build_function_call_no_args() {
        let mut builder = ZigBuilder::new();

        // First, register a function signature
        let foo_name = builder.intern("foo");
        builder.function_signatures.insert(
            foo_name,
            Type::Function {
                params: vec![],
                return_type: Box::new(Type::Primitive(zyntax_typed_ast::PrimitiveType::I32)),
                is_varargs: false,
                has_named_params: false,
                has_default_params: false,
                async_kind: AsyncKind::Sync,
                calling_convention: CallingConvention::Default,
                nullability: NullabilityKind::NonNull,
            },
        );

        let source = "foo()";
        let pairs = ZigParser::parse(Rule::expr, source).unwrap();
        let pair = pairs.into_iter().next().unwrap();
        let expr = builder.build_expression(pair).unwrap();

        // Verify it's a Call expression
        if let TypedExpression::Call(call) = &expr.node {
            assert_eq!(call.positional_args.len(), 0);
            assert_eq!(expr.ty, Type::Primitive(zyntax_typed_ast::PrimitiveType::I32));
        } else {
            panic!("Expected Call expression");
        }
    }

    #[test]
    fn test_build_function_call_with_args() {
        let mut builder = ZigBuilder::new();

        // First, intern all strings
        let add_name = builder.intern("add");
        let x_name = builder.intern("x");
        let y_name = builder.intern("y");

        // Register a function signature
        builder.function_signatures.insert(
            add_name,
            Type::Function {
                params: vec![
                    ParamInfo {
                        name: Some(x_name),
                        ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::I32),
                        is_optional: false,
                        is_varargs: false,
                        is_keyword_only: false,
                        is_positional_only: false,
                        is_out: false,
                        is_ref: false,
                        is_inout: false,
                    },
                    ParamInfo {
                        name: Some(y_name),
                        ty: Type::Primitive(zyntax_typed_ast::PrimitiveType::I32),
                        is_optional: false,
                        is_varargs: false,
                        is_keyword_only: false,
                        is_positional_only: false,
                        is_out: false,
                        is_ref: false,
                        is_inout: false,
                    },
                ],
                return_type: Box::new(Type::Primitive(zyntax_typed_ast::PrimitiveType::I32)),
                is_varargs: false,
                has_named_params: false,
                has_default_params: false,
                async_kind: AsyncKind::Sync,
                calling_convention: CallingConvention::Default,
                nullability: NullabilityKind::NonNull,
            },
        );

        let source = "add(1, 2)";
        let pairs = ZigParser::parse(Rule::expr, source).unwrap();
        let pair = pairs.into_iter().next().unwrap();
        let expr = builder.build_expression(pair).unwrap();

        // Verify it's a Call expression
        if let TypedExpression::Call(call) = &expr.node {
            assert_eq!(call.positional_args.len(), 2);
            assert_eq!(expr.ty, Type::Primitive(zyntax_typed_ast::PrimitiveType::I32));
        } else {
            panic!("Expected Call expression");
        }
    }

    #[test]
    fn test_function_with_parameters_in_scope() {
        let mut builder = ZigBuilder::new();

        // Function that uses its parameters in the body
        let source = "fn add(x: i32, y: i32) i32 { return x + y; }";
        let pairs = ZigParser::parse(Rule::fn_decl, source).unwrap();
        let pair = pairs.into_iter().next().unwrap();
        let span = Span::new(0, source.len());
        let result = builder.build_fn_decl(pair, span);

        // Should succeed - parameters should be available in function body
        assert!(result.is_ok());
    }

    #[test]
    fn test_complete_program_with_function() {
        let source = r#"
            fn add(x: i32, y: i32) i32 {
                return x + y;
            }
        "#;

        let pairs = ZigParser::parse(Rule::program, source).unwrap();
        let mut builder = ZigBuilder::new();
        let program = builder.build_program(pairs).unwrap();

        assert_eq!(program.declarations.len(), 1);
    }

    // ===== Struct Tests =====

    #[test]
    fn test_parse_struct_decl_empty() {
        let source = "const Point = struct {};";
        let result = ZigParser::parse(Rule::struct_decl, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_struct_decl_with_fields() {
        let source = "const Point = struct { x: i32, y: i32, };";
        let result = ZigParser::parse(Rule::struct_decl, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_struct_decl_multiple_fields() {
        let source = "const Person = struct { name: i32, age: i32, height: f32, };";
        let result = ZigParser::parse(Rule::struct_decl, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_build_struct_decl_empty() {
        let mut builder = ZigBuilder::new();

        let source = "const Point = struct {};";
        let pairs = ZigParser::parse(Rule::struct_decl, source).unwrap();
        let pair = pairs.into_iter().next().unwrap();
        let span = Span::new(0, source.len());
        let decl = builder.build_struct_decl(pair, span).unwrap();

        // Verify it's a Class declaration (struct)
        use zyntax_typed_ast::typed_ast::TypedDeclaration;
        if let TypedDeclaration::Class(class) = &decl.node {
            assert_eq!(class.fields.len(), 0);
        } else {
            panic!("Expected Class declaration");
        }
    }

    #[test]
    fn test_build_struct_decl_with_fields() {
        let mut builder = ZigBuilder::new();

        let source = "const Point = struct { x: i32, y: i32, };";
        let pairs = ZigParser::parse(Rule::struct_decl, source).unwrap();
        let pair = pairs.into_iter().next().unwrap();
        let span = Span::new(0, source.len());
        let decl = builder.build_struct_decl(pair, span).unwrap();

        // Verify it's a Class declaration with 2 fields
        use zyntax_typed_ast::typed_ast::TypedDeclaration;
        if let TypedDeclaration::Class(class) = &decl.node {
            assert_eq!(class.fields.len(), 2);
            assert_eq!(class.fields[0].ty, Type::Primitive(zyntax_typed_ast::PrimitiveType::I32));
            assert_eq!(class.fields[1].ty, Type::Primitive(zyntax_typed_ast::PrimitiveType::I32));
        } else {
            panic!("Expected Class declaration");
        }
    }

    #[test]
    fn test_build_struct_registers_type() {
        let mut builder = ZigBuilder::new();

        let source = "const Point = struct { x: i32, y: i32, };";
        let pairs = ZigParser::parse(Rule::struct_decl, source).unwrap();
        let pair = pairs.into_iter().next().unwrap();
        let span = Span::new(0, source.len());
        builder.build_struct_decl(pair, span).unwrap();

        // Verify struct type was registered
        let point_name = builder.intern("Point");
        assert!(builder.struct_types.contains_key(&point_name));
    }

    #[test]
    fn test_parse_struct_literal_empty() {
        let source = "Point{}";
        let result = ZigParser::parse(Rule::struct_literal, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_struct_literal_with_fields() {
        let source = "Point{.x = 10, .y = 20}";
        let result = ZigParser::parse(Rule::struct_literal, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_struct_literal_in_expression() {
        let source = "Point{.x = 1 + 2, .y = 3 * 4}";
        let result = ZigParser::parse(Rule::expr, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_build_struct_literal_empty() {
        let mut builder = ZigBuilder::new();

        // First register the struct type
        let point_name = builder.intern("Point");
        let type_id = TypeId::next();
        builder.struct_types.insert(point_name, type_id);

        let source = "Point{}";
        let pairs = ZigParser::parse(Rule::struct_literal, source).unwrap();
        let pair = pairs.into_iter().next().unwrap();
        let expr = builder.build_struct_literal(pair).unwrap();

        // Verify it's a Struct expression
        if let TypedExpression::Struct(struct_lit) = &expr.node {
            assert_eq!(struct_lit.fields.len(), 0);
        } else {
            panic!("Expected Struct expression");
        }
    }

    #[test]
    fn test_build_struct_literal_with_fields() {
        let mut builder = ZigBuilder::new();

        // Register the struct type
        let point_name = builder.intern("Point");
        let type_id = TypeId::next();
        builder.struct_types.insert(point_name, type_id);

        let source = "Point{.x = 10, .y = 20}";
        let pairs = ZigParser::parse(Rule::struct_literal, source).unwrap();
        let pair = pairs.into_iter().next().unwrap();
        let expr = builder.build_struct_literal(pair).unwrap();

        // Verify it's a Struct expression with 2 fields
        if let TypedExpression::Struct(struct_lit) = &expr.node {
            assert_eq!(struct_lit.fields.len(), 2);
        } else {
            panic!("Expected Struct expression");
        }
    }

    #[test]
    fn test_build_struct_literal_type_lookup() {
        let mut builder = ZigBuilder::new();

        // Register the struct type
        let point_name = builder.intern("Point");
        let type_id = TypeId::next();
        builder.struct_types.insert(point_name, type_id);

        let source = "Point{.x = 10, .y = 20}";
        let pairs = ZigParser::parse(Rule::struct_literal, source).unwrap();
        let pair = pairs.into_iter().next().unwrap();
        let expr = builder.build_struct_literal(pair).unwrap();

        // Verify type is Named with correct type_id
        match &expr.ty {
            Type::Named { id, .. } => {
                assert_eq!(*id, type_id);
            }
            _ => panic!("Expected Named type"),
        }
    }

    #[test]
    fn test_parse_field_access() {
        let source = "point.x";
        let result = ZigParser::parse(Rule::expr, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_field_access_chained() {
        let source = "a.b.c";
        let result = ZigParser::parse(Rule::expr, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_field_access_in_expression() {
        let source = "point.x + point.y";
        let result = ZigParser::parse(Rule::expr, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_complete_program_with_struct() {
        // Simpler test - just check that struct decl parses in program
        let source = r#"
            const Point = struct {
                x: i32,
                y: i32,
            };
        "#;

        let pairs = ZigParser::parse(Rule::program, source).unwrap();
        let mut builder = ZigBuilder::new();
        let program = builder.build_program(pairs).unwrap();

        assert_eq!(program.declarations.len(), 1); // Point struct
    }

    // ===== Week 4 Tests: For Loops, Break/Continue, Array Indexing =====

    #[test]
    fn test_parse_for_stmt() {
        let source = "for (i in range) { const x = 1; }";
        let result = ZigParser::parse(Rule::for_stmt, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_break_stmt() {
        let source = "break;";
        let result = ZigParser::parse(Rule::break_stmt, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_continue_stmt() {
        let source = "continue;";
        let result = ZigParser::parse(Rule::continue_stmt, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_build_for_stmt() {
        let mut builder = ZigBuilder::new();

        let source = "for (i in items) { const x = i; }";
        let pairs = ZigParser::parse(Rule::for_stmt, source).unwrap();
        let pair = pairs.into_iter().next().unwrap();
        let span = Span::new(0, source.len());
        let stmt = builder.build_for_stmt(pair, span).unwrap();

        // Verify it's a For statement
        use zyntax_typed_ast::typed_ast::TypedStatement;
        assert!(matches!(stmt.node, TypedStatement::For(_)));
    }

    #[test]
    fn test_build_break_stmt() {
        let mut builder = ZigBuilder::new();

        let span = Span::new(0, 6);
        let stmt = builder.build_break_stmt(span).unwrap();

        // Verify it's a Break statement
        use zyntax_typed_ast::typed_ast::TypedStatement;
        assert!(matches!(stmt.node, TypedStatement::Break(_)));
    }

    #[test]
    fn test_build_continue_stmt() {
        let mut builder = ZigBuilder::new();

        let span = Span::new(0, 9);
        let stmt = builder.build_continue_stmt(span).unwrap();

        // Verify it's a Continue statement
        use zyntax_typed_ast::typed_ast::TypedStatement;
        assert!(matches!(stmt.node, TypedStatement::Continue));
    }

    #[test]
    fn test_for_with_break_continue() {
        let source = r#"for (i in items) { if (true) { break; } if (false) { continue; } const x = 1; }"#;
        let result = ZigParser::parse(Rule::for_stmt, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_array_indexing() {
        let source = "arr[0]";
        let result = ZigParser::parse(Rule::expr, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_array_indexing_expression() {
        let source = "arr[i + 1]";
        let result = ZigParser::parse(Rule::expr, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_chained_array_indexing() {
        let source = "matrix[i][j]";
        let result = ZigParser::parse(Rule::expr, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_nested_loops() {
        let source = r#"for (i in outer) { for (j in inner) { const x = 1; } }"#;
        let result = ZigParser::parse(Rule::for_stmt, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_while_with_break() {
        let source = r#"while (true) { if (false) { break; } const x = 1; }"#;
        let result = ZigParser::parse(Rule::while_stmt, source);
        assert!(result.is_ok());
    }

    #[test]
    fn test_for_loop_variable_scope() {
        let mut builder = ZigBuilder::new();

        let source = "for (item in items) { const x = item; }";
        let pairs = ZigParser::parse(Rule::for_stmt, source).unwrap();
        let pair = pairs.into_iter().next().unwrap();
        let span = Span::new(0, source.len());
        let result = builder.build_for_stmt(pair, span);

        // Should succeed - loop variable should be in scope
        assert!(result.is_ok());
    }
}
