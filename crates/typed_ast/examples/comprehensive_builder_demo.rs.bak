//! # Comprehensive TypedAST Builder Demonstration
//!
//! This example showcases the full capabilities of the enhanced TypedAST builder,
//! demonstrating all the patterns and constructs that are now supported.

use zyntax_typed_ast::{
    TypedASTBuilder,
    typed_ast::*,
    Type, PrimitiveType, Mutability, Visibility, Variance,
    Span,
};

fn main() {
    println!("ðŸš€ Comprehensive TypedAST Builder Demonstration\n");

    let mut builder = TypedASTBuilder::new();
    let span = Span::new(0, 10);

    // ====== Enhanced Parameter System Demo ======
    println!("ðŸ“‹ Enhanced Parameter System:");
    
    // Regular parameter
    let regular_param = builder.parameter("x", Type::Primitive(PrimitiveType::I32), Mutability::Immutable, span);
    println!("âœ… Regular parameter: {}", builder.arena().resolve_string(regular_param.name).unwrap());
    
    // Optional parameter with default value
    let default_value = builder.int_literal(42, span);
    let optional_param = builder.optional_parameter(
        "y", 
        Type::Primitive(PrimitiveType::I32), 
        Mutability::Immutable, 
        default_value, 
        span
    );
    println!("âœ… Optional parameter with default: {}", builder.arena().resolve_string(optional_param.name).unwrap());
    
    // Rest/variadic parameter
    let rest_param = builder.rest_parameter("args", Type::Primitive(PrimitiveType::I32), Mutability::Immutable, span);
    println!("âœ… Rest parameter: {}", builder.arena().resolve_string(rest_param.name).unwrap());
    
    // Out parameter (C#-style)
    let out_param = builder.out_parameter("result", Type::Primitive(PrimitiveType::I32), span);
    println!("âœ… Out parameter: {}", builder.arena().resolve_string(out_param.name).unwrap());
    
    // Ref parameter (C#-style)
    let ref_param = builder.ref_parameter("value", Type::Primitive(PrimitiveType::I32), Mutability::Mutable, span);
    println!("âœ… Ref parameter: {}", builder.arena().resolve_string(ref_param.name).unwrap());
    
    // InOut parameter (Swift-style)
    let inout_param = builder.inout_parameter("data", Type::Primitive(PrimitiveType::I32), span);
    println!("âœ… InOut parameter: {}", builder.arena().resolve_string(inout_param.name).unwrap());

    // ====== Named Arguments in Function Calls Demo ======
    println!("\nðŸ”§ Named Arguments & Function Calls:");
    
    let func_var = builder.variable("calculate", Type::Primitive(PrimitiveType::I32), span);
    let arg1 = builder.int_literal(10, span);
    let arg2 = builder.int_literal(20, span);
    
    // Function call with named arguments
    let named_call = builder.call_named(
        func_var,
        vec![("width", arg1), ("height", arg2)],
        Type::Primitive(PrimitiveType::I32),
        span,
    );
    println!("âœ… Named function call: calculate(width: 10, height: 20)");
    
    // Mixed positional and named arguments
    let func_var2 = builder.variable("process", Type::Primitive(PrimitiveType::String), span);
    let pos_arg = builder.string_literal("data", span);
    let named_arg1 = builder.bool_literal(true, span);
    let named_arg2 = builder.int_literal(100, span);
    
    let mixed_call = builder.call_mixed(
        func_var2,
        vec![pos_arg],
        vec![("debug", named_arg1), ("timeout", named_arg2)],
        vec![],
        Type::Primitive(PrimitiveType::String),
        span,
    );
    println!("âœ… Mixed call: process(\"data\", debug: true, timeout: 100)");

    // ====== Pattern Matching Builders Demo ======
    println!("\nðŸŽ¯ Advanced Pattern Matching:");
    
    // Struct pattern
    let px_var = builder.intern("px");
    let py_var = builder.intern("py");
    let struct_pattern = builder.struct_pattern(
        "Point",
        vec![
            ("x", typed_node(TypedPattern::immutable_var(px_var), Type::Unknown, span)),
            ("y", typed_node(TypedPattern::immutable_var(py_var), Type::Unknown, span)),
        ],
        span,
    );
    println!("âœ… Struct pattern: Point {{ x: px, y: py }}");
    
    // Enum pattern
    let value_var = builder.intern("value");
    let enum_pattern = builder.enum_pattern(
        "Option",
        "Some",
        vec![typed_node(TypedPattern::immutable_var(value_var), Type::Unknown, span)],
        span,
    );
    println!("âœ… Enum pattern: Some(value)");
    
    // Array pattern
    let first_var = builder.intern("first");
    let array_pattern = builder.array_pattern(
        vec![
            typed_node(TypedPattern::immutable_var(first_var), Type::Unknown, span),
            typed_node(TypedPattern::wildcard(), Type::Unknown, span),
        ],
        span,
    );
    println!("âœ… Array pattern: [first, _]");
    
    // Slice pattern with rest
    let middle_var = builder.intern("middle");
    let last_var = builder.intern("last");
    let slice_pattern = builder.slice_pattern(
        vec![typed_node(TypedPattern::immutable_var(first_var), Type::Unknown, span)],
        Some(typed_node(TypedPattern::Rest { 
            name: Some(middle_var), 
            mutability: Mutability::Immutable 
        }, Type::Unknown, span)),
        vec![typed_node(TypedPattern::immutable_var(last_var), Type::Unknown, span)],
        span,
    );
    println!("âœ… Slice pattern: [first, ..middle, last]");
    
    // Map pattern
    let rest_var = builder.intern("rest");
    let n_var = builder.intern("n");
    let a_var = builder.intern("a");
    let map_pattern = builder.map_pattern(
        vec![
            ("name", typed_node(TypedPattern::immutable_var(n_var), Type::Unknown, span)),
            ("age", typed_node(TypedPattern::immutable_var(a_var), Type::Unknown, span)),
        ],
        Some(("rest", Mutability::Immutable)),
        false,
        span,
    );
    println!("âœ… Map pattern: {{ name: n, age: a, ..rest }}");

    // ====== Expression Builders Demo ======
    println!("\nðŸ”§ Expression Building:");
    
    // Various literals
    let int_expr = builder.int_literal(42, span);
    let str_expr = builder.string_literal("hello world", span);
    let bool_expr = builder.bool_literal(true, span);
    let char_expr = builder.char_literal('ðŸ¦€', span);
    let unit_expr = builder.unit_literal(span);
    
    println!("âœ… Literals: integer(42), string(\"hello world\"), bool(true), char('ðŸ¦€'), unit");
    
    // Binary operations
    let x_var = builder.variable("x", Type::Primitive(PrimitiveType::I32), span);
    let y_var = builder.variable("y", Type::Primitive(PrimitiveType::I32), span);
    let add_expr = builder.binary(
        BinaryOp::Add,
        x_var,
        y_var,
        Type::Primitive(PrimitiveType::I32),
        span,
    );
    println!("âœ… Binary expression: x + y");
    
    // Method call
    let obj_var = builder.variable("obj", Type::Primitive(PrimitiveType::String), span);
    let method_call = builder.method_call(
        obj_var,
        "len",
        vec![],
        Type::Primitive(PrimitiveType::I32),
        span,
    );
    println!("âœ… Method call: obj.len()");
    
    // Struct literal
    let x_val = builder.int_literal(10, span);
    let y_val = builder.int_literal(20, span);
    let point_name = builder.intern("Point");
    let struct_lit = builder.struct_literal(
        "Point",
        vec![
            ("x", x_val),
            ("y", y_val),
        ],
        Type::Named { name: point_name, type_args: vec![] },
        span,
    );
    println!("âœ… Struct literal: Point {{ x: 10, y: 20 }}");

    // ====== Statement Builders Demo ======
    println!("\nðŸ“ Statement Building:");
    
    // Let statement
    let init_val = builder.int_literal(0, span);
    let let_stmt = builder.let_statement(
        "counter",
        Type::Primitive(PrimitiveType::I32),
        Mutability::Mutable,
        Some(init_val),
        span,
    );
    println!("âœ… Let statement: let mut counter: i32 = 0");
    
    // If statement
    let condition = builder.bool_literal(true, span);
    let int_lit_1 = builder.int_literal(1, span);
    let then_stmt = builder.expression_statement(int_lit_1, span);
    let then_block = builder.block(vec![then_stmt], span);
    let int_lit_2 = builder.int_literal(2, span);
    let else_stmt = builder.expression_statement(int_lit_2, span);
    let else_block = builder.block(vec![else_stmt], span);
    let if_stmt = builder.if_statement(condition, then_block, Some(else_block), span);
    println!("âœ… If statement: if true {{ 1 }} else {{ 2 }}");
    
    // For loop
    let iterable = builder.variable("items", Type::Array { element_type: Box::new(Type::Primitive(PrimitiveType::I32)), size: None }, span);
    let item_var = builder.variable("item", Type::Primitive(PrimitiveType::I32), span);
    let loop_stmt = builder.expression_statement(item_var, span);
    let loop_body = builder.block(vec![loop_stmt], span);
    let for_stmt = builder.for_loop("item", iterable, loop_body, span);
    println!("âœ… For loop: for item in items {{ item }}");

    // ====== Coroutine & Async Builders Demo ======
    println!("\nâš¡ Coroutine & Async Features:");
    
    // Async coroutine
    let async_body = builder.int_literal(42, span);
    let async_stmt = builder.coroutine(CoroutineKind::Async, async_body, vec![], span);
    println!("âœ… Async coroutine: async {{ 42 }}");
    
    // Defer statement
    let cleanup_expr = builder.variable("cleanup", Type::Primitive(PrimitiveType::Unit), span);
    let defer_stmt = builder.defer(cleanup_expr, span);
    println!("âœ… Defer statement: defer cleanup");

    // ====== Function Declaration Demo ======
    println!("\nðŸ—ï¸ Function Declaration:");
    
    // Build a comprehensive function with various parameter types
    let params = vec![
        regular_param,
        optional_param,
        rest_param,
    ];
    
    let func_stmt = builder.expression_statement(add_expr, span);
    let func_body = builder.block(vec![func_stmt], span);
    
    let function = builder.function(
        "calculate_sum",
        params,
        Type::Primitive(PrimitiveType::I32),
        func_body,
        Visibility::Public,
        false,
        span,
    );
    
    println!("âœ… Function: pub fn calculate_sum(x: i32, y: i32 = 42, ..args: i32) -> i32");

    // ====== Complete Program Demo ======
    println!("\nðŸŽ¯ Complete Program:");
    
    // Create a program with multiple declarations
    let program = builder.program(vec![function], span);
    
    println!("âœ… Program with {} declarations", program.declarations.len());

    // ====== Summary ======
    println!("\nðŸŽ‰ TypedAST Builder Features Summary:");
    println!("ðŸ“‹ Enhanced Parameter System:");
    println!("   â€¢ Regular, Optional, Rest, Out, Ref, InOut parameters");
    println!("   â€¢ Default values for optional parameters");
    println!("   â€¢ Parameter attributes for validation");
    
    println!("ðŸ“‹ Advanced Function Calls:");
    println!("   â€¢ Named arguments support");
    println!("   â€¢ Mixed positional and named arguments");
    println!("   â€¢ Generic type arguments");
    
    println!("ðŸ“‹ Comprehensive Pattern Matching:");
    println!("   â€¢ Struct, Enum, Array, Slice patterns");
    println!("   â€¢ Map patterns with rest syntax");
    println!("   â€¢ Wildcard and variable binding patterns");
    
    println!("ðŸ“‹ Rich Expression System:");
    println!("   â€¢ All literal types with proper typing");
    println!("   â€¢ Binary and unary operations");
    println!("   â€¢ Method calls and field access");
    println!("   â€¢ Struct literals and lambdas");
    
    println!("ðŸ“‹ Complete Statement Coverage:");
    println!("   â€¢ Let bindings with mutability");
    println!("   â€¢ Control flow (if, while, for, match)");
    println!("   â€¢ Expression statements");
    
    println!("ðŸ“‹ Coroutine & Async Support:");
    println!("   â€¢ Async, Generator, Goroutine patterns");
    println!("   â€¢ Defer statements for cleanup");
    println!("   â€¢ Select statements for channels");
    
    println!("ðŸ“‹ Type-Safe Construction:");
    println!("   â€¢ All nodes carry type and span information");
    println!("   â€¢ String interning for efficiency");
    println!("   â€¢ Comprehensive test coverage");
    
    println!("\nâœ¨ Ready for comprehensive language support!");
}