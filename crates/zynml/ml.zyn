// ============================================================================
// ZynML Grammar - Machine Learning DSL for Zyntax
// ============================================================================
//
// ZynML is a domain-specific language for machine learning pipelines.
// It provides Python-like ergonomics with systems-level performance.
//
// Features:
//   - Tensor operations with shape inference
//   - Pipe operator (|>) for data flow
//   - ML-specific builtins (audio, text, vectors, models)
//   - Clean, readable syntax
//
// Usage:
//   zynml run script.ml
//   zynml repl
//
// ============================================================================

@language {
    name: "ZynML",
    version: "1.0",
    file_extensions: [".ml", ".zynml"],
    entry_point: "main"
}

// ============================================================================
// ZRTL Plugin Symbol Mappings
// ============================================================================

@builtin {
    // === Tensor Operations (zrtl_tensor) ===
    tensor: "tensor_from_array",          // tensor([1.0, 2.0]) -> tensor_from_array([1.0, 2.0])
    tensor_from_array: "$Tensor$from_array_f32",
    tensor_zeros: "$Tensor$zeros",
    tensor_ones: "$Tensor$ones",
    tensor_full: "$Tensor$full_f32",
    arange: "$Tensor$arange_f32",             // arange(1.0, 10.0, 1.0) shorthand
    tensor_arange: "$Tensor$arange_f32",
    tensor_linspace: "$Tensor$linspace_f32",
    tensor_rand: "$Tensor$rand_f32",
    tensor_randn: "$Tensor$randn_f32",
    tensor_reshape: "$Tensor$reshape",
    tensor_transpose: "$Tensor$transpose",
    tensor_sum: "$Tensor$sum_f32",
    tensor_mean: "$Tensor$mean_f32",
    tensor_max: "$Tensor$max_f32",
    tensor_min: "$Tensor$min_f32",
    tensor_free: "$Tensor$free",
    tensor_print: "$Tensor$print",
    tensor_println: "$Tensor$println",
    tensor_to_string: "$Tensor$to_string",

    // === Audio Operations (zrtl_audio) ===
    audio_load: "$Audio$load",
    audio_free: "$Audio$free",
    audio_resample: "$Audio$resample",
    audio_to_mono: "$Audio$to_mono",
    audio_normalize: "$Audio$normalize",
    audio_trim_silence: "$Audio$trim_silence",
    audio_stft: "$Audio$stft",
    audio_mel_spectrogram: "$Audio$mel_spectrogram",
    audio_sample_rate: "$Audio$sample_rate",
    audio_duration: "$Audio$duration_seconds",

    // === Text Operations (zrtl_text) ===
    bpe_create: "$Text$bpe_create",
    bpe_encode: "$Text$bpe_encode",
    bpe_decode: "$Text$bpe_decode",
    text_lowercase: "$Text$lowercase",
    text_normalize: "$Text$normalize_whitespace",
    text_chunk: "$Text$chunk_by_sentences",

    // === Vector Operations (zrtl_vector) ===
    vec_cosine: "$Vector$cosine_similarity",
    vec_dot: "$Vector$dot_product",
    vec_euclidean: "$Vector$euclidean_distance",
    vec_normalize: "$Vector$l2_normalize",
    vec_topk: "$Vector$topk_cosine",
    flat_create: "$Vector$flat_create",
    flat_add: "$Vector$flat_add",
    flat_search: "$Vector$flat_search_cosine",
    hnsw_create: "$Vector$hnsw_create",
    hnsw_add: "$Vector$hnsw_add",
    hnsw_search: "$Vector$hnsw_search",

    // === Model Operations (zrtl_model) ===
    model_load: "$Model$load",
    model_free: "$Model$free",
    model_get_tensor: "$Model$get_tensor_f32",
    model_num_tensors: "$Model$num_tensors",

    // === SIMD Operations (zrtl_simd) ===
    simd_relu: "$SIMD$relu_f32",
    simd_sigmoid: "$SIMD$sigmoid_f32",
    simd_softmax: "$SIMD$softmax_f32",
    simd_tanh: "$SIMD$tanh_f32",
    simd_gemm: "$SIMD$gemm_f32",
    simd_layer_norm: "$SIMD$layer_norm_f32",

    // === I/O Operations (zrtl_io) ===
    // Universal print - uses DynamicBox for auto-formatting any type
    // This is the default for ZynML - prints tensors, floats, ints, strings, etc.
    print: "$IO$print_dynamic",
    println: "$IO$println_dynamic",
    eprint: "$IO$eprint_dynamic",
    eprintln: "$IO$eprintln_dynamic",

    // String-only output (for when you know it's a string)
    print_str: "$IO$print",
    println_str: "$IO$println",
    eprint_str: "$IO$eprint",
    eprintln_str: "$IO$eprintln",

    // Integer output
    print_i64: "$IO$print_i64",
    println_i64: "$IO$println_i64",
    print_u64: "$IO$print_u64",
    println_u64: "$IO$println_u64",

    // Float output
    print_f64: "$IO$print_f64",
    println_f64: "$IO$println_f64",

    // Boolean output
    print_bool: "$IO$print_bool",
    println_bool: "$IO$println_bool",

    // Character output
    print_char: "$IO$print_char",
    println_char: "$IO$println_char",

    // Input
    read_line: "$IO$read_line",
    input: "$IO$input",

    // Formatting
    format_i64: "$IO$format_i64",
    format_f64: "$IO$format_f64",
    format_bool: "$IO$format_bool",

    // Flushing
    flush: "$IO$flush",
    flush_stderr: "$IO$flush_stderr",

    // Dynamic (any type) output - handles all ZRTL types
    print_dynamic: "$IO$print_dynamic",
    println_dynamic: "$IO$println_dynamic",
    format_dynamic: "$IO$format_dynamic",

    // Array output (type-specific)
    print_array_f32: "$IO$print_array_f32",
    println_array_f32: "$IO$println_array_f32",
    print_array_i32: "$IO$print_array_i32",
    println_array_i32: "$IO$println_array_i32",
    print_array_i64: "$IO$print_array_i64",
    println_array_i64: "$IO$println_array_i64",
    print_array_f64: "$IO$print_array_f64",
    println_array_f64: "$IO$println_array_f64",

    // String operations
    string_concat: "$IO$string_concat",
    string_free: "$IO$string_free",

    // === File Operations (zrtl_fs) ===
    file_read: "$FS$read_string",
    file_write: "$FS$write_string",
    file_exists: "$FS$exists",

    // === Method Mappings ===
    // Syntax: x.method(args) -> builtin(x, args)
    @sum: "tensor_sum",           // x.sum() -> tensor_sum(x)
    @mean: "tensor_mean",         // x.mean() -> tensor_mean(x)
    @max: "tensor_max",           // x.max() -> tensor_max(x)
    @min: "tensor_min",           // x.min() -> tensor_min(x)
    @reshape: "tensor_reshape",   // x.reshape(shape) -> tensor_reshape(x, shape)
    @transpose: "tensor_transpose", // x.transpose() -> tensor_transpose(x)
    @normalize: "vec_normalize",  // x.normalize() -> vec_normalize(x)
    @dot: "vec_dot",              // x.dot(y) -> vec_dot(x, y)
    @cosine: "vec_cosine",        // x.cosine(y) -> vec_cosine(x, y)

    // === Operator Overloads ===
    // Syntax: x op y -> builtin(x, y)
    // Note: These apply globally - for type-aware overloading, use method syntax
    $@: "vec_dot"                 // x @ y -> vec_dot(x, y) (matrix multiply, like Python)
}

// ============================================================================
// Type Declarations for Opaque Types and Return Type Tracking
// ============================================================================
// Declares opaque types (ZRTL-backed pointer types) and function return types
// so the compiler can properly track types for operator trait dispatch.

@types {
    // Opaque types - these are pointer types backed by ZRTL plugins
    opaque: [$Tensor, $Audio, $Model, $Vector, $Text, $BPETokenizer, $FlatIndex, $HNSWIndex],

    // Function return types - tells the compiler what type each function returns
    returns: {
        // Tensor operations return $Tensor
        tensor: $Tensor,
        tensor_from_array: $Tensor,
        tensor_zeros: $Tensor,
        tensor_ones: $Tensor,
        tensor_full: $Tensor,
        arange: $Tensor,                // Shorthand for tensor_arange
        tensor_arange: $Tensor,
        tensor_linspace: $Tensor,
        tensor_rand: $Tensor,
        tensor_randn: $Tensor,
        tensor_reshape: $Tensor,
        tensor_transpose: $Tensor,

        // Audio operations return $Audio
        audio_load: $Audio,
        audio_resample: $Audio,
        audio_to_mono: $Audio,
        audio_normalize: $Audio,
        audio_trim_silence: $Audio,
        audio_stft: $Tensor,
        audio_mel_spectrogram: $Tensor,

        // Text operations
        bpe_create: $BPETokenizer,
        bpe_encode: $Tensor,

        // Vector operations
        flat_create: $FlatIndex,
        hnsw_create: $HNSWIndex,

        // Model operations
        model_load: $Model,
        model_get_tensor: $Tensor
    }
}

// ============================================================================
// Program Structure
// ============================================================================

program = { SOI ~ items:top_level_items ~ EOI }
  -> items

top_level_items = { decl:top_level_item* }
  -> TypedProgram {
      declarations: decl,
  }

top_level_item = {
    module_decl |
    config_block |
    pipeline_def |
    decorated_item |
    trait_def |
    impl_block |
    abstract_def |
    enum_def |
    struct_def |
    type_def |
    fn_def |
    let_stmt |
    import_stmt |
    render_stmt |
    stream_stmt |
    expr_stmt
}

// ============================================================================
// Import Statement
// ============================================================================

// import tensor
// import prelude
// import zynml.tensor as T
import_stmt = { import_aliased | import_simple }

// import zynml.tensor as T
import_aliased = { "import" ~ path:module_path ~ "as" ~ alias:identifier }
  -> TypedDeclaration::Import {
      path: [intern(path)],
  }

// import tensor
import_simple = { "import" ~ name:identifier }
  -> TypedDeclaration::Import {
      path: [intern(name)],
  }

// Module path: zynml.tensor.ops
module_path = @{ identifier ~ ("." ~ identifier)* }

// ============================================================================
// Module Declaration
// ============================================================================

// module recommendation_pipeline
module_decl = { "module" ~ name:identifier }
  -> TypedDeclaration::Module {
      name: intern(name),
  }

// ============================================================================
// Config Block
// ============================================================================

// config { device: "cpu", precision: "float32", batch_size: 32 }
config_block = { "config" ~ "{" ~ config_entries ~ "}" }
  -> TypedDeclaration {
      "commands": [
          { "define": "config", "args": {
              "entries": "$1"
          }}
      ]
  }

config_entries = { config_entry ~ ("," ~ config_entry)* ~ ","? }
  -> List {
      "get_all_children": true
  }

config_entry = { identifier ~ ":" ~ expr }
  -> TypedExpression {
      "commands": [
          { "define": "config_entry", "args": {
              "key": "$1",
              "value": "$2"
          }}
      ]
  }

// ============================================================================
// Pipeline Definition
// ============================================================================

// pipeline image_search(query: text, top_k: int) -> list { ... }
pipeline_def = { "pipeline" ~ identifier ~ "(" ~ fn_params? ~ ")" ~ ("->" ~ type_expr)? ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "pipeline", "args": {
              "name": "$1",
              "params": "$2",
              "return_type": "$3",
              "body": "$4"
          }}
      ]
  }

// ============================================================================
// Decorated Items (@cache, @memoize, @kernel, @workgroup, @device)
// ============================================================================

// @cache(ttl=1h) fn expensive() { ... }
// @memoize fn compute() { ... }
// @kernel elementwise
decorated_item = { decorator+ ~ (fn_def | pipeline_def) }
  -> TypedDeclaration {
      "commands": [
          { "define": "decorated", "args": {
              "decorators": "$1",
              "item": "$2"
          }}
      ]
  }

// Decorator: @name or @name(args)
decorator = { "@" ~ identifier ~ decorator_args? }
  -> TypedExpression {
      "commands": [
          { "define": "decorator", "args": {
              "name": "$1",
              "args": "$2"
          }}
      ]
  }

decorator_args = { "(" ~ decorator_arg_list ~ ")" }
  -> List {
      "get_child": { "index": 0 }
  }

decorator_arg_list = { decorator_arg ~ ("," ~ decorator_arg)* }
  -> List {
      "get_all_children": true
  }

// ttl=1h or just identifier for kernel types
decorator_arg = { identifier ~ "=" ~ expr | identifier | expr }
  -> TypedExpression {
      "get_all_children": true,
      "define": "decorator_arg"
  }

// ============================================================================
// Render Statement (Visualization for ZynBook)
// ============================================================================

// render photo
// render chart(data) { type: "line", title: "My Chart" }
render_stmt = { render_with_options | render_simple }
  -> TypedDeclaration {
      "get_child": { "index": 0 }
  }

// render photo { title: "Original Image", width: 400 }
render_with_options = { "render" ~ expr ~ "{" ~ config_entries ~ "}" }
  -> TypedDeclaration {
      "commands": [
          { "define": "render", "args": {
              "expr": "$1",
              "options": "$2"
          }}
      ]
  }

// render photo
render_simple = { "render" ~ expr }
  -> TypedDeclaration {
      "commands": [
          { "define": "render", "args": {
              "expr": "$1"
          }}
      ]
  }

// ============================================================================
// Stream Statement
// ============================================================================

// stream sensor_data |> window(100) |> sink(alert_system)
stream_stmt = { "stream" ~ identifier ~ ("|>" ~ pipe_call)+ }
  -> TypedDeclaration {
      "commands": [
          { "define": "stream", "args": {
              "source": "$1",
              "pipeline": "$2"
          }}
      ]
  }

// ============================================================================
// Trait Definition
// ============================================================================

// trait Display { fn to_string(self) -> String }
// trait Iterator<T> { fn next(self) -> Option<T> }
// trait Add<Rhs> { type Output; fn add(self, rhs: Rhs) -> Output }
// Note: For now we simplify and just capture the name - methods/types will be parsed later
trait_def = { "trait" ~ name:identifier ~ type_params? ~ "{" ~ trait_item* ~ "}" }
  -> TypedDeclaration::Interface {
      name: intern(name),
  }

// Trait item can be an associated type or a method
// For now, these are parsed but produce empty results (the grammar captures the syntax)
trait_item = { item:associated_type | item:trait_method }
  -> item

// Associated type: type Output
// With bounds: type Item: Clone
associated_type = { "type" ~ name:identifier ~ (":" ~ type_bounds)? }
  -> TypedDeclaration::TypeAlias {
      name: intern(name),
  }

trait_method = { "fn" ~ name:identifier ~ type_params? ~ "(" ~ trait_params? ~ ")" ~ ("->" ~ type_expr)? }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: [],
      return_type: Type::Unit,
      body: None,
  }

trait_params = { param:trait_param ~ ("," ~ param:trait_param)* }
  -> param

trait_param = { name:identifier ~ (":" ~ ty:type_expr)? }
  -> TypedParameter {
      name: intern(name),
      type_annotation: ty,
  }

// Type parameters: <T, U>
// With bounds: <T: Display, U: Clone + Debug>
// For now, we just consume type params and produce text values
type_params = { "<" ~ param:type_param ~ ("," ~ param:type_param)* ~ ">" }
  -> param

type_param = { name:identifier ~ (":" ~ type_bounds)? }
  -> intern(name)

type_bounds = { ty:type_expr ~ ("+" ~ ty:type_expr)* }
  -> ty

// ============================================================================
// Type Definition
// ============================================================================

// @opaque("$Tensor") type Tensor
// type Point = { x: f32, y: f32 }
type_def = { decl:type_opaque | decl:type_alias | decl:type_struct }
  -> decl

// Opaque type wrapping external (ZRTL) type
// Match @opaque as two separate tokens to avoid conflict with @ operator
// For now, we emit a TypeAlias - the actual opaque behavior is handled elsewhere
type_opaque = { "@" ~ "opaque" ~ "(" ~ string_literal ~ ")" ~ "type" ~ name:identifier }
  -> TypedDeclaration::TypeAlias {
      name: intern(name),
  }

// Type alias: type Scalar = f32
type_alias = { "type" ~ name:identifier ~ "=" ~ type_expr }
  -> TypedDeclaration::TypeAlias {
      name: intern(name),
  }

// Struct type: type Point = { x: f32, y: f32 }
type_struct = { "type" ~ name:identifier ~ "=" ~ "{" ~ fields:struct_fields ~ "}" }
  -> TypedDeclaration::Class {
      name: intern(name),
      fields: fields,
  }

struct_fields = { field:struct_field ~ ("," ~ field:struct_field)* ~ ","? }
  -> field

struct_field = { name:identifier ~ ":" ~ ty:type_expr }
  -> TypedField {
      name: intern(name),
      ty: ty,
  }

// ============================================================================
// Abstract Type Definition (Haxe-style)
// ============================================================================

// abstract Duration(i64) with Suffix("ms") { ms: i64 }
// abstract Duration(i64) with Suffixes("ms, s, ns, m, h") { ms: i64 }
// abstract Duration(i64) { value: i64 }
// abstract Duration(i64) with Suffix("ms"): ms: i64  (colon style also supported)
// Abstract types are zero-cost wrappers with implicit conversions
// Can have fields like structs, with underlying type for direct conversions
// Suffix/Suffixes enables literal syntax like 1000ms, 5s, 3ns
// For now, abstracts are represented as TypeAlias - the actual abstract behavior is handled elsewhere
abstract_def = {
    decl:abstract_with_suffix_brace | decl:abstract_with_suffixes_brace |
    decl:abstract_with_suffixes | decl:abstract_with_suffix |
    decl:abstract_with_fields_brace | decl:abstract_with_fields |
    decl:abstract_simple
}
  -> decl

// ========== Brace-style abstract definitions ==========

// abstract Name(Type) with Suffix("x") { fields }
abstract_with_suffix_brace = { "abstract" ~ name:identifier ~ "(" ~ type_expr ~ ")" ~ "with" ~ "Suffix" ~ "(" ~ string_literal ~ ")" ~ "{" ~ struct_field_list ~ "}" }
  -> TypedDeclaration::TypeAlias {
      name: intern(name),
  }

// abstract Name(Type) with Suffixes("x, y, z") { fields }
abstract_with_suffixes_brace = { "abstract" ~ name:identifier ~ "(" ~ type_expr ~ ")" ~ "with" ~ "Suffixes" ~ "(" ~ string_literal ~ ")" ~ "{" ~ struct_field_list ~ "}" }
  -> TypedDeclaration::TypeAlias {
      name: intern(name),
  }

// abstract Name(Type) { fields } (without suffix)
abstract_with_fields_brace = { "abstract" ~ name:identifier ~ "(" ~ type_expr ~ ")" ~ "{" ~ struct_field_list ~ "}" }
  -> TypedDeclaration::TypeAlias {
      name: intern(name),
  }

// ========== Colon-style abstract definitions (legacy/alternative) ==========

// abstract Name(Type) with Suffix("x"):  or  with Suffixes("x, y, z"):
abstract_with_suffix = { "abstract" ~ name:identifier ~ "(" ~ type_expr ~ ")" ~ "with" ~ "Suffix" ~ "(" ~ string_literal ~ ")" ~ ":" ~ struct_def_fields }
  -> TypedDeclaration::TypeAlias {
      name: intern(name),
  }

abstract_with_suffixes = { "abstract" ~ name:identifier ~ "(" ~ type_expr ~ ")" ~ "with" ~ "Suffixes" ~ "(" ~ string_literal ~ ")" ~ ":" ~ struct_def_fields }
  -> TypedDeclaration::TypeAlias {
      name: intern(name),
  }

// abstract Name(Type): fields (without suffix)
abstract_with_fields = { "abstract" ~ name:identifier ~ "(" ~ type_expr ~ ")" ~ ":" ~ struct_def_fields }
  -> TypedDeclaration::TypeAlias {
      name: intern(name),
  }

// abstract Name(Type)
abstract_simple = { "abstract" ~ name:identifier ~ "(" ~ type_expr ~ ")" }
  -> TypedDeclaration::TypeAlias {
      name: intern(name),
  }

// Field list for brace-style definitions: field: type, field: type
struct_field_list = { field:struct_field ~ ("," ~ field:struct_field)* }
  -> field

struct_field = { name:identifier ~ ":" ~ ty:type_expr }
  -> TypedField {
      name: intern(name),
      ty: ty,
  }

// ============================================================================
// Struct Definition (Both Brace and Colon Syntax)
// ============================================================================

// Brace style: struct Point { x: float, y: float }
// Colon style: struct Point:
//                  x: float
//                  y: float
// Split into generic and non-generic variants (optional not supported in grammar)
struct_def = {
    struct_def_generic_brace | struct_def_brace |
    struct_def_generic | struct_def_simple
}

// ========== Brace-style struct definitions ==========

// struct List<T> { items: Vec, count: int }
struct_def_generic_brace = { "struct" ~ name:identifier ~ type_params ~ "{" ~ fields:struct_field_list ~ "}" }
  -> TypedDeclaration::Class {
      name: intern(name),
      fields: fields,
  }

// struct Point { x: float, y: float }
struct_def_brace = { "struct" ~ name:identifier ~ "{" ~ fields:struct_field_list ~ "}" }
  -> TypedDeclaration::Class {
      name: intern(name),
      fields: fields,
  }

// ========== Colon-style struct definitions ==========

// struct List<T>:
//     ...
struct_def_generic = { "struct" ~ name:identifier ~ type_params ~ ":" ~ fields:struct_def_fields }
  -> TypedDeclaration::Class {
      name: intern(name),
      fields: fields,
  }

// struct Point:
//     ...
struct_def_simple = { "struct" ~ name:identifier ~ ":" ~ fields:struct_def_fields }
  -> TypedDeclaration::Class {
      name: intern(name),
      fields: fields,
  }

struct_def_fields = { field:struct_def_field+ }
  -> field

struct_def_field = { name:identifier ~ ":" ~ ty:type_expr }
  -> TypedField {
      name: intern(name),
      ty: ty,
  }

// ============================================================================
// Enum Definition
// ============================================================================

// enum Option<T> {
//     Some(T),
//     None
// }
// Split into generic and non-generic variants
enum_def = { decl:enum_def_generic | decl:enum_def_simple }
  -> decl

// enum Option<T> { ... }
enum_def_generic = { "enum" ~ name:identifier ~ type_params ~ "{" ~ variants:enum_variants ~ "}" }
  -> TypedDeclaration::Enum {
      name: intern(name),
      variants: variants,
  }

// enum Color { Red, Green, Blue }
enum_def_simple = { "enum" ~ name:identifier ~ "{" ~ variants:enum_variants ~ "}" }
  -> TypedDeclaration::Enum {
      name: intern(name),
      variants: variants,
  }

// Enum variants list
enum_variants = { variant:enum_variant ~ ("," ~ variant:enum_variant)* ~ ","? }
  -> variant

// Enum variant: Name or Name(T1, T2, ...)
// Split into tuple variant and unit variant
enum_variant = { v:enum_variant_tuple | v:enum_variant_unit }
  -> v

// Some(T) - tuple variant with associated types
enum_variant_tuple = { name:identifier ~ "(" ~ type_expr ~ ("," ~ type_expr)* ~ ")" }
  -> TypedVariant {
      name: intern(name),
      fields: TypedVariantFields::Unit,
  }

// None - unit variant (no associated data)
enum_variant_unit = { name:identifier }
  -> TypedVariant {
      name: intern(name),
      fields: TypedVariantFields::Unit,
  }

// ============================================================================
// Impl Block (Trait Implementation + Inherent Methods)
// ============================================================================

// impl Display for Tensor: fn to_string(self) -> String { ... }
// impl Add<Tensor> for Tensor: type Output = Tensor; fn add(...) { ... }
// impl Duration(i64): fn from_ms(value: i64) -> Self { ... }
// Split into multiple rules to avoid optional capture index shifting
// Order matters: try more specific rules first
impl_block = { decl:impl_abstract_inherent | decl:impl_block_with_args | decl:impl_block_trait | decl:impl_block_inherent }
  -> decl

// Inherent impl for abstract types: impl<T> TypeName(UnderlyingType) { methods }
// Split into generic and non-generic variants
impl_abstract_inherent = { decl:impl_abstract_inherent_generic | decl:impl_abstract_inherent_simple }
  -> decl

// impl<T> Container<T>(i64) { ... }
// For now, emit as Impl since we need a for_type
impl_abstract_inherent_generic = { "impl" ~ type_params ~ name:identifier ~ "(" ~ type_expr ~ ")" ~ "{" ~ items:impl_items ~ "}" }
  -> TypedDeclaration::Impl {
      trait_name: intern(name),
      for_type: intern(name),
      items: items,
  }

// impl Duration(i64) { ... }
impl_abstract_inherent_simple = { "impl" ~ name:identifier ~ "(" ~ type_expr ~ ")" ~ "{" ~ items:impl_items ~ "}" }
  -> TypedDeclaration::Impl {
      trait_name: intern(name),
      for_type: intern(name),
      items: items,
  }

// impl<T> Trait<Args> for Type<T> { ... }
// Split into generic and non-generic variants
impl_block_with_args = { decl:impl_block_with_args_generic | decl:impl_block_with_args_simple }
  -> decl

// impl<T> Add<T> for Container<T> { ... }
impl_block_with_args_generic = { "impl" ~ type_params ~ trait_name:identifier ~ type_args_angle ~ "for" ~ for_type:type_expr_name ~ "{" ~ items:impl_items ~ "}" }
  -> TypedDeclaration::Impl {
      trait_name: intern(trait_name),
      for_type: intern(for_type),
      items: items,
  }

// impl Add<Tensor> for Tensor { ... }
impl_block_with_args_simple = { "impl" ~ trait_name:identifier ~ type_args_angle ~ "for" ~ for_type:type_expr_name ~ "{" ~ items:impl_items ~ "}" }
  -> TypedDeclaration::Impl {
      trait_name: intern(trait_name),
      for_type: intern(for_type),
      items: items,
  }

// impl<T> Trait for Type<T> { ... } - trait implementation
// Split into generic and non-generic variants
impl_block_trait = { decl:impl_block_trait_generic | decl:impl_block_trait_simple }
  -> decl

// impl<T> Iterator for ListIterator<T> { ... }
impl_block_trait_generic = { "impl" ~ type_params ~ trait_name:identifier ~ "for" ~ for_type:type_expr_name ~ "{" ~ items:impl_items ~ "}" }
  -> TypedDeclaration::Impl {
      trait_name: intern(trait_name),
      for_type: intern(for_type),
      items: items,
  }

// impl Display for Point { ... }
impl_block_trait_simple = { "impl" ~ trait_name:identifier ~ "for" ~ for_type:type_expr_name ~ "{" ~ items:impl_items ~ "}" }
  -> TypedDeclaration::Impl {
      trait_name: intern(trait_name),
      for_type: intern(for_type),
      items: items,
  }

// impl<T> Type<T> { ... } - inherent implementation (no trait)
// Split into generic and non-generic variants (optional not supported)
impl_block_inherent = { decl:impl_block_inherent_generic | decl:impl_block_inherent_simple }
  -> decl

// impl<T> List<T> { ... }
impl_block_inherent_generic = { "impl" ~ type_params ~ for_type:impl_type_name_generic ~ "{" ~ items:impl_items ~ "}" }
  -> TypedDeclaration::Impl {
      trait_name: intern(for_type),
      for_type: intern(for_type),
      items: items,
  }

// impl List { ... }
impl_block_inherent_simple = { "impl" ~ for_type:identifier ~ "{" ~ items:impl_items ~ "}" }
  -> TypedDeclaration::Impl {
      trait_name: intern(for_type),
      for_type: intern(for_type),
      items: items,
  }

// Type name for generic impl blocks - captures the base identifier
impl_type_name_generic = { name:identifier ~ "<" ~ type_args ~ ">" }
  -> name

// Helper to get just the name from a type expression for impl blocks
type_expr_name = { generic_type_name | simple_type_name }

generic_type_name = { name:identifier ~ "<" ~ type_args ~ ">" }
  -> name

simple_type_name = { name:identifier }
  -> name

impl_items = { item:impl_item* }
  -> item

// Impl items: associated types and methods (expression-bodied, indent-bodied, and brace-bodied)
// NOTE: indent-bodied must come after expression-bodied to prefer single-expression form when applicable
impl_item = {
    decl:impl_assoc_type |
    decl:impl_method_return_expr | decl:impl_method_return_indent | decl:impl_method_return |
    decl:impl_method_params_expr | decl:impl_method_params_indent | decl:impl_method_params |
    decl:impl_method_simple_indent | decl:impl_method_simple
}
  -> decl

// type Output = Tensor
impl_assoc_type = { "type" ~ name:identifier ~ "=" ~ target:type_expr }
  -> TypedDeclaration::TypeAlias {
      name: intern(name),
      target: target,
  }

// Impl methods can't have their own type params (they use the impl block's)
// So we define specific impl method rules without type params

// ========== Expression-bodied methods (single expression after colon) ==========

// fn add(self, rhs: T) -> ReturnType: expression
impl_method_return_expr = { "fn" ~ name:identifier ~ "(" ~ params:fn_params? ~ ")" ~ "->" ~ ret:type_expr ~ ":" ~ body:expr_block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: params,
      return_type: ret,
      body: Some(body),
  }

// fn process(self, other: T): expression
impl_method_params_expr = { "fn" ~ name:identifier ~ "(" ~ params:fn_params ~ ")" ~ ":" ~ body:expr_block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: params,
      return_type: Type::Unit,
      body: Some(body),
  }

// ========== Indent-bodied methods (Python-style colon with statement block) ==========

// fn add(self, rhs: T) -> ReturnType:
//     statements...
impl_method_return_indent = { "fn" ~ name:identifier ~ "(" ~ params:fn_params? ~ ")" ~ "->" ~ ret:type_expr ~ ":" ~ body:indent_block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: params,
      return_type: ret,
      body: Some(body),
  }

// fn process(self, other: T):
//     statements...
impl_method_params_indent = { "fn" ~ name:identifier ~ "(" ~ params:fn_params ~ ")" ~ ":" ~ body:indent_block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: params,
      return_type: Type::Unit,
      body: Some(body),
  }

// fn simple():
//     statements...
impl_method_simple_indent = { "fn" ~ name:identifier ~ "(" ~ ")" ~ ":" ~ body:indent_block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: [],
      return_type: Type::Unit,
      body: Some(body),
  }

// ========== Block-bodied methods (with braces) ==========

// fn add(self, rhs: T) -> ReturnType { ... }
// NOTE: Impl methods are initially typed as functions but marked with is_self on parameters
// The compiler will re-type the body expressions with correct self type during lowering
impl_method_return = { "fn" ~ name:identifier ~ "(" ~ params:fn_params? ~ ")" ~ "->" ~ ret:type_expr ~ body:block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: params,
      return_type: ret,
      body: Some(body),
  }

// fn process(self, other: T) { ... }
impl_method_params = { "fn" ~ name:identifier ~ "(" ~ params:fn_params ~ ")" ~ body:block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: params,
      return_type: Type::Unit,
      body: Some(body),
  }

// fn simple() { ... }
impl_method_simple = { "fn" ~ name:identifier ~ "(" ~ ")" ~ body:block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: [],
      return_type: Type::Unit,
      body: Some(body),
  }

// Type arguments in angle brackets (for trait impl)
type_args_angle = { "<" ~ args:type_args ~ ">" }
  -> args

// ============================================================================
// Type Expressions
// ============================================================================

type_expr = { ty:generic_type | ty:array_type | ty:simple_type }
  -> ty

simple_type = { name:identifier }
  -> Type::Named {
      name: intern(name),
  }

array_type = { "Array" ~ "<" ~ elem:type_expr ~ ">" }
  -> Type::Named {
      name: intern("Array"),
  }

generic_type = { name:identifier ~ "<" ~ type_args ~ ">" }
  -> Type::Named {
      name: intern(name),
  }

type_args = { ty:type_expr ~ ("," ~ ty:type_expr)* }
  -> ty

// ============================================================================
// Function Definition
// ============================================================================

// Function definitions - split by presence of type params, params, return type, and block style
// Supports both brace-style { } and Python-style colon : blocks
fn_def = {
    fn_def_generic_return_colon | fn_def_generic_return |
    fn_def_generic_colon | fn_def_generic |
    fn_def_return_colon | fn_def_return |
    fn_def_params_colon | fn_def_params |
    fn_def_simple_colon | fn_def_simple
}

// ========== Brace-style function definitions ==========

// fn map<T, U>(items) -> ReturnType { ... }
fn_def_generic_return = { "fn" ~ name:identifier ~ type_params ~ "(" ~ params:fn_params? ~ ")" ~ "->" ~ ret:type_expr ~ body:block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: params,
      return_type: ret,
      body: Some(body),
  }

// fn process<T>(x) { ... }
fn_def_generic = { "fn" ~ name:identifier ~ type_params ~ "(" ~ params:fn_params? ~ ")" ~ body:block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: params,
      return_type: Type::Unit,
      body: Some(body),
  }

// fn process(x, y) -> ReturnType { ... }
fn_def_return = { "fn" ~ name:identifier ~ "(" ~ params:fn_params? ~ ")" ~ "->" ~ ret:type_expr ~ body:block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: params,
      return_type: ret,
      body: Some(body),
  }

// fn process(x, y) { ... } - with params, no return type
fn_def_params = { "fn" ~ name:identifier ~ "(" ~ params:fn_params ~ ")" ~ body:block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: params,
      return_type: Type::Unit,
      body: Some(body),
  }

// fn main() { ... } - no params, no return type
fn_def_simple = { "fn" ~ name:identifier ~ "(" ~ ")" ~ body:block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: [],
      return_type: Type::Unit,
      body: Some(body),
  }

// ========== Python-style colon function definitions ==========

// fn map<T, U>(items) -> ReturnType:
//     statements...
fn_def_generic_return_colon = { "fn" ~ name:identifier ~ type_params ~ "(" ~ params:fn_params? ~ ")" ~ "->" ~ ret:type_expr ~ ":" ~ body:indent_block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: params,
      return_type: ret,
      body: Some(body),
  }

// fn process<T>(x):
//     statements...
fn_def_generic_colon = { "fn" ~ name:identifier ~ type_params ~ "(" ~ params:fn_params? ~ ")" ~ ":" ~ body:indent_block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: params,
      return_type: Type::Unit,
      body: Some(body),
  }

// fn process(x, y) -> ReturnType:
//     statements...
fn_def_return_colon = { "fn" ~ name:identifier ~ "(" ~ params:fn_params? ~ ")" ~ "->" ~ ret:type_expr ~ ":" ~ body:indent_block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: params,
      return_type: ret,
      body: Some(body),
  }

// fn process(x, y):
//     statements...
fn_def_params_colon = { "fn" ~ name:identifier ~ "(" ~ params:fn_params ~ ")" ~ ":" ~ body:indent_block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: params,
      return_type: Type::Unit,
      body: Some(body),
  }

// fn main():
//     statements...
fn_def_simple_colon = { "fn" ~ name:identifier ~ "(" ~ ")" ~ ":" ~ body:indent_block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: [],
      return_type: Type::Unit,
      body: Some(body),
  }

fn_params = { param:fn_param ~ ("," ~ param:fn_param)* }
  -> param

// Parameter with optional type annotation
// Supports: x, x: Int, self, self: Tensor
fn_param = { name:identifier ~ (":" ~ ty:type_expr)? }
  -> TypedParameter {
      name: intern(name),
      type_annotation: ty,
  }

// ============================================================================
// Statements
// ============================================================================

statement = {
    let_stmt |
    assign_stmt |
    if_stmt |
    while_stmt |
    for_stmt |
    try_stmt |
    match_stmt |
    return_stmt |
    break_stmt |
    continue_stmt |
    expr_stmt
}

// let x = expr
// let mel = audio |> resample(16000) |> to_mono()
let_stmt = { "let" ~ name:identifier ~ "=" ~ init:expr }
  -> TypedStatement::Let {
      name: intern(name),
      type_annotation: None,
      initializer: Some(init),
      is_mutable: true,
  }

// x = expr
assign_stmt = { field_assign_stmt | simple_assign_stmt }

// self.field = expr
field_assign_stmt = { obj:identifier ~ "." ~ field:identifier ~ "=" ~ value:expr }
  -> TypedStatement::Assignment {
      target: TypedExpression::FieldAccess {
          object: Box::new(TypedExpression::Variable { name: intern(obj) }),
          field: intern(field),
      },
      value: value,
  }

// x = expr
simple_assign_stmt = { target:identifier ~ "=" ~ value:expr }
  -> TypedStatement::Assignment {
      target: TypedExpression::Variable { name: intern(target) },
      value: value,
  }

// if condition { ... } else { ... }
if_stmt = { "if" ~ cond:expr ~ then_body:block ~ ("else" ~ else_body:block)? }
  -> TypedStatement::If {
      condition: cond,
      then_branch: then_body,
      else_branch: else_body,
  }

// while condition { ... }
while_stmt = { "while" ~ cond:expr ~ body:block }
  -> TypedStatement::While {
      condition: cond,
      body: body,
  }

// for i in range(10) { ... }
// for item in items { ... }
for_stmt = { "for" ~ var:identifier ~ "in" ~ iter:expr ~ body:block }
  -> TypedStatement::For {
      variable: intern(var),
      iterable: iter,
      body: body,
  }

// return expr
return_stmt = { "return" ~ value:expr? }
  -> TypedStatement::Return {
      value: value,
  }

// break
break_stmt = { "break" ~ value:expr? }
  -> TypedStatement::Break {
      value: value,
  }

// continue
continue_stmt = { "continue" }
  -> TypedStatement::Continue {}

// ============================================================================
// Try/Catch Statement
// ============================================================================

// try { ... } catch ErrorType as e { ... }
try_stmt = { "try" ~ body:block ~ catches:catch_clause+ }
  -> TypedStatement::Try {
      body: body,
      catches: catches,
  }

// catch ErrorType as e { ... }
// catch _ { ... }  (catch all)
catch_clause = { "catch" ~ error_type:identifier ~ ("as" ~ binding:identifier)? ~ body:block }
  -> TypedCatch {
      error_type: intern(error_type),
      binding: binding,
      body: body,
  }

// ============================================================================
// Match/Case Statement
// ============================================================================

// match expr { case pattern { ... } case _ { ... } }
match_stmt = { "match" ~ scrutinee:expr ~ "{" ~ arms:match_arm+ ~ "}" }
  -> TypedStatement::Match {
      scrutinee: scrutinee,
      arms: arms,
  }

// case "pattern" { ... }
// case _ { ... }
match_arm = { "case" ~ pat:pattern ~ body:block }
  -> TypedMatchArm {
      pattern: pat,
      body: body,
  }

// Pattern: literal, identifier (binding), or wildcard (_)
pattern = { string_literal | int_literal | bool_literal | wildcard | identifier }

// Wildcard pattern
wildcard = { "_" }
  -> TypedExpression::Wildcard {}

// expr as statement
expr_stmt = { e:expr }
  -> TypedStatement::Expression {
      expr: e,
  }

// { statements } - brace-style block
block = { "{" ~ stmts:statement* ~ "}" }
  -> TypedBlock {
      statements: stmts,
  }

// Python-style indented block with colon
// Used ONLY for top-level function definitions where greediness is acceptable
// Note: PEG grammars don't track indentation, so this consumes all remaining statements
// This works for `fn main(): ...` but NOT for control flow inside functions
indent_block = { statement+ }
  -> TypedBlock {
      "get_all_children": true,
      "define": "block",
      "args": { "statements": "$result" }
  }

// Expression block (for colon-based method syntax)
// Wraps a single expression as a block with one expression statement
// Used in impl methods: fn getter(self) -> T: self.field
expr_block = { expr }
  -> TypedBlock {
      "commands": [
          { "define": "expr_block", "args": {
              "expr": "$1"
          }}
      ]
  }

// ============================================================================
// Expressions
// ============================================================================

// Expression with pipe operator (lowest precedence)
expr = { e:pipe_expr }
  -> e

// Pipe operator: x |> f(args) |> g()
// Transforms: a |> f(b) into f(a, b)
// For now, simplified - just parse and pass first operand
pipe_expr = { first:ternary_expr ~ ("|>" ~ pipe_call)* }
  -> first

pipe_call = { callee:identifier ~ "(" ~ args:call_args? ~ ")" }
  -> TypedExpression::Call {
      callee: Box::new(TypedExpression::Variable { name: intern(callee) }),
      args: args,
  }

// Ternary conditional: condition ? true_expr : false_expr
ternary_expr = { ternary_with_branches | or_expr }

ternary_with_branches = { cond:or_expr ~ "?" ~ then_expr:or_expr ~ ":" ~ else_expr:or_expr }
  -> TypedExpression::Ternary {
      condition: Box::new(cond),
      then_branch: Box::new(then_expr),
      else_branch: Box::new(else_expr),
  }

// Logical OR - simplified (just pass through inner expression for now)
or_expr = { inner:and_expr ~ ("||" ~ and_expr)* }
  -> inner

// Logical AND - simplified (just pass through inner expression for now)
and_expr = { inner:comparison_expr ~ ("&&" ~ comparison_expr)* }
  -> inner

// Comparison - simplified (just pass through inner expression for now)
comparison_expr = { inner:range_expr ~ (comparison_op ~ range_expr)? }
  -> inner

comparison_op = @{ "==" | "!=" | "<=" | ">=" | "<" | ">" }

// Range: 0..10 (exclusive), 0..=10 (inclusive)
range_expr = { range_inclusive | range_exclusive | additive_expr }

range_exclusive = { start:additive_expr ~ ".." ~ end:additive_expr }
  -> TypedExpression::Range {
      start: Box::new(start),
      end: Box::new(end),
      inclusive: false,
  }

range_inclusive = { start:additive_expr ~ "..=" ~ end:additive_expr }
  -> TypedExpression::Range {
      start: Box::new(start),
      end: Box::new(end),
      inclusive: true,
  }

// Addition and subtraction - simplified (just pass through for now)
additive_expr = { inner:multiplicative_expr ~ (additive_op ~ multiplicative_expr)* }
  -> inner

additive_op = @{ "+" | "-" }

// Multiplication, division, modulo - simplified (just pass through for now)
multiplicative_expr = { inner:unary_expr ~ (multiplicative_op ~ unary_expr)* }
  -> inner

// Note: "@" in quotes is a literal character, not the pest atomic rule marker
multiplicative_op = @{ "@" | "*" | "/" | "%" }

// Unary operators - simplified (just pass through operand for now)
unary_expr = { unary_op? ~ operand:postfix_expr }
  -> operand

unary_op = @{ "-" | "!" }

// Postfix: function calls, indexing, member access
// Simplified - just pass through primary for now
postfix_expr = { base:primary_expr ~ postfix_op* }
  -> base

postfix_op = { call_op | index_op | member_op }

// Function call: f(args) - not used in simplified version
call_op = { "(" ~ args:call_args? ~ ")" }
  -> TypedExpression::CallArgs { args: args }

call_args = { first:expr ~ ("," ~ rest:expr)* }
  -> first

// Call args as a proper list - returns list of expressions
// Pattern matches: expr ("," expr)*
// rest binding on the repetition collects all values into a List
call_args_list = { first:expr ~ ("," ~ rest:expr)* }
  -> prepend_list(first, rest)

// Indexing: x[i] - not used in simplified version
index_op = { "[" ~ idx:expr ~ "]" }
  -> TypedExpression::IndexOp { index: idx }

// Member access: x.field - not used in simplified version
member_op = { "." ~ field:identifier }
  -> TypedExpression::MemberOp { field: intern(field) }

// Primary expressions
primary_expr = {
    load_as_expr |
    model_config_expr |
    compute_expr |
    extern_call |
    tensor_literal |
    struct_literal |
    array_literal |
    float_literal |
    suffixed_literal |
    duration_literal |
    int_literal |
    string_literal |
    bool_literal |
    grouped_expr |
    path_expr |
    var_expr
}

// ============================================================================
// Load with Type Cast
// ============================================================================

// load("image.jpg") as image
load_as_expr = { "load" ~ "(" ~ string_literal ~ ")" ~ "as" ~ identifier }
  -> TypedExpression {
      "commands": [
          { "define": "load_as", "args": {
              "path": "$1",
              "type": "$2"
          }}
      ]
  }

// ============================================================================
// Model with Config Block
// ============================================================================

// model("bert.onnx") { input: text, output: Embedding }
model_config_expr = { "model" ~ "(" ~ string_literal ~ ")" ~ "{" ~ config_entries ~ "}" }
  -> TypedExpression {
      "commands": [
          { "define": "model_config", "args": {
              "path": "$1",
              "config": "$2"
          }}
      ]
  }

// ============================================================================
// Compute Expression (GPU Kernel Dispatch)
// ============================================================================

// compute(tensor) { @kernel elementwise for i in 0..len { out[i] = x[i] * 2.0 } }
compute_expr = { "compute" ~ "(" ~ call_args ~ ")" ~ "{" ~ compute_body ~ "}" }
  -> TypedExpression {
      "commands": [
          { "define": "compute", "args": {
              "args": "$1",
              "body": "$2"
          }}
      ]
  }

// Compute body can have decorators and statements
compute_body = { (decorator | statement)* }
  -> List {
      "get_all_children": true
  }

// Path expression: Type::method or module::function
// Used for associated functions (static methods) like Duration::from(1000)
path_expr = { ns:identifier ~ "::" ~ name:identifier }
  -> TypedExpression::Path {
      segments: [intern(ns), intern(name)],
  }

// Extern function call: extern name(args)
// The extern keyword explicitly marks this as a call to a ZRTL builtin
// The name is resolved via @builtin mappings (e.g., tensor_to_string -> $Tensor$to_string)
extern_call = { "extern" ~ name:identifier ~ "(" ~ args:call_args_list? ~ ")" }
  -> TypedExpression::Call {
      callee: Box::new(TypedExpression::Variable { name: intern(name) }),
      args: args,
  }

// Grouped expression: (expr)
grouped_expr = { "(" ~ inner:expr ~ ")" }
  -> inner

// Variable reference
var_expr = { name:identifier }
  -> TypedExpression::Variable { name: intern(name) }

// ============================================================================
// Tensor Literals
// ============================================================================

// Tensor literal: tensor([1.0, 2.0, 3.0])
// Shape inference: tensor([[1, 2], [3, 4]]) -> shape [2, 2]
// Uses standard call pattern - zyntax_embed handles builtin resolution
tensor_literal = { "tensor" ~ "(" ~ array_literal ~ ")" }
  -> TypedExpression {
      "commands": [
          { "define": "call", "args": {
              "callee": { "define": "variable", "args": { "name": "tensor_from_array" } },
              "args": ["$1"]
          }}
      ]
  }

// ============================================================================
// Struct Literals
// ============================================================================

// Struct literal: Point { x: 1.0, y: 2.0 }
// Used to construct struct instances
struct_literal = { identifier ~ "{" ~ struct_literal_fields? ~ "}" }
  -> TypedExpression {
      "commands": [
          { "define": "struct_literal", "args": {
              "type_name": "$1",
              "fields": "$2"
          }}
      ]
  }

struct_literal_fields = { struct_literal_field ~ ("," ~ struct_literal_field)* }
  -> List {
      "get_all_children": true
  }

struct_literal_field = { identifier ~ ":" ~ expr }
  -> TypedExpression {
      "commands": [
          { "define": "field_init", "args": {
              "name": "$1",
              "value": "$2"
          }}
      ]
  }

// Array literal: [1, 2, 3] or [[1, 2], [3, 4]]
array_literal = { "[" ~ (array_element ~ ("," ~ array_element)*)? ~ "]" }
  -> TypedExpression {
      "get_all_children": true,
      "define": "array_literal",
      "args": { "elements": "$result" }
  }

array_element = { array_literal | expr }
  -> TypedExpression {
      "get_child": { "index": 0 }
  }

// ============================================================================
// Literals
// ============================================================================

// Float: 3.14, -2.5, 1e-3
float_literal = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ ~ (("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+)? }
  -> TypedExpression::FloatLiteral { value: parse_float(text()) }

// Suffixed literal: 1000ms, 5s, 3ns (abstract type suffix)
// Must come before int_literal to match first
suffixed_literal = @{ "-"? ~ ASCII_DIGIT+ ~ ASCII_ALPHA+ }
  -> TypedExpression::SuffixedLiteral { text: text() }

// Integer: 42, -10, 0
int_literal = @{ "-"? ~ ASCII_DIGIT+ }
  -> TypedExpression::IntLiteral { value: parse_int(text()) }

// Duration: 1h, 5m, 30s, 500ms, 2d (deprecated - use abstract types)
duration_literal = @{ ASCII_DIGIT+ ~ duration_unit }
  -> TypedExpression::DurationLiteral { text: text() }

duration_unit = { "ms" | "s" | "m" | "h" | "d" }

// String: "hello world" or """multiline string"""
string_literal = @{ triple_quoted_string | regular_string }
  -> TypedExpression::StringLiteral { value: text() }

// Triple-quoted string for multiline/docstrings
triple_quoted_string = { "\"\"\"" ~ triple_string_inner* ~ "\"\"\"" }

triple_string_inner = { !("\"\"\"") ~ ANY }

// Regular double-quoted string
regular_string = { "\"" ~ string_inner* ~ "\"" }

string_inner = { !("\"" | "\\") ~ ANY | "\\" ~ ANY }

// Boolean: true, false
bool_literal = { "true" | "false" }
  -> TypedExpression::BoolLiteral { value: parse_bool(text()) }

// Identifier - returns the text directly for use in bindings
identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// ============================================================================
// Whitespace and Comments
// ============================================================================

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
