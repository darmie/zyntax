// ============================================================================
// ZynML Grammar - Machine Learning DSL for Zyntax
// ============================================================================
//
// ZynML is a domain-specific language for machine learning pipelines.
// It provides Python-like ergonomics with systems-level performance.
//
// Features:
//   - Tensor operations with shape inference
//   - Pipe operator (|>) for data flow
//   - ML-specific builtins (audio, text, vectors, models)
//   - Clean, readable syntax
//
// Usage:
//   zynml run script.ml
//   zynml repl
//
// ============================================================================

@language {
    name: "ZynML",
    version: "1.0",
    file_extensions: [".ml", ".zynml"],
    entry_point: "main"
}

// ============================================================================
// ZRTL Plugin Symbol Mappings
// ============================================================================

@builtin {
    // === Tensor Operations (zrtl_tensor) ===
    tensor: "tensor_from_array",          // tensor([1.0, 2.0]) -> tensor_from_array([1.0, 2.0])
    tensor_from_array: "$Tensor$from_array_f32",
    tensor_zeros: "$Tensor$zeros",
    tensor_ones: "$Tensor$ones",
    tensor_full: "$Tensor$full_f32",
    arange: "$Tensor$arange_f32",             // arange(1.0, 10.0, 1.0) shorthand
    tensor_arange: "$Tensor$arange_f32",
    tensor_linspace: "$Tensor$linspace_f32",
    tensor_rand: "$Tensor$rand_f32",
    tensor_randn: "$Tensor$randn_f32",
    tensor_reshape: "$Tensor$reshape",
    tensor_transpose: "$Tensor$transpose",
    tensor_sum: "$Tensor$sum_f32",
    tensor_mean: "$Tensor$mean_f32",
    tensor_max: "$Tensor$max_f32",
    tensor_min: "$Tensor$min_f32",
    tensor_free: "$Tensor$free",
    tensor_print: "$Tensor$print",
    tensor_println: "$Tensor$println",
    tensor_to_string: "$Tensor$to_string",

    // === Audio Operations (zrtl_audio) ===
    audio_load: "$Audio$load",
    audio_free: "$Audio$free",
    audio_resample: "$Audio$resample",
    audio_to_mono: "$Audio$to_mono",
    audio_normalize: "$Audio$normalize",
    audio_trim_silence: "$Audio$trim_silence",
    audio_stft: "$Audio$stft",
    audio_mel_spectrogram: "$Audio$mel_spectrogram",
    audio_sample_rate: "$Audio$sample_rate",
    audio_duration: "$Audio$duration_seconds",

    // === Text Operations (zrtl_text) ===
    bpe_create: "$Text$bpe_create",
    bpe_encode: "$Text$bpe_encode",
    bpe_decode: "$Text$bpe_decode",
    text_lowercase: "$Text$lowercase",
    text_normalize: "$Text$normalize_whitespace",
    text_chunk: "$Text$chunk_by_sentences",

    // === Vector Operations (zrtl_vector) ===
    vec_cosine: "$Vector$cosine_similarity",
    vec_dot: "$Vector$dot_product",
    vec_euclidean: "$Vector$euclidean_distance",
    vec_normalize: "$Vector$l2_normalize",
    vec_topk: "$Vector$topk_cosine",
    flat_create: "$Vector$flat_create",
    flat_add: "$Vector$flat_add",
    flat_search: "$Vector$flat_search_cosine",
    hnsw_create: "$Vector$hnsw_create",
    hnsw_add: "$Vector$hnsw_add",
    hnsw_search: "$Vector$hnsw_search",

    // === Model Operations (zrtl_model) ===
    model_load: "$Model$load",
    model_free: "$Model$free",
    model_get_tensor: "$Model$get_tensor_f32",
    model_num_tensors: "$Model$num_tensors",

    // === SIMD Operations (zrtl_simd) ===
    simd_relu: "$SIMD$relu_f32",
    simd_sigmoid: "$SIMD$sigmoid_f32",
    simd_softmax: "$SIMD$softmax_f32",
    simd_tanh: "$SIMD$tanh_f32",
    simd_gemm: "$SIMD$gemm_f32",
    simd_layer_norm: "$SIMD$layer_norm_f32",

    // === I/O Operations (zrtl_io) ===
    // Universal print - uses DynamicBox for auto-formatting any type
    // This is the default for ZynML - prints tensors, floats, ints, strings, etc.
    print: "$IO$print_dynamic",
    println: "$IO$println_dynamic",
    eprint: "$IO$eprint_dynamic",
    eprintln: "$IO$eprintln_dynamic",

    // String-only output (for when you know it's a string)
    print_str: "$IO$print",
    println_str: "$IO$println",
    eprint_str: "$IO$eprint",
    eprintln_str: "$IO$eprintln",

    // Integer output
    print_i64: "$IO$print_i64",
    println_i64: "$IO$println_i64",
    print_u64: "$IO$print_u64",
    println_u64: "$IO$println_u64",

    // Float output
    print_f64: "$IO$print_f64",
    println_f64: "$IO$println_f64",

    // Boolean output
    print_bool: "$IO$print_bool",
    println_bool: "$IO$println_bool",

    // Character output
    print_char: "$IO$print_char",
    println_char: "$IO$println_char",

    // Input
    read_line: "$IO$read_line",
    input: "$IO$input",

    // Formatting
    format_i64: "$IO$format_i64",
    format_f64: "$IO$format_f64",
    format_bool: "$IO$format_bool",

    // Flushing
    flush: "$IO$flush",
    flush_stderr: "$IO$flush_stderr",

    // Dynamic (any type) output - handles all ZRTL types
    print_dynamic: "$IO$print_dynamic",
    println_dynamic: "$IO$println_dynamic",
    format_dynamic: "$IO$format_dynamic",

    // Array output (type-specific)
    print_array_f32: "$IO$print_array_f32",
    println_array_f32: "$IO$println_array_f32",
    print_array_i32: "$IO$print_array_i32",
    println_array_i32: "$IO$println_array_i32",
    print_array_i64: "$IO$print_array_i64",
    println_array_i64: "$IO$println_array_i64",
    print_array_f64: "$IO$print_array_f64",
    println_array_f64: "$IO$println_array_f64",

    // String operations
    string_concat: "$IO$string_concat",
    string_free: "$IO$string_free",

    // === File Operations (zrtl_fs) ===
    file_read: "$FS$read_string",
    file_write: "$FS$write_string",
    file_exists: "$FS$exists",

    // === Method Mappings ===
    // Syntax: x.method(args) -> builtin(x, args)
    @sum: "tensor_sum",           // x.sum() -> tensor_sum(x)
    @mean: "tensor_mean",         // x.mean() -> tensor_mean(x)
    @max: "tensor_max",           // x.max() -> tensor_max(x)
    @min: "tensor_min",           // x.min() -> tensor_min(x)
    @reshape: "tensor_reshape",   // x.reshape(shape) -> tensor_reshape(x, shape)
    @transpose: "tensor_transpose", // x.transpose() -> tensor_transpose(x)
    @normalize: "vec_normalize",  // x.normalize() -> vec_normalize(x)
    @dot: "vec_dot",              // x.dot(y) -> vec_dot(x, y)
    @cosine: "vec_cosine",        // x.cosine(y) -> vec_cosine(x, y)

    // === Operator Overloads ===
    // Syntax: x op y -> builtin(x, y)
    // Note: These apply globally - for type-aware overloading, use method syntax
    $@: "vec_dot"                 // x @ y -> vec_dot(x, y) (matrix multiply, like Python)
}

// ============================================================================
// Type Declarations for Opaque Types and Return Type Tracking
// ============================================================================
// Declares opaque types (ZRTL-backed pointer types) and function return types
// so the compiler can properly track types for operator trait dispatch.

@types {
    // Opaque types - these are pointer types backed by ZRTL plugins
    opaque: [$Tensor, $Audio, $Model, $Vector, $Text, $BPETokenizer, $FlatIndex, $HNSWIndex],

    // Function return types - tells the compiler what type each function returns
    returns: {
        // Tensor operations return $Tensor
        tensor: $Tensor,
        tensor_from_array: $Tensor,
        tensor_zeros: $Tensor,
        tensor_ones: $Tensor,
        tensor_full: $Tensor,
        arange: $Tensor,                // Shorthand for tensor_arange
        tensor_arange: $Tensor,
        tensor_linspace: $Tensor,
        tensor_rand: $Tensor,
        tensor_randn: $Tensor,
        tensor_reshape: $Tensor,
        tensor_transpose: $Tensor,

        // Audio operations return $Audio
        audio_load: $Audio,
        audio_resample: $Audio,
        audio_to_mono: $Audio,
        audio_normalize: $Audio,
        audio_trim_silence: $Audio,
        audio_stft: $Tensor,
        audio_mel_spectrogram: $Tensor,

        // Text operations
        bpe_create: $BPETokenizer,
        bpe_encode: $Tensor,

        // Vector operations
        flat_create: $FlatIndex,
        hnsw_create: $HNSWIndex,

        // Model operations
        model_load: $Model,
        model_get_tensor: $Tensor
    }
}

// ============================================================================
// Program Structure
// ============================================================================

program = { SOI ~ top_level_items ~ EOI }
  -> TypedProgram {
      "get_child": { "index": 0 }
  }

top_level_items = { top_level_item* }
  -> TypedProgram {
      "get_all_children": true,
      "define": "program",
      "args": { "declarations": "$result" }
  }

top_level_item = { trait_def | impl_block | struct_def | type_def | fn_def | let_stmt | import_stmt | expr_stmt }
  -> TypedDeclaration {
      "get_child": { "index": 0 }
  }

// ============================================================================
// Import Statement
// ============================================================================

// import tensor
// import prelude
import_stmt = { "import" ~ identifier }
  -> TypedDeclaration {
      "commands": [
          { "define": "import", "args": {
              "module_name": "$1"
          }}
      ]
  }

// ============================================================================
// Trait Definition
// ============================================================================

// trait Display { fn to_string(self) -> String }
// trait Iterator<T> { fn next(self) -> Option<T> }
// trait Add<Rhs> { type Output; fn add(self, rhs: Rhs) -> Output }
trait_def = { "trait" ~ identifier ~ type_params? ~ "{" ~ trait_item* ~ "}" }
  -> TypedDeclaration {
      "commands": [
          { "define": "trait", "args": {
              "name": "$1",
              "type_params": "$2",
              "items": "$3"
          }}
      ]
  }

// Trait item can be an associated type or a method
trait_item = { associated_type | trait_method }
  -> TypedDeclaration {
      "get_child": { "index": 0 }
  }

// Associated type: type Output
// With bounds: type Item: Clone
associated_type = { "type" ~ identifier ~ (":" ~ type_bounds)? }
  -> TypedDeclaration {
      "commands": [
          { "define": "associated_type", "args": {
              "name": "$1",
              "bounds": "$2"
          }}
      ]
  }

trait_method = { "fn" ~ identifier ~ type_params? ~ "(" ~ trait_params? ~ ")" ~ ("->" ~ type_expr)? }
  -> TypedDeclaration {
      "commands": [
          { "define": "trait_method", "args": {
              "name": "$1",
              "type_params": "$2",
              "params": "$3",
              "return_type": "$4"
          }}
      ]
  }

trait_params = { trait_param ~ ("," ~ trait_param)* }
  -> List {
      "get_all_children": true
  }

trait_param = { identifier ~ (":" ~ type_expr)? }
  -> TypedParameter {
      "commands": [
          { "define": "param", "args": {
              "name": "$1",
              "type": "$2"
          }}
      ]
  }

// Type parameters: <T, U>
// With bounds: <T: Display, U: Clone + Debug>
type_params = { "<" ~ type_param ~ ("," ~ type_param)* ~ ">" }
  -> List {
      "get_all_children": true
  }

type_param = { identifier ~ (":" ~ type_bounds)? }
  -> TypedTypeParam {
      "commands": [
          { "define": "type_param", "args": {
              "name": "$1",
              "bounds": "$2"
          }}
      ]
  }

type_bounds = { type_expr ~ ("+" ~ type_expr)* }
  -> List {
      "get_all_children": true
  }

// ============================================================================
// Type Definition
// ============================================================================

// @opaque("$Tensor") type Tensor
// type Point = { x: f32, y: f32 }
type_def = { type_opaque | type_alias | type_struct }
  -> TypedDeclaration {
      "get_child": { "index": 0 }
  }

// Opaque type wrapping external (ZRTL) type
// Match @opaque as two separate tokens to avoid conflict with @ operator
// Get the full text and parse it in the runtime since atomic rules don't create child nodes
type_opaque = { "@" ~ "opaque" ~ "(" ~ string_literal ~ ")" ~ "type" ~ identifier }
  -> TypedDeclaration {
      "get_text": true,
      "commands": [
          { "define": "opaque_type", "args": {
              "text": "$result"
          }}
      ]
  }

// Type alias: type Scalar = f32
type_alias = { "type" ~ identifier ~ "=" ~ type_expr }
  -> TypedDeclaration {
      "commands": [
          { "define": "type_alias", "args": {
              "name": "$1",
              "target": "$2"
          }}
      ]
  }

// Struct type: type Point = { x: f32, y: f32 }
type_struct = { "type" ~ identifier ~ "=" ~ "{" ~ struct_fields ~ "}" }
  -> TypedDeclaration {
      "commands": [
          { "define": "struct_type", "args": {
              "name": "$1",
              "fields": "$2"
          }}
      ]
  }

struct_fields = { struct_field ~ ("," ~ struct_field)* ~ ","? }
  -> List {
      "get_all_children": true
  }

struct_field = { identifier ~ ":" ~ type_expr }
  -> TypedParameter {
      "commands": [
          { "define": "field", "args": {
              "name": "$1",
              "type": "$2"
          }}
      ]
  }

// ============================================================================
// Struct Definition (Colon Syntax)
// ============================================================================

// struct Point:
//     x: float
//     y: float
// Note: Whitespace is handled implicitly by WHITESPACE rule
struct_def = { "struct" ~ identifier ~ ":" ~ struct_def_fields }
  -> TypedDeclaration {
      "commands": [
          { "define": "struct_type", "args": {
              "name": "$1",
              "fields": "$2"
          }}
      ]
  }

struct_def_fields = { struct_def_field+ }
  -> List {
      "get_all_children": true
  }

struct_def_field = { identifier ~ ":" ~ type_expr }
  -> TypedParameter {
      "commands": [
          { "define": "field", "args": {
              "name": "$1",
              "type": "$2"
          }}
      ]
  }

// ============================================================================
// Impl Block (Trait Implementation)
// ============================================================================

// impl Display for Tensor { fn to_string(self) -> String { ... } }
// impl Add<Tensor> for Tensor { type Output = Tensor; fn add(...) { ... } }
// Split into two rules to avoid optional capture index shifting
impl_block = { impl_block_with_args | impl_block_simple }
  -> TypedDeclaration {
      "get_child": { "index": 0 }
  }

// impl Trait<Args> for Type { ... }
impl_block_with_args = { "impl" ~ identifier ~ type_args_angle ~ "for" ~ identifier ~ "{" ~ impl_items ~ "}" }
  -> TypedDeclaration {
      "commands": [
          { "define": "impl_block", "args": {
              "trait_name": "$1",
              "trait_args": "$2",
              "type_name": "$3",
              "items": "$4"
          }}
      ]
  }

// impl Trait for Type { ... }
impl_block_simple = { "impl" ~ identifier ~ "for" ~ identifier ~ "{" ~ impl_items ~ "}" }
  -> TypedDeclaration {
      "commands": [
          { "define": "impl_block", "args": {
              "trait_name": "$1",
              "trait_args": "none",
              "type_name": "$2",
              "items": "$3"
          }}
      ]
  }

impl_items = { impl_item* }
  -> List {
      "get_all_children": true
  }

impl_item = { impl_assoc_type | impl_method_return | impl_method_params | impl_method_simple }
  -> TypedDeclaration {
      "get_child": { "index": 0 }
  }

// type Output = Tensor
impl_assoc_type = { "type" ~ identifier ~ "=" ~ type_expr }
  -> TypedDeclaration {
      "commands": [
          { "define": "impl_assoc_type", "args": {
              "name": "$1",
              "type": "$2"
          }}
      ]
  }

// Impl methods can't have their own type params (they use the impl block's)
// So we define specific impl method rules without type params

// fn add(self, rhs: T) -> ReturnType { ... }
// NOTE: Impl methods are initially typed as functions but marked with is_self on parameters
// The compiler will re-type the body expressions with correct self type during lowering
impl_method_return = { "fn" ~ identifier ~ "(" ~ fn_params? ~ ")" ~ "->" ~ type_expr ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "function", "args": {
              "name": "$1",
              "params": "$2",
              "return_type": "$3",
              "body": "$4"
          }}
      ]
  }

// fn process(self, other: T) { ... }
impl_method_params = { "fn" ~ identifier ~ "(" ~ fn_params ~ ")" ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "function", "args": {
              "name": "$1",
              "params": "$2",
              "return_type": "void",
              "body": "$3"
          }}
      ]
  }

// fn simple() { ... }
impl_method_simple = { "fn" ~ identifier ~ "(" ~ ")" ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "function", "args": {
              "name": "$1",
              "params": [],
              "return_type": "void",
              "body": "$2"
          }}
      ]
  }

// Type arguments in angle brackets (for trait impl)
type_args_angle = { "<" ~ type_args ~ ">" }
  -> List {
      "get_child": { "index": 0 }
  }

// ============================================================================
// Type Expressions
// ============================================================================

type_expr = { generic_type | array_type | simple_type }
  -> TypedType {
      "get_child": { "index": 0 }
  }

simple_type = { identifier }
  -> TypedType {
      "get_text": true,
      "define": "named_type",
      "args": { "name": "$result" }
  }

array_type = { "Array" ~ "<" ~ type_expr ~ ">" }
  -> TypedType {
      "commands": [
          { "define": "array_type", "args": {
              "element_type": "$1"
          }}
      ]
  }

generic_type = { identifier ~ "<" ~ type_args ~ ">" }
  -> TypedType {
      "commands": [
          { "define": "generic_type", "args": {
              "name": "$1",
              "type_args": "$2"
          }}
      ]
  }

type_args = { type_expr ~ ("," ~ type_expr)* }
  -> List {
      "get_all_children": true
  }

// ============================================================================
// Function Definition
// ============================================================================

// Function definitions - split by presence of type params, params, and return type
// to ensure predictable child indices (PEG doesn't emit placeholders for missing optionals)
fn_def = { fn_def_generic_return | fn_def_generic | fn_def_return | fn_def_params | fn_def_simple }
  -> TypedDeclaration {
      "get_child": { "index": 0 }
  }

// fn map<T, U>(items) -> ReturnType { ... }
fn_def_generic_return = { "fn" ~ identifier ~ type_params ~ "(" ~ fn_params? ~ ")" ~ "->" ~ type_expr ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "function", "args": {
              "name": "$1",
              "type_params": "$2",
              "params": "$3",
              "return_type": "$4",
              "body": "$5"
          }}
      ]
  }

// fn process<T>(x) { ... }
fn_def_generic = { "fn" ~ identifier ~ type_params ~ "(" ~ fn_params? ~ ")" ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "function", "args": {
              "name": "$1",
              "type_params": "$2",
              "params": "$3",
              "return_type": "void",
              "body": "$4"
          }}
      ]
  }

// fn process(x, y) -> ReturnType { ... }
fn_def_return = { "fn" ~ identifier ~ "(" ~ fn_params? ~ ")" ~ "->" ~ type_expr ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "function", "args": {
              "name": "$1",
              "params": "$2",
              "return_type": "$3",
              "body": "$4"
          }}
      ]
  }

// fn process(x, y) { ... } - with params, no return type
fn_def_params = { "fn" ~ identifier ~ "(" ~ fn_params ~ ")" ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "function", "args": {
              "name": "$1",
              "params": "$2",
              "return_type": "void",
              "body": "$3"
          }}
      ]
  }

// fn main() { ... } - no params, no return type
fn_def_simple = { "fn" ~ identifier ~ "(" ~ ")" ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "function", "args": {
              "name": "$1",
              "params": [],
              "return_type": "void",
              "body": "$2"
          }}
      ]
  }

fn_params = { fn_param ~ ("," ~ fn_param)* }
  -> List {
      "get_all_children": true
  }

// Parameter with optional type annotation
// Supports: x, x: Int, self, self: Tensor
fn_param = { identifier ~ (":" ~ type_expr)? }
  -> TypedParameter {
      "commands": [
          { "define": "param", "args": {
              "name": "$1",
              "type": "$2"
          }}
      ]
  }

// ============================================================================
// Statements
// ============================================================================

statement = { let_stmt | assign_stmt | if_stmt | while_stmt | for_stmt | return_stmt | expr_stmt }
  -> TypedStatement {
      "get_child": { "index": 0 }
  }

// let x = expr
// let mel = audio |> resample(16000) |> to_mono()
let_stmt = { "let" ~ identifier ~ "=" ~ expr }
  -> TypedStatement {
      "commands": [
          { "define": "let_stmt", "args": {
              "name": "$1",
              "type": { "define": "infer_type" },
              "init": "$2",
              "is_const": false
          }}
      ]
  }

// x = expr
assign_stmt = { identifier ~ "=" ~ expr }
  -> TypedStatement {
      "commands": [
          { "define": "assignment", "args": {
              "target": { "define": "variable", "args": { "name": "$1" } },
              "value": "$2"
          }}
      ]
  }

// if condition { ... } else { ... }
if_stmt = { "if" ~ expr ~ block ~ ("else" ~ block)? }
  -> TypedStatement {
      "commands": [
          { "define": "if_stmt", "args": {
              "condition": "$1",
              "then_branch": "$2",
              "else_branch": "$3"
          }}
      ]
  }

// while condition { ... }
while_stmt = { "while" ~ expr ~ block }
  -> TypedStatement {
      "commands": [
          { "define": "while_stmt", "args": {
              "condition": "$1",
              "body": "$2"
          }}
      ]
  }

// for i in range(10) { ... }
// for item in items { ... }
for_stmt = { "for" ~ identifier ~ "in" ~ expr ~ block }
  -> TypedStatement {
      "commands": [
          { "define": "for_stmt", "args": {
              "var": "$1",
              "iter": "$2",
              "body": "$3"
          }}
      ]
  }

// return expr
return_stmt = { "return" ~ expr? }
  -> TypedStatement {
      "commands": [
          { "define": "return_stmt", "args": {
              "value": "$1"
          }}
      ]
  }

// expr as statement
expr_stmt = { expr }
  -> TypedStatement {
      "commands": [
          { "define": "expression_stmt", "args": {
              "expr": "$1"
          }}
      ]
  }

// { statements }
block = { "{" ~ statement* ~ "}" }
  -> TypedBlock {
      "get_all_children": true,
      "define": "block",
      "args": { "statements": "$result" }
  }

// ============================================================================
// Expressions
// ============================================================================

// Expression with pipe operator (lowest precedence)
expr = { pipe_expr }
  -> TypedExpression {
      "get_child": { "index": 0 }
  }

// Pipe operator: x |> f(args) |> g()
// Transforms: a |> f(b) into f(a, b)
pipe_expr = { ternary_expr ~ ("|>" ~ pipe_call)* }
  -> TypedExpression {
      "get_all_children": true,
      "fold_left": {
          "op": "pipe",
          "transform": "prepend_arg"
      }
  }

pipe_call = { identifier ~ "(" ~ call_args? ~ ")" }
  -> TypedExpression {
      "commands": [
          { "define": "pipe_target", "args": {
              "callee": { "define": "variable", "args": { "name": "$1" } },
              "args": "$2"
          }}
      ]
  }

// Ternary conditional: condition ? true_expr : false_expr
// Two separate rules to handle optional ternary syntax
ternary_expr = { ternary_with_branches | or_expr }
  -> TypedExpression {
      "get_child": { "index": 0 }
  }

ternary_with_branches = { or_expr ~ "?" ~ or_expr ~ ":" ~ or_expr }
  -> TypedExpression {
      "define": "ternary", "args": {
          "condition": "$1",
          "then_expr": "$2",
          "else_expr": "$3"
      }
  }

// Logical OR
or_expr = { and_expr ~ ("||" ~ and_expr)* }
  -> TypedExpression {
      "get_all_children": true,
      "fold_left": { "op": "||" }
  }

// Logical AND
and_expr = { comparison_expr ~ ("&&" ~ comparison_expr)* }
  -> TypedExpression {
      "get_all_children": true,
      "fold_left": { "op": "&&" }
  }

// Comparison: ==, !=, <, >, <=, >=
comparison_expr = { additive_expr ~ (comparison_op ~ additive_expr)? }
  -> TypedExpression {
      "get_all_children": true,
      "fold_binary": true
  }

comparison_op = { "==" | "!=" | "<=" | ">=" | "<" | ">" }
  -> String {
      "get_text": true
  }

// Addition and subtraction
additive_expr = { multiplicative_expr ~ (additive_op ~ multiplicative_expr)* }
  -> TypedExpression {
      "get_all_children": true,
      "fold_left_ops": true
  }

additive_op = { "+" | "-" }
  -> String {
      "get_text": true
  }

// Multiplication, division, modulo
multiplicative_expr = { unary_expr ~ (multiplicative_op ~ unary_expr)* }
  -> TypedExpression {
      "get_all_children": true,
      "fold_left_ops": true
  }

// Note: "@" in quotes is a literal character, not the pest atomic rule marker
multiplicative_op = { "@" | "*" | "/" | "%" }
  -> String {
      "get_text": true
  }

// Unary operators: -, !
unary_expr = { unary_op? ~ postfix_expr }
  -> TypedExpression {
      "get_all_children": true,
      "apply_unary": true
  }

unary_op = { "-" | "!" }
  -> String {
      "get_text": true
  }

// Postfix: function calls, indexing, member access
postfix_expr = { primary_expr ~ postfix_op* }
  -> TypedExpression {
      "get_all_children": true,
      "fold_postfix": true
  }

postfix_op = { call_op | index_op | member_op }
  -> TypedExpression {
      "get_child": { "index": 0 }
  }

// Function call: f(args)
call_op = { "(" ~ call_args? ~ ")" }
  -> TypedExpression {
      "get_child": { "index": 0 },
      "define": "call_args",
      "args": { "args": "$result" }
  }

call_args = { expr ~ ("," ~ expr)* }
  -> List {
      "get_all_children": true
  }

// Indexing: x[i]
index_op = { "[" ~ expr ~ "]" }
  -> TypedExpression {
      "define": "index",
      "args": { "index": "$1" }
  }

// Member access: x.field
member_op = { "." ~ identifier }
  -> TypedExpression {
      "define": "member",
      "args": { "field": "$1" }
  }

// Primary expressions
primary_expr = {
    extern_call |
    tensor_literal |
    struct_literal |
    array_literal |
    float_literal |
    int_literal |
    string_literal |
    bool_literal |
    grouped_expr |
    var_expr
}
  -> TypedExpression {
      "get_child": { "index": 0 }
  }

// Extern function call: extern name(args)
// The extern keyword explicitly marks this as a call to a ZRTL builtin
// The name is resolved via @builtin mappings (e.g., tensor_to_string -> $Tensor$to_string)
extern_call = { "extern" ~ identifier ~ "(" ~ call_args? ~ ")" }
  -> TypedExpression {
      "commands": [
          { "define": "call", "args": {
              "callee": { "define": "variable", "args": { "name": "$1" } },
              "args": "$2"
          }}
      ]
  }

// Grouped expression: (expr)
grouped_expr = { "(" ~ expr ~ ")" }
  -> TypedExpression {
      "get_child": { "index": 0 }
  }

// Variable reference
var_expr = { identifier }
  -> TypedExpression {
      "get_text": true,
      "define": "variable",
      "args": { "name": "$result" }
  }

// ============================================================================
// Tensor Literals
// ============================================================================

// Tensor literal: tensor([1.0, 2.0, 3.0])
// Shape inference: tensor([[1, 2], [3, 4]]) -> shape [2, 2]
// Uses standard call pattern - zyntax_embed handles builtin resolution
tensor_literal = { "tensor" ~ "(" ~ array_literal ~ ")" }
  -> TypedExpression {
      "commands": [
          { "define": "call", "args": {
              "callee": { "define": "variable", "args": { "name": "tensor_from_array" } },
              "args": ["$1"]
          }}
      ]
  }

// ============================================================================
// Struct Literals
// ============================================================================

// Struct literal: Point { x: 1.0, y: 2.0 }
// Used to construct struct instances
struct_literal = { identifier ~ "{" ~ struct_literal_fields? ~ "}" }
  -> TypedExpression {
      "commands": [
          { "define": "struct_literal", "args": {
              "type_name": "$1",
              "fields": "$2"
          }}
      ]
  }

struct_literal_fields = { struct_literal_field ~ ("," ~ struct_literal_field)* }
  -> List {
      "get_all_children": true
  }

struct_literal_field = { identifier ~ ":" ~ expr }
  -> TypedExpression {
      "commands": [
          { "define": "field_init", "args": {
              "name": "$1",
              "value": "$2"
          }}
      ]
  }

// Array literal: [1, 2, 3] or [[1, 2], [3, 4]]
array_literal = { "[" ~ (array_element ~ ("," ~ array_element)*)? ~ "]" }
  -> TypedExpression {
      "get_all_children": true,
      "define": "array_literal",
      "args": { "elements": "$result" }
  }

array_element = { array_literal | expr }
  -> TypedExpression {
      "get_child": { "index": 0 }
  }

// ============================================================================
// Literals
// ============================================================================

// Float: 3.14, -2.5, 1e-3
float_literal = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ ~ (("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+)? }
  -> TypedExpression {
      "get_text": true,
      "parse_float": true,
      "define": "float_literal",
      "args": { "value": "$result" }
  }

// Integer: 42, -10, 0
int_literal = @{ "-"? ~ ASCII_DIGIT+ }
  -> TypedExpression {
      "get_text": true,
      "parse_int": true,
      "define": "int_literal",
      "args": { "value": "$result" }
  }

// String: "hello world" or """multiline string"""
string_literal = @{ triple_quoted_string | regular_string }
  -> TypedExpression {
      "get_text": true,
      "define": "string_literal",
      "args": { "value": "$result" }
  }

// Triple-quoted string for multiline/docstrings
triple_quoted_string = { "\"\"\"" ~ triple_string_inner* ~ "\"\"\"" }

triple_string_inner = { !("\"\"\"") ~ ANY }

// Regular double-quoted string
regular_string = { "\"" ~ string_inner* ~ "\"" }

string_inner = { !("\"" | "\\") ~ ANY | "\\" ~ ANY }

// Boolean: true, false
bool_literal = { "true" | "false" }
  -> TypedExpression {
      "get_text": true,
      "parse_bool": true,
      "define": "bool_literal",
      "args": { "value": "$result" }
  }

// Identifier
identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
  -> String {
      "get_text": true
  }

// ============================================================================
// Whitespace and Comments
// ============================================================================

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
