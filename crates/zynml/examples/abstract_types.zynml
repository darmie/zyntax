// Example: Abstract Types with Method Dispatch
// Demonstrates zero-cost abstractions with compile-time method resolution

import prelude

// Abstract Duration type with suffix literals
// Wraps i64 but provides type-safe time operations
abstract Duration(i64) with Suffixes("ms, s, m"):
    value: i64

// Inherent methods for Duration
impl Duration(i64) {
    // Constructor: create from milliseconds
    fn from_ms(v: i64) -> Duration:
        Duration { value: v }

    // Constructor: create from seconds
    fn from_s(v: i64) -> Duration:
        Duration { value: v * 1000 }

    // Constructor: create from minutes
    fn from_m(v: i64) -> Duration:
        Duration { value: v * 60000 }

    // Conversion: to milliseconds
    fn to_ms(self) -> i64:
        self.value

    // Conversion: to seconds (integer division)
    fn to_s(self) -> i64:
        self.value / 1000

    // Conversion: to minutes
    fn to_m(self) -> i64:
        self.value / 60000
}

fn main():
    // Demonstrate Duration with suffix literals and method dispatch

    // Test 1: milliseconds literal
    let delay1 = 1000ms
    println(delay1.to_ms())  // Expected: 1000

    // Test 2: seconds literal with conversion
    let delay2 = 5s
    println(delay2.to_ms())  // Expected: 5000
    println(delay2.to_s())   // Expected: 5

    // Test 3: minutes literal
    let delay3 = 2m
    println(delay3.to_ms())  // Expected: 120000
    println(delay3.to_s())   // Expected: 120
    println(delay3.to_m())   // Expected: 2

    // Test 4: using constructor methods
    let delay4 = Duration::from_ms(500)
    println(delay4.to_ms())  // Expected: 500

    let delay5 = Duration::from_s(10)
    println(delay5.to_ms())  // Expected: 10000
    println(delay5.to_s())   // Expected: 10
