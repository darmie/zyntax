// ============================================================================
// ZynML Standard Library - Tensor Module
// ============================================================================
//
// Tensor type for multi-dimensional numerical arrays.
// Wraps the zrtl_tensor plugin with a high-level ZynML interface.
//
// Builtin functions use the "extern" keyword to call ZRTL plugin functions.
// Example: extern tensor_to_string(x) calls the builtin "tensor_to_string"
//
// ============================================================================

import prelude

// Internal opaque type from the plugin
@opaque("$Tensor")
type TensorPtr

// Tensor is a struct that wraps the opaque pointer
struct Tensor { ptr: TensorPtr }

// Implement Display trait for Tensor
impl Display for Tensor {
    fn to_string(self) -> String: extern tensor_to_string(self.ptr)
}

// Implement Clone trait for Tensor
impl Clone for Tensor {
    fn clone(self) -> Tensor: Tensor { ptr: extern tensor_clone(self.ptr) }
}

// Implement Drop trait for Tensor
impl Drop for Tensor {
    fn drop(self): extern tensor_free(self.ptr)
}

// ============================================================================
// Operator Trait Implementations
// ============================================================================

// Tensor + Tensor
impl Add<Tensor> for Tensor {
    type Output = Tensor
    fn add(self, rhs: Tensor) -> Tensor: Tensor { ptr: extern tensor_add(self.ptr, rhs.ptr) }
}

// Tensor - Tensor
impl Sub<Tensor> for Tensor {
    type Output = Tensor
    fn sub(self, rhs: Tensor) -> Tensor: Tensor { ptr: extern tensor_sub(self.ptr, rhs.ptr) }
}

// Tensor * Tensor (element-wise)
impl Mul<Tensor> for Tensor {
    type Output = Tensor
    fn mul(self, rhs: Tensor) -> Tensor: Tensor { ptr: extern tensor_mul(self.ptr, rhs.ptr) }
}

// Tensor / Tensor (element-wise)
impl Div<Tensor> for Tensor {
    type Output = Tensor
    fn div(self, rhs: Tensor) -> Tensor: Tensor { ptr: extern tensor_div(self.ptr, rhs.ptr) }
}

// Tensor @ Tensor (matrix multiplication / dot product)
impl MatMul<Tensor> for Tensor {
    type Output = f32  // Returns scalar for vector dot product
    fn matmul(self, rhs: Tensor) -> f32: extern tensor_dot(self.ptr, rhs.ptr)
}

// Tensor negation (-x)
impl Neg for Tensor {
    type Output = Tensor
    fn neg(self) -> Tensor: Tensor { ptr: extern tensor_neg(self.ptr) }
}

// ============================================================================
// Tensor Creation Functions
// ============================================================================

// Create tensor from array literal
// Usage: from_array([1.0, 2.0, 3.0])
fn from_array(data: Array<f32>) -> Tensor {
    Tensor { ptr: extern tensor_from_array(data) }
}

// Create tensor filled with zeros
// Usage: zeros([3, 4])  // 3x4 matrix of zeros
fn zeros(shape: Array<i64>, dtype: i32) -> Tensor {
    Tensor { ptr: extern tensor_zeros(shape, dtype) }
}

// Create tensor filled with ones
// Usage: ones([3, 4])
fn ones(shape: Array<i64>, dtype: i32) -> Tensor {
    Tensor { ptr: extern tensor_ones(shape, dtype) }
}

// Create tensor with values in range [start, end) with step
// Usage: arange(0.0, 10.0, 1.0)
fn arange(start: f32, end: f32, step: f32) -> Tensor {
    Tensor { ptr: extern tensor_arange(start, end, step) }
}

// Create tensor with n evenly spaced values between start and end
// Usage: linspace(0.0, 1.0, 100)
fn linspace(start: f32, end: f32, n: i64) -> Tensor {
    Tensor { ptr: extern tensor_linspace(start, end, n) }
}

// Create tensor with random values in [0, 1)
// Usage: rand([3, 4], seed)
fn rand(shape: Array<i64>, seed: i64) -> Tensor {
    Tensor { ptr: extern tensor_rand(shape, seed) }
}

// Create tensor with random normal values (mean=0, std=1)
// Usage: randn([3, 4], seed)
fn randn(shape: Array<i64>, seed: i64) -> Tensor {
    Tensor { ptr: extern tensor_randn(shape, seed) }
}

// ============================================================================
// Tensor Methods
// ============================================================================
//
// TODO: These should use @method attribute when that's implemented
// For now, they can be called as regular functions: sum(tensor)

fn sum(t: Tensor) -> f32 {
    extern tensor_sum(t.ptr)
}

fn mean(t: Tensor) -> f32 {
    extern tensor_mean(t.ptr)
}

fn max(t: Tensor) -> f32 {
    extern tensor_max(t.ptr)
}

fn min(t: Tensor) -> f32 {
    extern tensor_min(t.ptr)
}

fn reshape(t: Tensor, shape: Array<i64>) -> Tensor {
    Tensor { ptr: extern tensor_reshape(t.ptr, shape) }
}

fn transpose(t: Tensor, dim0: i32, dim1: i32) -> Tensor {
    Tensor { ptr: extern tensor_transpose(t.ptr, dim0, dim1) }
}
