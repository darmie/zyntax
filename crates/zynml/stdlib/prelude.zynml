// ============================================================================
// ZynML Standard Library - Prelude
// ============================================================================
//
// Core traits and types that are automatically available in all ZynML programs.
//
// The compiler recognizes these standard traits and generates appropriate code:
// - Display: enables println(x) to format any type
// - Operator traits: enables operator overloading (+, -, *, /, @, etc.)
//
// ============================================================================

// ============================================================================
// Formatting Traits
// ============================================================================

// Display trait - types that can be converted to string representation
// Types implementing Display can be used with println() and string interpolation
trait Display {
    fn to_string(self) -> String
}

// Debug trait - types with debug representation (more verbose than Display)
trait Debug {
    fn debug_string(self) -> String
}

// ============================================================================
// Arithmetic Operator Traits
// ============================================================================

// Add trait - enables x + y
trait Add<Rhs> {
    type Output
    fn add(self, rhs: Rhs) -> Output
}

// Sub trait - enables x - y
trait Sub<Rhs> {
    type Output
    fn sub(self, rhs: Rhs) -> Output
}

// Mul trait - enables x * y
trait Mul<Rhs> {
    type Output
    fn mul(self, rhs: Rhs) -> Output
}

// Div trait - enables x / y
trait Div<Rhs> {
    type Output
    fn div(self, rhs: Rhs) -> Output
}

// Mod trait - enables x % y
trait Mod<Rhs> {
    type Output
    fn mod(self, rhs: Rhs) -> Output
}

// MatMul trait - enables x @ y (matrix multiplication)
trait MatMul<Rhs> {
    type Output
    fn matmul(self, rhs: Rhs) -> Output
}

// Neg trait - enables -x (unary negation)
trait Neg {
    type Output
    fn neg(self) -> Output
}

// ============================================================================
// Comparison Operator Traits
// ============================================================================

// Eq trait - enables x == y and x != y
trait Eq<Rhs> {
    fn eq(self, rhs: Rhs) -> bool
    fn ne(self, rhs: Rhs) -> bool
}

// Ord trait - enables x < y, x > y, x <= y, x >= y
trait Ord<Rhs> {
    fn lt(self, rhs: Rhs) -> bool
    fn gt(self, rhs: Rhs) -> bool
    fn le(self, rhs: Rhs) -> bool
    fn ge(self, rhs: Rhs) -> bool
}

// ============================================================================
// Bitwise Operator Traits
// ============================================================================

// BitAnd trait - enables x & y
trait BitAnd<Rhs> {
    type Output
    fn bitand(self, rhs: Rhs) -> Output
}

// BitOr trait - enables x | y
trait BitOr<Rhs> {
    type Output
    fn bitor(self, rhs: Rhs) -> Output
}

// BitXor trait - enables x ^ y
trait BitXor<Rhs> {
    type Output
    fn bitxor(self, rhs: Rhs) -> Output
}

// Not trait - enables !x (unary not)
trait Not {
    type Output
    fn not(self) -> Output
}

// ============================================================================
// Indexing Trait
// ============================================================================

// Index trait - enables x[i]
trait Index<Idx> {
    type Output
    fn index(self, idx: Idx) -> Output
}

// IndexMut trait - enables x[i] = v
trait IndexMut<Idx> {
    type Output
    fn index_mut(self, idx: Idx) -> Output
}

// ============================================================================
// Lifecycle Traits
// ============================================================================

// Clone trait - types that can be deeply copied
trait Clone {
    fn clone(self) -> Self
}

// Drop trait - types with custom cleanup logic
trait Drop {
    fn drop(self)
}

// ============================================================================
// Iterator Trait
// ============================================================================

// Iterator trait - enables for loops
trait Iterator {
    type Item
    fn next(self) -> Option<Item>
}

// IntoIterator trait - types that can be converted to iterators
trait IntoIterator {
    type Item
    type IntoIter: Iterator<Item>
    fn into_iter(self) -> IntoIter
}

// ============================================================================
// Type Conversion Traits
// ============================================================================

// From trait - value-to-value conversion that consumes the input
// Used for type conversions, e.g., Duration::from(1000)
trait From<T> {
    fn from(value: T) -> Self
}

// Into trait - value-to-value conversion that consumes self
// Used for type conversions, e.g., duration.into()
// Note: Usually auto-implemented via blanket impl when From is implemented
trait Into<T> {
    fn into(self) -> T
}

// ============================================================================
// Core Types
// ============================================================================

// Option type - represents an optional value
enum Option<T> {
    Some(T),
    None
}

// Result type - represents either success or failure
enum Result<T, E> {
    Ok(T),
    Err(E)
}

// ============================================================================
// Collections
// ============================================================================

// List - dynamically sized array backed by ZRTL runtime
// This is a simple wrapper around raw pointers with length/capacity tracking
struct List<T>:
    data: i64      // Pointer to data (will be properly typed when we have generics in runtime)
    len: i64       // Number of elements
    capacity: i64  // Allocated capacity

impl<T> List<T> {
    // Create an empty list
    fn new() -> List<T> {
        List { data: 0, len: 0, capacity: 0 }
    }

    // Get the length of the list
    fn length(self) -> i64 {
        self.len
    }

    // Check if list is empty
    fn is_empty(self) -> bool {
        self.len == 0
    }
}

// ListIterator - iterator over a list
struct ListIterator<T>:
    list_data: i64   // Pointer to list data
    list_len: i64    // Total length
    index: i64       // Current index

impl<T> Iterator for ListIterator<T> {
    type Item = T

    fn next(self) -> Option<T> {
        if self.index >= self.list_len {
            Option::None
        } else {
            // This will need proper pointer arithmetic and load in the actual implementation
            // For now, this is the interface that the compiler will recognize
            let value = extern list_get_at(self.list_data, self.index)
            self.index = self.index + 1
            Option::Some(value)
        }
    }
}

impl<T> IntoIterator for List<T> {
    type Item = T
    type IntoIter = ListIterator<T>

    fn into_iter(self) -> ListIterator<T> {
        ListIterator {
            list_data: self.data,
            list_len: self.len,
            index: 0
        }
    }
}
