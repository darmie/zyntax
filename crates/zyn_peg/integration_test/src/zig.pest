// Generated by ZynPEG from zig.zyn

program = { SOI ~ declaration* ~ EOI  }
declaration = { const_decl
  | var_decl
  | fn_decl
  | struct_decl
  | enum_decl
  | union_decl
  | error_set_decl
 }
const_decl = { "const" ~ identifier ~ (":" ~ type_expr)? ~ "=" ~ expr ~ ";"  }
var_decl = { "var" ~ identifier ~ (":" ~ type_expr)? ~ "=" ~ expr ~ ";"  }
fn_decl = { "fn" ~ identifier ~
    "(" ~ fn_params? ~ ")" ~ type_expr ~
    block
 }
fn_params = { fn_param ~ ("," ~ fn_param)*  }
fn_param = { comptime_param | regular_param  }
comptime_param = { "comptime" ~ identifier ~ ":" ~ "type"  }
regular_param = { identifier ~ ":" ~ type_expr  }
struct_decl = { "const" ~ identifier ~ "=" ~ "struct" ~ "{" ~
    field_decl* ~
    "}" ~ ";"
 }
field_decl = { identifier ~ ":" ~ type_expr ~ ","  }
enum_decl = { "const" ~ identifier ~ "=" ~ "enum" ~ ("(" ~ type_expr ~ ")")? ~ "{" ~
    enum_variant ~ ("," ~ enum_variant)* ~ ","? ~
    "}" ~ ";"
 }
enum_variant = { identifier ~ ("=" ~ expr)?  }
union_decl = { "const" ~ identifier ~ "=" ~ "union" ~ ("(" ~ "enum" ~ ")")? ~ "{" ~
    union_field ~ ("," ~ union_field)* ~ ","? ~
    "}" ~ ";"
 }
union_field = { identifier ~ ":" ~ type_expr  }
error_set_decl = { "const" ~ identifier ~ "=" ~ "error" ~ "{" ~
    identifier ~ ("," ~ identifier)* ~ ","? ~
    "}" ~ ";"
 }
type_expr = { primitive_type
  | identifier
  | array_type
  | pointer_type
  | optional_type
  | error_union_type
 }
primitive_type = { "i8" | "i16" | "i32" | "i64" | "i128"
  | "u8" | "u16" | "u32" | "u64" | "u128"
  | "f32" | "f64"
  | "bool"
  | "void"
 }
array_type = { "[" ~ integer_literal? ~ "]" ~ type_expr  }
pointer_type = { "*" ~ type_expr  }
optional_type = { "?" ~ type_expr  }
error_union_type = { "!" ~ type_expr  }
statement = { const_decl
  | var_decl
  | assignment
  | if_stmt
  | while_stmt
  | for_stmt
  | break_stmt
  | continue_stmt
  | return_stmt
  | defer_stmt
  | errdefer_stmt
  | expr_stmt
 }
defer_stmt = { "defer" ~ (block | expr_stmt)  }
errdefer_stmt = { "errdefer" ~ (block | expr_stmt)  }
assignment = { assign_target ~ assign_op ~ expr ~ ";"  }
assign_target = { identifier ~ ("[" ~ expr ~ "]")*  }
assign_op = { "<<=" | ">>=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "="  }
return_stmt = { "return" ~ expr? ~ ";"  }
expr_stmt = { expr ~ ";"  }
if_stmt = { if_let_stmt
  | if_regular_stmt
 }
if_let_stmt = { "if" ~ "(" ~ "let" ~ pattern ~ "=" ~ expr ~ ")" ~ block ~
    ("else" ~ block)?
 }
if_regular_stmt = { "if" ~ "(" ~ expr ~ ")" ~ block ~
    ("else" ~ block)?
 }
while_stmt = { "while" ~ "(" ~ expr ~ ")" ~ block
 }
for_stmt = { "for" ~ "(" ~ identifier ~ "in" ~ expr ~ ")" ~ block
 }
break_stmt = { "break" ~ ";"  }
continue_stmt = { "continue" ~ ";"  }
block = { "{" ~ statement* ~ "}"  }
expr = { orelse_expr  }
orelse_expr = { catch_expr ~ (orelse_op ~ catch_expr)*  }
catch_expr = { logical_or ~ (catch_op ~ logical_or)*  }
logical_or = { logical_and ~ (log_or_op ~ logical_and)*  }
logical_and = { equality ~ (log_and_op ~ equality)*  }
equality = { comparison ~ (eq_op ~ comparison)*  }
comparison = { bitwise_or ~ (cmp_op ~ bitwise_or)*  }
bitwise_or = { bitwise_xor ~ (bit_or_op ~ bitwise_xor)*  }
bitwise_xor = { bitwise_and ~ (bit_xor_op ~ bitwise_and)*  }
bitwise_and = { bit_shift ~ (bit_and_op ~ bit_shift)*  }
bit_shift = { addition ~ (shift_op ~ addition)*  }
addition = { multiplication ~ (add_op ~ multiplication)*  }
multiplication = { unary ~ (mul_op ~ unary)*  }
unary = { unary_op ~ unary
  | postfix
 }
postfix = { primary ~ postfix_op*
 }
postfix_op = { ".*"
  | "." ~ identifier
  | "[" ~ expr ~ "]"
  | "(" ~ args? ~ ")"
 }
args = { expr ~ ("," ~ expr)*  }
primary = { literal
  | struct_literal
  | switch_expr
  | try_expr
  | lambda_expr
  | "(" ~ expr ~ ")"
  | identifier
 }
lambda_expr = { "|" ~ lambda_params? ~ "|" ~ (block | expr)
 }
lambda_params = { lambda_param ~ ("," ~ lambda_param)*  }
lambda_param = { identifier ~ (":" ~ type_expr)?  }
try_expr = { "try" ~ postfix  }
switch_expr = { "switch" ~ "(" ~ expr ~ ")" ~ "{" ~
    switch_case ~ ("," ~ switch_case)* ~ ","? ~
    "}"
 }
switch_case = { switch_pattern ~ "=>" ~ expr
 }
switch_pattern = { integer_literal
  | switch_else
  | identifier
 }
switch_else = { "else"  }
literal = { bool_literal
  | null_literal
  | undefined_literal
  | float_literal     // Must be before integer_literal (3.14 vs 3)
  | integer_literal
  | string_literal
  | array_literal
 }
null_literal = { "null"  }
undefined_literal = { "undefined"  }
bool_literal = { "true" | "false"  }
integer_literal = @{ "-"? ~ ASCII_DIGIT+  }
float_literal = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+  }
string_literal = { "\"" ~ string_inner ~ "\""  }
string_inner = @{ (!("\"" | "\\") ~ ANY)*  }
array_literal = { "[" ~ "_" ~ "]" ~ type_expr ~ "{" ~ (expr ~ ("," ~ expr)*)? ~ "}"  }
struct_literal = { identifier ~ "{" ~ struct_field_init? ~ ("," ~ struct_field_init)* ~ ","? ~ "}"
 }
struct_field_init = { "." ~ identifier ~ "=" ~ expr  }
pattern = { wildcard_pattern
  | identifier_pattern
  | literal_pattern
  | enum_pattern
 }
wildcard_pattern = { "_"  }
identifier_pattern = { ("mut" ~ identifier) | identifier  }
literal_pattern = { literal  }
enum_pattern = { identifier ~ "(" ~ pattern ~ ")"
 }
identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")*  }
orelse_op = { "orelse"  }
catch_op = { "catch"  }
log_or_op = { "or"  }
log_and_op = { "and"  }
cmp_op = { "<=" | ">=" | "<" | ">"  }
eq_op = { "==" | "!="  }
bit_or_op = { "|"  }
bit_xor_op = { "^"  }
bit_and_op = { "&"  }
shift_op = { "<<" | ">>"  }
add_op = { "+" | "-"  }
mul_op = { "*" | "/" | "%"  }
unary_op = { "-" | "!" | "~" | "&"  }
WHITESPACE = _{ " " | "\t" | "\n" | "\r"  }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n"?  }