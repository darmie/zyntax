//! ZynPEG Integration Test
//!
//! This crate tests that ZynPEG-generated code can:
//! 1. Parse Zig code using the generated pest grammar
//! 2. Use generated TypedAST types to build typed programs
//!
//! The pest grammar and typed_ast types are generated by ZynPEG.
//! Once the ast_builder generator is complete, parse_to_typed_ast will work automatically.

use pest_derive::Parser;

// Load the generated pest grammar (path relative to src/)
#[derive(Parser)]
#[grammar = "../../generated/zig.pest"]
pub struct ZigParser;

// Include generated TypedAST types (path relative to src/)
#[path = "../../generated/typed_ast.rs"]
pub mod typed_ast;

// Re-export core types for convenience
pub use typed_ast::*;

// Include generated AST builder
#[path = "../../generated/ast_builder.rs"]
pub mod ast_builder;

// Include generated parser implementation
#[path = "../../generated/parser_impl.rs"]
pub mod parser_impl;

// Re-export the main parse function
pub use parser_impl::parse_to_typed_ast;

#[cfg(test)]
mod tests {
    use super::*;
    use pest::Parser;

    #[test]
    fn test_grammar_parses_const() {
        let input = "const x: i32 = 42;";
        let result = ZigParser::parse(Rule::const_decl, input);
        assert!(result.is_ok(), "Failed to parse: {:?}", result.err());
        println!("✓ Grammar parsed const decl");
    }

    #[test]
    fn test_grammar_parses_function() {
        let input = "fn add(a: i32, b: i32) i32 { return a; }";
        let result = ZigParser::parse(Rule::fn_decl, input);
        assert!(result.is_ok(), "Failed to parse: {:?}", result.err());
        println!("✓ Grammar parsed function");
    }

    #[test]
    fn test_grammar_parses_struct() {
        let input = "const Point = struct { x: i32, y: i32, };";
        let result = ZigParser::parse(Rule::struct_decl, input);
        assert!(result.is_ok(), "Failed to parse: {:?}", result.err());
        println!("✓ Grammar parsed struct");
    }

    #[test]
    fn test_grammar_parses_program() {
        let input = r#"
const PI: f64 = 3.14159;
const answer: i32 = 42;

fn double(x: i32) i32 {
    return x;
}

const Point = struct {
    x: i32,
    y: i32,
};
"#;
        let result = ZigParser::parse(Rule::program, input);
        assert!(result.is_ok(), "Failed to parse: {:?}", result.err());

        let pairs = result.unwrap();
        let count = pairs.flatten().count();
        println!("✓ Grammar parsed full program with {} nodes", count);
    }

    #[test]
    fn test_typed_ast_types_work() {
        // Test Span
        let span = Span::new(0, 10);
        assert_eq!(span.start, 0);
        assert_eq!(span.end, 10);

        // Test Type variants
        let ty = Type::I32;
        assert_eq!(ty, Type::I32);

        let arr_ty = Type::Array(Box::new(Type::I32), Some(10));
        assert_eq!(arr_ty.element_type(), Type::I32);

        // Test TypedExpression
        let expr = TypedExpression::default();
        assert_eq!(expr.ty, Type::Unknown);

        // Test TypedProgram
        let program = TypedProgram::default();
        assert!(program.declarations.is_empty());

        // Test helper functions
        let parsed = typed_ast::parse_int("42");
        assert_eq!(parsed, 42);

        println!("✓ TypedAST types work correctly");
    }

    /// Test building TypedProgram from parse tree using generated types
    ///
    /// This demonstrates the integration test pattern:
    /// 1. Parse with generated pest grammar
    /// 2. Build TypedAST using generated typed_ast types
    /// 3. Once ast_builder is fully working, this manual code will be replaced
    ///    with a simple call to parse_to_typed_ast::<ZigParser>(input)
    #[test]
    fn test_build_typed_program_from_parse_tree() {
        let input = "const x: i32 = 42;";
        let pairs = ZigParser::parse(Rule::program, input).unwrap();

        // Build TypedProgram manually using generated typed_ast types
        let mut program = TypedProgram::default();

        for pair in pairs {
            if pair.as_rule() == Rule::program {
                for inner in pair.into_inner() {
                    if inner.as_rule() == Rule::declaration {
                        if let Some(decl_inner) = inner.into_inner().next() {
                            if decl_inner.as_rule() == Rule::const_decl {
                                let span = Span::new(
                                    decl_inner.as_span().start(),
                                    decl_inner.as_span().end()
                                );

                                let mut children = decl_inner.into_inner().peekable();

                                // Get identifier
                                let name = children.next().unwrap().as_str().to_string();

                                // Get type if present
                                let mut ty = Type::Unknown;
                                if let Some(next) = children.peek() {
                                    if next.as_rule() == Rule::type_expr {
                                        let type_str = children.next().unwrap().as_str();
                                        ty = match type_str {
                                            "i32" => Type::I32,
                                            "i64" => Type::I64,
                                            "f32" => Type::F32,
                                            "f64" => Type::F64,
                                            "bool" => Type::Bool,
                                            _ => Type::Named(type_str.to_string()),
                                        };
                                    }
                                }

                                // Get expression
                                let expr_pair = children.next().unwrap();
                                let expr_text = expr_pair.as_str().trim();
                                let value = if let Ok(n) = expr_text.parse::<i64>() {
                                    TypedExpression {
                                        expr: Expression::IntLiteral(n),
                                        ty: Type::I64,
                                        span: Span::new(
                                            expr_pair.as_span().start(),
                                            expr_pair.as_span().end()
                                        ),
                                    }
                                } else {
                                    TypedExpression::default()
                                };

                                program.declarations.push(TypedDeclaration {
                                    decl: Declaration::Const(ConstDecl {
                                        name,
                                        ty: Some(ty),
                                        value,
                                        is_pub: false,
                                    }),
                                    span,
                                });
                            }
                        }
                    }
                }
            }
        }

        // Verify the built program
        assert_eq!(program.declarations.len(), 1);

        if let Declaration::Const(c) = &program.declarations[0].decl {
            assert_eq!(c.name, "x");
            assert_eq!(c.ty, Some(Type::I32));
            if let Expression::IntLiteral(n) = &c.value.expr {
                assert_eq!(*n, 42);
                println!("✓ Built TypedProgram: const {} : {:?} = {}", c.name, c.ty, n);
            }
        }
    }

    /// Test that parse tree traversal correctly handles nested structures
    #[test]
    fn test_build_typed_function() {
        let input = "fn double(x: i32) i32 { return x; }";
        let pairs = ZigParser::parse(Rule::fn_decl, input).unwrap();

        for pair in pairs {
            if pair.as_rule() == Rule::fn_decl {
                let span = Span::from_pest(pair.as_span());
                let mut children = pair.into_inner();

                // Get function name
                let name = children.next().unwrap().as_str().to_string();
                assert_eq!(name, "double");

                println!("✓ Parsed function '{}' with span {:?}", name, span);
            }
        }
    }

    // =========================================================================
    // CRITICAL: Tests using the generated parse_to_typed_ast function
    // =========================================================================
    // These tests demonstrate that ZynPEG's generated code works end-to-end.
    // The user can call parse_to_typed_ast::<ZigParser>(input) and get back
    // a fully typed AST with minimal boilerplate.

    /// Test parse_to_typed_ast for a simple const declaration
    #[test]
    fn test_parse_to_typed_ast_const() {
        let input = "const x: i32 = 42;";
        let result = parse_to_typed_ast::<ZigParser>(input);
        assert!(result.is_ok(), "parse_to_typed_ast failed: {:?}", result.err());

        let program = result.unwrap();
        assert_eq!(program.declarations.len(), 1);

        if let Declaration::Const(c) = &program.declarations[0].decl {
            assert_eq!(c.name, "x");
            assert_eq!(c.ty, Some(Type::I32));
            if let Expression::IntLiteral(n) = &c.value.expr {
                assert_eq!(*n, 42);
            } else {
                panic!("Expected IntLiteral, got {:?}", c.value.expr);
            }
            println!("✓ parse_to_typed_ast: const {} : {:?} = {:?}", c.name, c.ty, c.value.expr);
        } else {
            panic!("Expected Const declaration, got {:?}", program.declarations[0].decl);
        }
    }

    /// Test parse_to_typed_ast for a function declaration
    #[test]
    fn test_parse_to_typed_ast_function() {
        let input = "fn add(a: i32, b: i32) i32 { return a; }";
        let result = parse_to_typed_ast::<ZigParser>(input);
        assert!(result.is_ok(), "parse_to_typed_ast failed: {:?}", result.err());

        let program = result.unwrap();
        assert_eq!(program.declarations.len(), 1);

        if let Declaration::Function(f) = &program.declarations[0].decl {
            assert_eq!(f.name, "add");
            assert_eq!(f.params.len(), 2);
            assert_eq!(f.params[0].name, "a");
            assert_eq!(f.params[0].ty, Type::I32);
            assert_eq!(f.params[1].name, "b");
            assert_eq!(f.params[1].ty, Type::I32);
            assert_eq!(f.return_type, Type::I32);
            assert!(f.body.is_some());
            println!("✓ parse_to_typed_ast: fn {}({:?}) {:?}", f.name, f.params, f.return_type);
        } else {
            panic!("Expected Function declaration, got {:?}", program.declarations[0].decl);
        }
    }

    /// Test parse_to_typed_ast for a struct declaration
    #[test]
    fn test_parse_to_typed_ast_struct() {
        let input = "const Point = struct { x: i32, y: i32, };";
        let result = parse_to_typed_ast::<ZigParser>(input);
        assert!(result.is_ok(), "parse_to_typed_ast failed: {:?}", result.err());

        let program = result.unwrap();
        assert_eq!(program.declarations.len(), 1);

        if let Declaration::Struct(s) = &program.declarations[0].decl {
            assert_eq!(s.name, "Point");
            assert_eq!(s.fields.len(), 2);
            assert_eq!(s.fields[0].name, "x");
            assert_eq!(s.fields[0].ty, Type::I32);
            assert_eq!(s.fields[1].name, "y");
            assert_eq!(s.fields[1].ty, Type::I32);
            println!("✓ parse_to_typed_ast: struct {} {{ {:?} }}", s.name, s.fields);
        } else {
            panic!("Expected Struct declaration, got {:?}", program.declarations[0].decl);
        }
    }

    /// Test parse_to_typed_ast for a complete program
    #[test]
    fn test_parse_to_typed_ast_full_program() {
        let input = r#"
const PI: f64 = 3.14159;
const answer: i32 = 42;

fn double(x: i32) i32 {
    return x;
}

const Point = struct {
    x: i32,
    y: i32,
};
"#;
        let result = parse_to_typed_ast::<ZigParser>(input);
        assert!(result.is_ok(), "parse_to_typed_ast failed: {:?}", result.err());

        let program = result.unwrap();
        assert_eq!(program.declarations.len(), 4);

        // Verify first declaration is const PI
        if let Declaration::Const(c) = &program.declarations[0].decl {
            assert_eq!(c.name, "PI");
            assert_eq!(c.ty, Some(Type::F64));
        }

        // Verify second declaration is const answer
        if let Declaration::Const(c) = &program.declarations[1].decl {
            assert_eq!(c.name, "answer");
            assert_eq!(c.ty, Some(Type::I32));
        }

        // Verify third declaration is fn double
        if let Declaration::Function(f) = &program.declarations[2].decl {
            assert_eq!(f.name, "double");
            assert_eq!(f.params.len(), 1);
        }

        // Verify fourth declaration is struct Point
        if let Declaration::Struct(s) = &program.declarations[3].decl {
            assert_eq!(s.name, "Point");
            assert_eq!(s.fields.len(), 2);
        }

        println!("✓ parse_to_typed_ast: full program with {} declarations", program.declarations.len());
    }

    /// Test parse_to_typed_ast for var declaration
    #[test]
    fn test_parse_to_typed_ast_var() {
        let input = "var counter: i32 = 0;";
        let result = parse_to_typed_ast::<ZigParser>(input);
        assert!(result.is_ok(), "parse_to_typed_ast failed: {:?}", result.err());

        let program = result.unwrap();
        assert_eq!(program.declarations.len(), 1);

        if let Declaration::Var(v) = &program.declarations[0].decl {
            assert_eq!(v.name, "counter");
            assert_eq!(v.ty, Some(Type::I32));
            println!("✓ parse_to_typed_ast: var {} : {:?}", v.name, v.ty);
        } else {
            panic!("Expected Var declaration, got {:?}", program.declarations[0].decl);
        }
    }
}
