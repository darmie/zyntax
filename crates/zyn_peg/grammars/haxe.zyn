// ===================================================================
// Haxe Grammar for Zyn Runtime
// ===================================================================
//
// Minimal Haxe subset supporting:
// - Classes with instance/static methods
// - Basic types and generics
// - Imports (parsed, resolution TBD)
//
// ===================================================================

@language {
    name: "Haxe",
    version: "4.0",
    file_extensions: [".hx"],
    entry_point: "main",
}

// Built-in functions provided by the runtime
// Maps function names to runtime symbols
@builtin {
    // trace(value) - Haxe's standard debug output
    // Note: Type-specific variants ($haxe$trace$int, $haxe$trace$float, etc.)
    // are resolved at compile time based on argument type
    trace: "$haxe$trace$int",
}

// ===== Program Structure =====

program = { SOI ~ package_decl? ~ import_decls ~ class_decl* ~ EOI }
  -> TypedProgram {
      "get_all_children": true,
      "define": "program",
      "args": { "declarations": "$result" }
  }

// ===== Package Declaration =====

package_decl = { "package" ~ module_path ~ ";" }
  -> TypedDeclaration {
      "commands": [
          { "define": "package", "args": { "path": "$1" } }
      ]
  }

// ===== Import Declarations =====

import_decls = { import_decl* }
  -> List {
      "get_all_children": true
  }

import_decl = { "import" ~ module_path ~ ";" }
  -> TypedDeclaration {
      "commands": [
          { "define": "import", "args": { "path": "$1" } }
      ]
  }

module_path = { identifier ~ ("." ~ identifier)* }
  -> String {
      "get_text": true
  }

// ===== Class Declaration =====
// Split to handle optional type_params correctly

class_decl = { class_with_type_params | class_without_type_params }
  -> TypedDeclaration {
      "get_child": { "index": 0 }
  }

// Class with generic type parameters: class Foo<T> { ... }
class_with_type_params = { "class" ~ identifier ~ type_params ~ "{" ~ class_members ~ "}" }
  -> TypedDeclaration {
      "commands": [
          { "define": "class", "args": {
              "name": "$1",
              "type_params": "$2",
              "members": "$3"
          }}
      ]
  }

// Class without generic type parameters: class Foo { ... }
class_without_type_params = { "class" ~ identifier ~ "{" ~ class_members ~ "}" }
  -> TypedDeclaration {
      "commands": [
          { "define": "class", "args": {
              "name": "$1",
              "type_params": [],
              "members": "$2"
          }}
      ]
  }

// Collect all class members into a list
class_members = { class_member* }
  -> List {
      "get_all_children": true
  }

type_params = { "<" ~ type_param ~ ("," ~ type_param)* ~ ">" }
  -> List {
      "get_all_children": true
  }

type_param = { identifier }
  -> String {
      "get_text": true
  }

// ===== Class Members =====

class_member = { field_decl | method_decl }
  -> TypedDeclaration {
      "get_child": { "index": 0 }
  }

// Field: public var name:Type;
field_decl = { visibility? ~ "var" ~ identifier ~ ":" ~ type_expr ~ ";" }
  -> TypedDeclaration {
      "commands": [
          { "define": "field", "args": {
              "visibility": "$1",
              "name": "$2",
              "type": "$3"
          }}
      ]
  }

// Method: public static function name(params):ReturnType { body }
// Note: method_name allows "new" for constructors
// Split into variants to handle optionals properly (pest doesn't create placeholder children)
// Each variant has fixed child positions.

method_decl = { method_ps_pr | method_ps_np | method_ps_nr | method_ps_nn
              | method_p_pr | method_p_np | method_p_nr | method_p_nn
              | method_s_pr | method_s_np | method_s_nr | method_s_nn
              | method_b_pr | method_b_np | method_b_nr | method_b_nn }
  -> TypedDeclaration {
      "get_child": { "index": 0 }
  }

// ps = public static, p = public, s = static, b = bare
// pr = params+return, np = no params+return, nr = params+no return, nn = no params+no return

// public static function with params and return type
method_ps_pr = { "public" ~ "static" ~ "function" ~ method_name ~ "(" ~ param_list ~ ")" ~ ":" ~ type_expr ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "method", "args": {
              "visibility": "public", "is_static": true,
              "name": "$1", "params": "$2", "return_type": "$3", "body": "$4"
          }}
      ]
  }

// public static function with no params but with return type
method_ps_np = { "public" ~ "static" ~ "function" ~ method_name ~ "(" ~ ")" ~ ":" ~ type_expr ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "method", "args": {
              "visibility": "public", "is_static": true,
              "name": "$1", "params": [], "return_type": "$2", "body": "$3"
          }}
      ]
  }

// public static function with params but no return type
method_ps_nr = { "public" ~ "static" ~ "function" ~ method_name ~ "(" ~ param_list ~ ")" ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "method", "args": {
              "visibility": "public", "is_static": true,
              "name": "$1", "params": "$2", "body": "$3"
          }}
      ]
  }

// public static function with no params and no return type
method_ps_nn = { "public" ~ "static" ~ "function" ~ method_name ~ "(" ~ ")" ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "method", "args": {
              "visibility": "public", "is_static": true,
              "name": "$1", "params": [], "body": "$2"
          }}
      ]
  }

// public function with params and return type
method_p_pr = { "public" ~ "function" ~ method_name ~ "(" ~ param_list ~ ")" ~ ":" ~ type_expr ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "method", "args": {
              "visibility": "public", "is_static": false,
              "name": "$1", "params": "$2", "return_type": "$3", "body": "$4"
          }}
      ]
  }

// public function with no params but with return type
method_p_np = { "public" ~ "function" ~ method_name ~ "(" ~ ")" ~ ":" ~ type_expr ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "method", "args": {
              "visibility": "public", "is_static": false,
              "name": "$1", "params": [], "return_type": "$2", "body": "$3"
          }}
      ]
  }

// public function with params but no return type
method_p_nr = { "public" ~ "function" ~ method_name ~ "(" ~ param_list ~ ")" ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "method", "args": {
              "visibility": "public", "is_static": false,
              "name": "$1", "params": "$2", "body": "$3"
          }}
      ]
  }

// public function with no params and no return type
method_p_nn = { "public" ~ "function" ~ method_name ~ "(" ~ ")" ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "method", "args": {
              "visibility": "public", "is_static": false,
              "name": "$1", "params": [], "body": "$2"
          }}
      ]
  }

// static function with params and return type
method_s_pr = { "static" ~ "function" ~ method_name ~ "(" ~ param_list ~ ")" ~ ":" ~ type_expr ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "method", "args": {
              "visibility": "private", "is_static": true,
              "name": "$1", "params": "$2", "return_type": "$3", "body": "$4"
          }}
      ]
  }

// static function with no params but with return type
method_s_np = { "static" ~ "function" ~ method_name ~ "(" ~ ")" ~ ":" ~ type_expr ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "method", "args": {
              "visibility": "private", "is_static": true,
              "name": "$1", "params": [], "return_type": "$2", "body": "$3"
          }}
      ]
  }

// static function with params but no return type
method_s_nr = { "static" ~ "function" ~ method_name ~ "(" ~ param_list ~ ")" ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "method", "args": {
              "visibility": "private", "is_static": true,
              "name": "$1", "params": "$2", "body": "$3"
          }}
      ]
  }

// static function with no params and no return type
method_s_nn = { "static" ~ "function" ~ method_name ~ "(" ~ ")" ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "method", "args": {
              "visibility": "private", "is_static": true,
              "name": "$1", "params": [], "body": "$2"
          }}
      ]
  }

// bare function with params and return type
method_b_pr = { "function" ~ method_name ~ "(" ~ param_list ~ ")" ~ ":" ~ type_expr ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "method", "args": {
              "visibility": "private", "is_static": false,
              "name": "$1", "params": "$2", "return_type": "$3", "body": "$4"
          }}
      ]
  }

// bare function with no params but with return type
method_b_np = { "function" ~ method_name ~ "(" ~ ")" ~ ":" ~ type_expr ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "method", "args": {
              "visibility": "private", "is_static": false,
              "name": "$1", "params": [], "return_type": "$2", "body": "$3"
          }}
      ]
  }

// bare function with params but no return type
method_b_nr = { "function" ~ method_name ~ "(" ~ param_list ~ ")" ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "method", "args": {
              "visibility": "private", "is_static": false,
              "name": "$1", "params": "$2", "body": "$3"
          }}
      ]
  }

// bare function with no params and no return type
method_b_nn = { "function" ~ method_name ~ "(" ~ ")" ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "method", "args": {
              "visibility": "private", "is_static": false,
              "name": "$1", "params": [], "body": "$2"
          }}
      ]
  }

// Method name allows "new" for constructors
method_name = @{ "new" | (!keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")*) }
  -> String {
      "get_text": true
  }

visibility = { "public" | "private" }
  -> String {
      "get_text": true
  }

param_list = { param ~ ("," ~ param)* }
  -> List {
      "get_all_children": true
  }

param = { identifier ~ ":" ~ type_expr }
  -> TypedParameter {
      "commands": [
          { "define": "param", "args": { "name": "$1", "type": "$2" } }
      ]
  }

// ===== Type Expressions =====

// Function types use right-associative arrow: T -> U -> V means T -> (U -> V)
type_expr = { primary_type ~ ("->" ~ primary_type)* }
  -> Type {
      "fold_binary": { "operand": "primary_type", "operator": "arrow_op" }
  }

// Primary type (non-function types)
primary_type = { generic_type | array_type | nullable_type | paren_type | simple_type }
  -> Type {
      "get_child": { "index": 0 }
  }

// Parenthesized type for grouping: (T -> U)
paren_type = _{ "(" ~ type_expr ~ ")" }

// Generic type: Map<String, Int>
generic_type = { identifier ~ "<" ~ type_expr ~ ("," ~ type_expr)* ~ ">" }
  -> Type {
      "commands": [
          { "define": "generic_type", "args": {
              "name": "$1",
              "params": { "get_all_children": true }
          }}
      ]
  }

// Array type: Array<T>
array_type = { "Array" ~ "<" ~ type_expr ~ ">" }
  -> Type {
      "commands": [
          { "define": "array_type", "args": { "element": "$1" } }
      ]
  }

// Nullable type: Null<T>
nullable_type = { "Null" ~ "<" ~ type_expr ~ ">" }
  -> Type {
      "commands": [
          { "define": "nullable_type", "args": { "inner": "$1" } }
      ]
  }

simple_type = { "Int" | "Float" | "Bool" | "String" | "Void" | identifier }
  -> Type {
      "get_text": true,
      "define": "primitive_type",
      "args": { "name": "$result" }
  }

arrow_op = { "->" }
  -> String { "get_text": true }

// ===== Statements =====

statement = { var_stmt | if_stmt | while_stmt | for_stmt | return_stmt | assign_stmt | expr_stmt }
  -> TypedStatement {
      "get_child": { "index": 0 }
  }

// Assignment statement: target = value;
// Simple identifier assignment for now
assign_stmt = { identifier ~ "=" ~ expr ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "assignment", "args": {
              "target": "$1",
              "value": "$2"
          }}
      ]
  }

var_stmt = { var_stmt_typed | var_stmt_inferred }
  -> TypedStatement {
      "get_child": { "index": 0 }
  }

var_stmt_typed = { "var" ~ identifier ~ ":" ~ type_expr ~ "=" ~ expr ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "var_stmt", "args": {
              "name": "$1",
              "type": "$2",
              "init": "$3"
          }}
      ]
  }

var_stmt_inferred = { "var" ~ identifier ~ "=" ~ expr ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "var_stmt", "args": {
              "name": "$1",
              "init": "$2"
          }}
      ]
  }

if_stmt = { if_else | if_only }
  -> TypedStatement { "get_child": { "index": 0 } }

if_only = { "if" ~ "(" ~ expr ~ ")" ~ block }
  -> TypedStatement {
      "commands": [
          { "define": "if", "args": {
              "condition": "$1",
              "then_branch": "$2"
          }}
      ]
  }

if_else = { "if" ~ "(" ~ expr ~ ")" ~ block ~ "else" ~ block }
  -> TypedStatement {
      "commands": [
          { "define": "if", "args": {
              "condition": "$1",
              "then_branch": "$2",
              "else_branch": "$3"
          }}
      ]
  }

while_stmt = { "while" ~ "(" ~ expr ~ ")" ~ block }
  -> TypedStatement {
      "commands": [
          { "define": "while", "args": {
              "condition": "$1",
              "body": "$2"
          }}
      ]
  }

// Haxe for loop: for (i in 0...10) { }
for_stmt = { "for" ~ "(" ~ identifier ~ "in" ~ expr ~ ")" ~ block }
  -> TypedStatement {
      "commands": [
          { "define": "for", "args": {
              "binding": "$1",
              "iterable": "$2",
              "body": "$3"
          }}
      ]
  }

return_stmt = { return_with_value | return_void }
  -> TypedStatement {
      "get_child": { "index": 0 }
  }

return_with_value = { "return" ~ expr ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "return_stmt", "args": { "value": "$1" } }
      ]
  }

return_void = { "return" ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "return_stmt", "args": { } }
      ]
  }

expr_stmt = { expr ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "expression_stmt", "args": { "expr": "$1" } }
      ]
  }

block = { "{" ~ statement* ~ "}" }
  -> TypedBlock {
      "get_all_children": true,
      "define": "block",
      "args": { "statements": "$result" }
  }

// ===== Expressions =====

// Assignment has lowest precedence
expr = { assignment | logical_or }
  -> TypedExpression {
      "get_child": { "index": 0 }
  }

// Assignment: target = value (right associative)
assignment = { postfix ~ assign_op ~ expr }
  -> TypedExpression {
      "commands": [
          { "define": "assignment", "args": {
              "target": "$1",
              "op": "$2",
              "value": "$3"
          }}
      ]
  }

assign_op = { "=" }
  -> String { "get_text": true }

logical_or = { logical_and ~ ("||" ~ logical_and)* }
  -> TypedExpression {
      "fold_binary": { "operand": "logical_and", "operator": "or_op" }
  }

logical_and = { comparison ~ ("&&" ~ comparison)* }
  -> TypedExpression {
      "fold_binary": { "operand": "comparison", "operator": "and_op" }
  }

comparison = { addition ~ ((eq_op | neq_op | lte_op | gte_op | lt_op | gt_op) ~ addition)* }
  -> TypedExpression {
      "fold_binary": { "operand": "addition", "operator": "eq_op|neq_op|lte_op|gte_op|lt_op|gt_op" }
  }

addition = { multiplication ~ ((add_op | sub_op) ~ multiplication)* }
  -> TypedExpression {
      "fold_binary": { "operand": "multiplication", "operator": "add_op|sub_op" }
  }

multiplication = { unary ~ ((mul_op | div_op | mod_op) ~ unary)* }
  -> TypedExpression {
      "fold_binary": { "operand": "unary", "operator": "mul_op|div_op|mod_op" }
  }

unary = { unary_with_op | postfix }
  -> TypedExpression {
      "get_child": { "index": 0 }
  }

unary_with_op = { unary_op ~ postfix }
  -> TypedExpression {
      "commands": [
          { "define": "unary", "args": { "op": "$1", "operand": "$2" } }
      ]
  }

// Postfix: calls, field access, array index
postfix = { primary ~ postfix_op* }
  -> TypedExpression {
      "fold_postfix": true
  }

postfix_op = { call_op | field_op | index_op }
  -> TypedExpression {
      "get_child": { "index": 0 }
  }

call_op = { "(" ~ call_args? ~ ")" }
  -> TypedExpression {
      "commands": [
          { "define": "call_postfix", "args": { "args": "$1" } }
      ]
  }

field_op = { "." ~ identifier }
  -> TypedExpression {
      "commands": [
          { "define": "field_postfix", "args": { "field": "$1" } }
      ]
  }

index_op = { "[" ~ expr ~ "]" }
  -> TypedExpression {
      "commands": [
          { "define": "index_postfix", "args": { "index": "$1" } }
      ]
  }

call_args = { expr ~ ("," ~ expr)* }
  -> List {
      "get_all_children": true
  }

primary = { new_expr | range_expr | array_literal | bool_literal | string_literal | integer_literal | float_literal | this_expr | identifier_expr | paren_expr }
  -> TypedExpression {
      "get_child": { "index": 0 }
  }

// new ClassName(args)
new_expr = { "new" ~ identifier ~ type_args? ~ "(" ~ call_args? ~ ")" }
  -> TypedExpression {
      "commands": [
          { "define": "new_expr", "args": {
              "class_name": "$1",
              "type_args": "$2",
              "args": "$3"
          }}
      ]
  }

type_args = { "<" ~ type_expr ~ ("," ~ type_expr)* ~ ">" }
  -> List {
      "get_all_children": true
  }

// Range: 0...10
range_expr = { integer_literal ~ "..." ~ integer_literal }
  -> TypedExpression {
      "commands": [
          { "define": "range", "args": {
              "start": "$1",
              "end": "$2"
          }}
      ]
  }

this_expr = { "this" }
  -> TypedExpression {
      "commands": [
          { "define": "this" }
      ]
  }

array_literal = { "[" ~ array_elements? ~ "]" }
  -> TypedExpression {
      "commands": [
          { "define": "array_literal", "args": { "elements": "$1" } }
      ]
  }

array_elements = { expr ~ ("," ~ expr)* }
  -> List {
      "get_all_children": true
  }

paren_expr = _{ "(" ~ expr ~ ")" }

identifier_expr = { identifier }
  -> TypedExpression {
      "get_text": true,
      "define": "variable",
      "args": { "name": "$result" }
  }

// ===== Literals =====

bool_literal = { "true" | "false" }
  -> TypedExpression {
      "get_text": true,
      "define": "bool_literal",
      "args": { "value": "$result" }
  }

integer_literal = @{ "-"? ~ ASCII_DIGIT+ }
  -> TypedExpression {
      "get_text": true,
      "parse_int": true,
      "define": "int_literal",
      "args": { "value": "$result" }
  }

float_literal = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
  -> TypedExpression {
      "get_text": true,
      "define": "float_literal",
      "args": { "value": "$result" }
  }

string_literal = @{ "\"" ~ string_inner* ~ "\"" }
  -> TypedExpression {
      "get_text": true,
      "define": "string_literal",
      "args": { "value": "$result" }
  }

string_inner = { (!("\"" | "\\") ~ ANY) | escape_seq }

escape_seq = { "\\" ~ ("n" | "r" | "t" | "\\" | "\"" | "0") }

// ===== Identifiers =====

keyword = @{
    ("class" | "function" | "var" | "if" | "else" | "while" | "for" | "in" |
     "return" | "new" | "this" | "public" | "private" | "static" |
     "true" | "false" | "null" | "import" | "package" |
     "Int" | "Float" | "Bool" | "String" | "Void" | "Array" | "Null")
    ~ !(ASCII_ALPHANUMERIC | "_")
}

identifier = @{ !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
  -> String {
      "get_text": true
  }

// ===== Operators =====

or_op = { "||" }
  -> String { "get_text": true }

and_op = { "&&" }
  -> String { "get_text": true }

eq_op = { "==" }
  -> String { "get_text": true }

neq_op = { "!=" }
  -> String { "get_text": true }

lte_op = { "<=" }
  -> String { "get_text": true }

gte_op = { ">=" }
  -> String { "get_text": true }

lt_op = { "<" }
  -> String { "get_text": true }

gt_op = { ">" }
  -> String { "get_text": true }

add_op = { "+" }
  -> String { "get_text": true }

sub_op = { "-" }
  -> String { "get_text": true }

mul_op = { "*" }
  -> String { "get_text": true }

div_op = { "/" }
  -> String { "get_text": true }

mod_op = { "%" }
  -> String { "get_text": true }

unary_op = { "-" | "!" }
  -> String { "get_text": true }

// ===== Whitespace and Comments =====

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n"? | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
