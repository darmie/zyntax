// ===================================================================
// Zig Grammar with JSON Commands for Zyn Runtime
// ===================================================================
//
// This grammar uses JSON command blocks that work with the Zyn runtime
// interpreter to build TypedAST nodes at parse time.
//
// Usage:
//   zyntax compile --source file.zig --grammar zig.zyn --format zyn --run
//
// ===================================================================

@language {
    name: "Zig",
    version: "0.11",
    file_extensions: [".zig"],
    entry_point: "main",
}

// ===== Program Structure =====

program = { SOI ~ declaration* ~ EOI }
  -> TypedProgram {
      "commands": [
          { "define": "program", "args": { "declarations": "$1" } }
      ]
  }

declaration = { fn_decl | const_decl | var_decl }
  -> TypedDeclaration {
      "get_child": { "index": 0 }
  }

// ===== Function Declaration =====

// Split into two rules to handle the optional params correctly
// pest doesn't produce placeholder children for missing optionals

fn_decl = { fn_decl_with_params | fn_decl_no_params }
  -> TypedDeclaration {
      "get_child": { "index": 0 }
  }

// With params: identifier, fn_params, type_expr, block
fn_decl_with_params = { "fn" ~ identifier ~ "(" ~ fn_params ~ ")" ~ type_expr ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "function", "args": {
              "name": "$1",
              "params": "$2",
              "return_type": "$3",
              "body": "$4"
          }}
      ]
  }

// No params: identifier, type_expr, block (no fn_params child)
fn_decl_no_params = { "fn" ~ identifier ~ "(" ~ ")" ~ type_expr ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "function", "args": {
              "name": "$1",
              "params": [],
              "return_type": "$2",
              "body": "$3"
          }}
      ]
  }

fn_params = { fn_param ~ ("," ~ fn_param)* }
  -> List {
      "get_child": { "index": 0 }
  }

// Children (non-silent): identifier, type_expr
fn_param = { identifier ~ ":" ~ type_expr }
  -> TypedParameter {
      "commands": [
          { "define": "param", "args": { "name": "$1", "type": "$2" } }
      ]
  }

// ===== Variable Declarations =====
// Split into typed/untyped variants since pest doesn't produce placeholder children for missing optionals

const_decl = { const_decl_typed | const_decl_untyped }
  -> TypedDeclaration { "get_child": { "index": 0 } }

const_decl_typed = { "const" ~ identifier ~ ":" ~ type_expr ~ "=" ~ expr ~ ";" }
  -> TypedDeclaration {
      "commands": [
          { "define": "let_stmt", "args": {
              "name": "$1",
              "type": "$2",
              "init": "$3",
              "is_const": true
          }}
      ]
  }

const_decl_untyped = { "const" ~ identifier ~ "=" ~ expr ~ ";" }
  -> TypedDeclaration {
      "commands": [
          { "define": "let_stmt", "args": {
              "name": "$1",
              "init": "$2",
              "is_const": true
          }}
      ]
  }

var_decl = { var_decl_typed | var_decl_untyped }
  -> TypedDeclaration { "get_child": { "index": 0 } }

var_decl_typed = { "var" ~ identifier ~ ":" ~ type_expr ~ "=" ~ expr ~ ";" }
  -> TypedDeclaration {
      "commands": [
          { "define": "let_stmt", "args": {
              "name": "$1",
              "type": "$2",
              "init": "$3",
              "is_const": false
          }}
      ]
  }

var_decl_untyped = { "var" ~ identifier ~ "=" ~ expr ~ ";" }
  -> TypedDeclaration {
      "commands": [
          { "define": "let_stmt", "args": {
              "name": "$1",
              "init": "$2",
              "is_const": false
          }}
      ]
  }

// ===== Type Expressions =====

type_expr = { primitive_type | identifier }
  -> Type {
      "get_child": { "index": 0 }
  }

primitive_type = { "i8" | "i16" | "i32" | "i64" | "u8" | "u16" | "u32" | "u64" | "f32" | "f64" | "bool" | "void" }
  -> Type {
      "get_text": true,
      "define": "primitive_type",
      "args": { "name": "$result" }
  }

// ===== Statements =====

statement = { if_stmt | while_stmt | return_stmt | local_const | local_var | assign_stmt | expr_stmt }
  -> TypedStatement {
      "get_child": { "index": 0 }
  }

// If statement variants
if_stmt = { if_else | if_only }
  -> TypedStatement { "get_child": { "index": 0 } }

if_only = { "if" ~ "(" ~ expr ~ ")" ~ block }
  -> TypedStatement {
      "commands": [
          { "define": "if", "args": {
              "condition": "$1",
              "then_branch": "$2"
          }}
      ]
  }

if_else = { "if" ~ "(" ~ expr ~ ")" ~ block ~ "else" ~ block }
  -> TypedStatement {
      "commands": [
          { "define": "if", "args": {
              "condition": "$1",
              "then_branch": "$2",
              "else_branch": "$3"
          }}
      ]
  }

// While loop
while_stmt = { "while" ~ "(" ~ expr ~ ")" ~ block }
  -> TypedStatement {
      "commands": [
          { "define": "while", "args": {
              "condition": "$1",
              "body": "$2"
          }}
      ]
  }

// Assignment statement: identifier = expr;
assign_stmt = { identifier ~ "=" ~ expr ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "assignment", "args": {
              "target": "$1",
              "value": "$2"
          }}
      ]
  }

// Children (non-silent): expr?
return_stmt = { "return" ~ expr? ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "return_stmt", "args": { "value": "$1" } }
      ]
  }

// Split into typed/untyped variants
local_const = { local_const_typed | local_const_untyped }
  -> TypedStatement { "get_child": { "index": 0 } }

local_const_typed = { "const" ~ identifier ~ ":" ~ type_expr ~ "=" ~ expr ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "let_stmt", "args": {
              "name": "$1",
              "type": "$2",
              "init": "$3",
              "is_const": true
          }}
      ]
  }

local_const_untyped = { "const" ~ identifier ~ "=" ~ expr ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "let_stmt", "args": {
              "name": "$1",
              "init": "$2",
              "is_const": true
          }}
      ]
  }

local_var = { local_var_typed | local_var_untyped }
  -> TypedStatement { "get_child": { "index": 0 } }

local_var_typed = { "var" ~ identifier ~ ":" ~ type_expr ~ "=" ~ expr ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "let_stmt", "args": {
              "name": "$1",
              "type": "$2",
              "init": "$3",
              "is_const": false
          }}
      ]
  }

local_var_untyped = { "var" ~ identifier ~ "=" ~ expr ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "let_stmt", "args": {
              "name": "$1",
              "init": "$2",
              "is_const": false
          }}
      ]
  }

expr_stmt = { expr ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "expression_stmt", "args": { "expr": "$1" } }
      ]
  }

// Collect all statements using get_all_children
block = { "{" ~ statement* ~ "}" }
  -> TypedBlock {
      "get_all_children": true,
      "define": "block",
      "args": { "statements": "$result" }
  }

// ===== Expressions =====

expr = { comparison }
  -> TypedExpression {
      "get_child": { "index": 0 }
  }

// Comparison operators (lowest precedence)
comparison = { addition ~ ((eq_op | neq_op | lte_op | gte_op | lt_op | gt_op) ~ addition)* }
  -> TypedExpression {
      "fold_binary": { "operand": "addition", "operator": "eq_op|neq_op|lte_op|gte_op|lt_op|gt_op" }
  }

addition = { multiplication ~ ((add_op | sub_op) ~ multiplication)* }
  -> TypedExpression {
      "fold_binary": { "operand": "multiplication", "operator": "add_op|sub_op" }
  }

multiplication = { unary ~ ((mul_op | div_op) ~ unary)* }
  -> TypedExpression {
      "fold_binary": { "operand": "unary", "operator": "mul_op|div_op" }
  }

unary = { unary_op? ~ primary }
  -> TypedExpression {
      "get_child": { "index": 0 }
  }

primary = { bool_literal | integer_literal | call_expr | identifier_expr | paren_expr }
  -> TypedExpression {
      "get_child": { "index": 0 }
  }

paren_expr = _{ "(" ~ expr ~ ")" }

// Function call expression: identifier(args...)
call_expr = { identifier ~ "(" ~ call_args? ~ ")" }
  -> TypedExpression {
      "commands": [
          { "define": "call", "args": {
              "callee": "$1",
              "args": "$2"
          }}
      ]
  }

call_args = { expr ~ ("," ~ expr)* }
  -> List {
      "get_all_children": true
  }

identifier_expr = { identifier }
  -> TypedExpression {
      "get_text": true,
      "define": "variable",
      "args": { "name": "$result" }
  }

// ===== Literals =====

bool_literal = { "true" | "false" }
  -> TypedExpression {
      "get_text": true,
      "define": "bool_literal",
      "args": { "value": "$result" }
  }

integer_literal = @{ "-"? ~ ASCII_DIGIT+ }
  -> TypedExpression {
      "get_text": true,
      "parse_int": true,
      "define": "int_literal",
      "args": { "value": "$result" }
  }

// ===== Identifiers =====

identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
  -> String {
      "get_text": true
  }

// ===== Operators =====

// Comparison operators (must check longer operators first)
eq_op = { "==" }
  -> String { "get_text": true }

neq_op = { "!=" }
  -> String { "get_text": true }

lte_op = { "<=" }
  -> String { "get_text": true }

gte_op = { ">=" }
  -> String { "get_text": true }

lt_op = { "<" }
  -> String { "get_text": true }

gt_op = { ">" }
  -> String { "get_text": true }

// Arithmetic operators
add_op = { "+" }
  -> String { "get_text": true }

sub_op = { "-" }
  -> String { "get_text": true }

mul_op = { "*" }
  -> String { "get_text": true }

div_op = { "/" }
  -> String { "get_text": true }

unary_op = { "-" | "!" }
  -> String { "get_text": true }

// ===== Whitespace and Comments =====

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n"? }
