// ===================================================================
// Zig Grammar with JSON Commands for Zyn Runtime
// ===================================================================
//
// This grammar uses JSON command blocks that work with the Zyn runtime
// interpreter to build TypedAST nodes at parse time.
//
// Usage:
//   zyntax compile --source file.zig --grammar zig.zyn --format zyn --run
//
// ===================================================================

@language {
    name: "Zig",
    version: "0.11",
    file_extensions: [".zig"],
    entry_point: "main",
}

// ===== Program Structure =====

program = { SOI ~ declaration* ~ EOI }
  -> TypedProgram {
      "commands": [
          { "define": "program", "args": { "declarations": "$1" } }
      ]
  }

declaration = { struct_decl | enum_decl | fn_decl | const_decl | var_decl }
  -> TypedDeclaration {
      "get_child": { "index": 0 }
  }

// ===== Struct Declaration =====

struct_decl = { "const" ~ identifier ~ "=" ~ "struct" ~ "{" ~ struct_fields? ~ "}" ~ ";" }
  -> TypedDeclaration {
      "commands": [
          { "define": "struct", "args": {
              "name": "$1",
              "fields": "$2"
          }}
      ]
  }

struct_fields = { struct_field ~ ("," ~ struct_field)* ~ ","? }
  -> List {
      "get_all_children": true
  }

struct_field = { identifier ~ ":" ~ type_expr }
  -> TypedField {
      "commands": [
          { "define": "field", "args": { "name": "$1", "type": "$2" } }
      ]
  }

// ===== Enum Declaration =====

enum_decl = { "const" ~ identifier ~ "=" ~ "enum" ~ "{" ~ enum_variants? ~ "}" ~ ";" }
  -> TypedDeclaration {
      "commands": [
          { "define": "enum", "args": {
              "name": "$1",
              "variants": "$2"
          }}
      ]
  }

enum_variants = { enum_variant ~ ("," ~ enum_variant)* ~ ","? }
  -> List {
      "get_all_children": true
  }

enum_variant = { identifier }
  -> TypedVariant {
      "get_text": true,
      "define": "variant",
      "args": { "name": "$result" }
  }

// ===== Function Declaration =====

// Split into two rules to handle the optional params correctly
// pest doesn't produce placeholder children for missing optionals

fn_decl = { fn_decl_with_params | fn_decl_no_params }
  -> TypedDeclaration {
      "get_child": { "index": 0 }
  }

// With params: identifier, fn_params, type_expr, block
fn_decl_with_params = { "fn" ~ identifier ~ "(" ~ fn_params ~ ")" ~ type_expr ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "function", "args": {
              "name": "$1",
              "params": "$2",
              "return_type": "$3",
              "body": "$4"
          }}
      ]
  }

// No params: identifier, type_expr, block (no fn_params child)
fn_decl_no_params = { "fn" ~ identifier ~ "(" ~ ")" ~ type_expr ~ block }
  -> TypedDeclaration {
      "commands": [
          { "define": "function", "args": {
              "name": "$1",
              "params": [],
              "return_type": "$2",
              "body": "$3"
          }}
      ]
  }

fn_params = { fn_param ~ ("," ~ fn_param)* }
  -> List {
      "get_child": { "index": 0 }
  }

// Children (non-silent): identifier, type_expr
fn_param = { identifier ~ ":" ~ type_expr }
  -> TypedParameter {
      "commands": [
          { "define": "param", "args": { "name": "$1", "type": "$2" } }
      ]
  }

// ===== Variable Declarations =====
// Split into typed/untyped variants since pest doesn't produce placeholder children for missing optionals

const_decl = { const_decl_typed | const_decl_untyped }
  -> TypedDeclaration { "get_child": { "index": 0 } }

const_decl_typed = { "const" ~ identifier ~ ":" ~ type_expr ~ "=" ~ expr ~ ";" }
  -> TypedDeclaration {
      "commands": [
          { "define": "let_stmt", "args": {
              "name": "$1",
              "type": "$2",
              "init": "$3",
              "is_const": true
          }}
      ]
  }

const_decl_untyped = { "const" ~ identifier ~ "=" ~ expr ~ ";" }
  -> TypedDeclaration {
      "commands": [
          { "define": "let_stmt", "args": {
              "name": "$1",
              "init": "$2",
              "is_const": true
          }}
      ]
  }

var_decl = { var_decl_typed | var_decl_untyped }
  -> TypedDeclaration { "get_child": { "index": 0 } }

var_decl_typed = { "var" ~ identifier ~ ":" ~ type_expr ~ "=" ~ expr ~ ";" }
  -> TypedDeclaration {
      "commands": [
          { "define": "let_stmt", "args": {
              "name": "$1",
              "type": "$2",
              "init": "$3",
              "is_const": false
          }}
      ]
  }

var_decl_untyped = { "var" ~ identifier ~ "=" ~ expr ~ ";" }
  -> TypedDeclaration {
      "commands": [
          { "define": "let_stmt", "args": {
              "name": "$1",
              "init": "$2",
              "is_const": false
          }}
      ]
  }

// ===== Type Expressions =====

type_expr = { pointer_type | optional_type | error_union_type | array_type | primitive_type | identifier }
  -> Type {
      "get_child": { "index": 0 }
  }

// Pointer type: *T or *const T
pointer_type = { "*" ~ "const"? ~ type_expr }
  -> Type {
      "commands": [
          { "define": "pointer_type", "args": { "pointee": "$1" } }
      ]
  }

// Optional type: ?T
optional_type = { "?" ~ type_expr }
  -> Type {
      "commands": [
          { "define": "optional_type", "args": { "inner": "$1" } }
      ]
  }

// Error union type: !T or E!T
error_union_type = { "!" ~ type_expr }
  -> Type {
      "commands": [
          { "define": "error_union_type", "args": { "payload": "$1" } }
      ]
  }

// Array type: [N]T or []T (slice)
array_type = { "[" ~ integer_literal? ~ "]" ~ type_expr }
  -> Type {
      "commands": [
          { "define": "array_type", "args": { "size": "$1", "element": "$2" } }
      ]
  }

primitive_type = { "i8" | "i16" | "i32" | "i64" | "u8" | "u16" | "u32" | "u64" | "f32" | "f64" | "bool" | "void" }
  -> Type {
      "get_text": true,
      "define": "primitive_type",
      "args": { "name": "$result" }
  }

// ===== Statements =====

statement = { if_stmt | while_stmt | for_stmt | return_stmt | break_stmt | continue_stmt | local_const | local_var | assign_stmt | expr_stmt }
  -> TypedStatement {
      "get_child": { "index": 0 }
  }

// Break statement
break_stmt = { "break" ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "break" }
      ]
  }

// Continue statement
continue_stmt = { "continue" ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "continue" }
      ]
  }

// If statement variants
if_stmt = { if_else | if_only }
  -> TypedStatement { "get_child": { "index": 0 } }

if_only = { "if" ~ "(" ~ expr ~ ")" ~ block }
  -> TypedStatement {
      "commands": [
          { "define": "if", "args": {
              "condition": "$1",
              "then_branch": "$2"
          }}
      ]
  }

if_else = { "if" ~ "(" ~ expr ~ ")" ~ block ~ "else" ~ block }
  -> TypedStatement {
      "commands": [
          { "define": "if", "args": {
              "condition": "$1",
              "then_branch": "$2",
              "else_branch": "$3"
          }}
      ]
  }

// While loop
while_stmt = { "while" ~ "(" ~ expr ~ ")" ~ block }
  -> TypedStatement {
      "commands": [
          { "define": "while", "args": {
              "condition": "$1",
              "body": "$2"
          }}
      ]
  }

// For loop: for (slice) |item| { ... }
for_stmt = { "for" ~ "(" ~ expr ~ ")" ~ "|" ~ identifier ~ "|" ~ block }
  -> TypedStatement {
      "commands": [
          { "define": "for", "args": {
              "iterable": "$1",
              "binding": "$2",
              "body": "$3"
          }}
      ]
  }

// Assignment statement: identifier = expr;
assign_stmt = { identifier ~ "=" ~ expr ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "assignment", "args": {
              "target": "$1",
              "value": "$2"
          }}
      ]
  }

// Children (non-silent): expr?
return_stmt = { "return" ~ expr? ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "return_stmt", "args": { "value": "$1" } }
      ]
  }

// Split into typed/untyped variants
local_const = { local_const_typed | local_const_untyped }
  -> TypedStatement { "get_child": { "index": 0 } }

local_const_typed = { "const" ~ identifier ~ ":" ~ type_expr ~ "=" ~ expr ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "let_stmt", "args": {
              "name": "$1",
              "type": "$2",
              "init": "$3",
              "is_const": true
          }}
      ]
  }

local_const_untyped = { "const" ~ identifier ~ "=" ~ expr ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "let_stmt", "args": {
              "name": "$1",
              "init": "$2",
              "is_const": true
          }}
      ]
  }

local_var = { local_var_typed | local_var_untyped }
  -> TypedStatement { "get_child": { "index": 0 } }

local_var_typed = { "var" ~ identifier ~ ":" ~ type_expr ~ "=" ~ expr ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "let_stmt", "args": {
              "name": "$1",
              "type": "$2",
              "init": "$3",
              "is_const": false
          }}
      ]
  }

local_var_untyped = { "var" ~ identifier ~ "=" ~ expr ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "let_stmt", "args": {
              "name": "$1",
              "init": "$2",
              "is_const": false
          }}
      ]
  }

expr_stmt = { expr ~ ";" }
  -> TypedStatement {
      "commands": [
          { "define": "expression_stmt", "args": { "expr": "$1" } }
      ]
  }

// Collect all statements using get_all_children
block = { "{" ~ statement* ~ "}" }
  -> TypedBlock {
      "get_all_children": true,
      "define": "block",
      "args": { "statements": "$result" }
  }

// ===== Expressions =====

expr = { logical_or }
  -> TypedExpression {
      "get_child": { "index": 0 }
  }

// Logical OR (lowest precedence)
logical_or = { logical_and ~ (or_op ~ logical_and)* }
  -> TypedExpression {
      "fold_binary": { "operand": "logical_and", "operator": "or_op" }
  }

// Logical AND
logical_and = { comparison ~ (and_op ~ comparison)* }
  -> TypedExpression {
      "fold_binary": { "operand": "comparison", "operator": "and_op" }
  }

// Comparison operators
comparison = { addition ~ ((eq_op | neq_op | lte_op | gte_op | lt_op | gt_op) ~ addition)* }
  -> TypedExpression {
      "fold_binary": { "operand": "addition", "operator": "eq_op|neq_op|lte_op|gte_op|lt_op|gt_op" }
  }

addition = { multiplication ~ ((add_op | sub_op) ~ multiplication)* }
  -> TypedExpression {
      "fold_binary": { "operand": "multiplication", "operator": "add_op|sub_op" }
  }

multiplication = { unary ~ ((mul_op | div_op) ~ unary)* }
  -> TypedExpression {
      "fold_binary": { "operand": "unary", "operator": "mul_op|div_op" }
  }

unary = { unary_with_op | primary }
  -> TypedExpression {
      "get_child": { "index": 0 }
  }

unary_with_op = { unary_op ~ primary }
  -> TypedExpression {
      "commands": [
          { "define": "unary", "args": { "op": "$1", "operand": "$2" } }
      ]
  }

primary = { postfix_expr }
  -> TypedExpression {
      "get_child": { "index": 0 }
  }

// Postfix expressions: base followed by call/field/index
// For now, just handle simple cases - no chaining
postfix_expr = { call_expr | field_expr | index_expr | atom }
  -> TypedExpression {
      "get_child": { "index": 0 }
  }

// Function call: atom(args...)
call_expr = { atom ~ "(" ~ call_args? ~ ")" }
  -> TypedExpression {
      "commands": [
          { "define": "call", "args": { "callee": "$1", "args": "$2" } }
      ]
  }

// Field access: atom.field
field_expr = { atom ~ "." ~ identifier }
  -> TypedExpression {
      "commands": [
          { "define": "field_access", "args": { "object": "$1", "field": "$2" } }
      ]
  }

// Index: atom[index]
index_expr = { atom ~ "[" ~ expr ~ "]" }
  -> TypedExpression {
      "commands": [
          { "define": "index", "args": { "object": "$1", "index": "$2" } }
      ]
  }

call_args = { expr ~ ("," ~ expr)* }
  -> List {
      "get_all_children": true
  }

// Atom: the base of postfix expressions
atom = { try_expr | array_literal | bool_literal | string_literal | integer_literal | identifier_expr | paren_expr }
  -> TypedExpression {
      "get_child": { "index": 0 }
  }

// Try expression: try expr
try_expr = { "try" ~ primary }
  -> TypedExpression {
      "commands": [
          { "define": "try", "args": { "expr": "$1" } }
      ]
  }

paren_expr = _{ "(" ~ expr ~ ")" }

// Array literal: [a, b, c]
array_literal = { "[" ~ array_elements? ~ "]" }
  -> TypedExpression {
      "commands": [
          { "define": "array_literal", "args": { "elements": "$1" } }
      ]
  }

array_elements = { expr ~ ("," ~ expr)* }
  -> List {
      "get_all_children": true
  }

identifier_expr = { identifier }
  -> TypedExpression {
      "get_text": true,
      "define": "variable",
      "args": { "name": "$result" }
  }

// ===== Literals =====

bool_literal = { "true" | "false" }
  -> TypedExpression {
      "get_text": true,
      "define": "bool_literal",
      "args": { "value": "$result" }
  }

integer_literal = @{ "-"? ~ ASCII_DIGIT+ }
  -> TypedExpression {
      "get_text": true,
      "parse_int": true,
      "define": "int_literal",
      "args": { "value": "$result" }
  }

string_literal = @{ "\"" ~ string_inner* ~ "\"" }
  -> TypedExpression {
      "get_text": true,
      "define": "string_literal",
      "args": { "value": "$result" }
  }

string_inner = { (!("\"" | "\\") ~ ANY) | escape_seq }

escape_seq = { "\\" ~ ("n" | "r" | "t" | "\\" | "\"" | "0") }

// ===== Identifiers =====

identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
  -> String {
      "get_text": true
  }

// ===== Operators =====

// Logical operators
and_op = { "and" }
  -> String { "get_text": true }

or_op = { "or" }
  -> String { "get_text": true }

// Comparison operators (must check longer operators first)
eq_op = { "==" }
  -> String { "get_text": true }

neq_op = { "!=" }
  -> String { "get_text": true }

lte_op = { "<=" }
  -> String { "get_text": true }

gte_op = { ">=" }
  -> String { "get_text": true }

lt_op = { "<" }
  -> String { "get_text": true }

gt_op = { ">" }
  -> String { "get_text": true }

// Arithmetic operators
add_op = { "+" }
  -> String { "get_text": true }

sub_op = { "-" }
  -> String { "get_text": true }

mul_op = { "*" }
  -> String { "get_text": true }

div_op = { "/" }
  -> String { "get_text": true }

unary_op = { "-" | "!" }
  -> String { "get_text": true }

// ===== Whitespace and Comments =====

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n"? }
