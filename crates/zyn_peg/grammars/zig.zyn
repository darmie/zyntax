// ===================================================================
// ZynPEG Zig Grammar with TypedAST Action Blocks
// ===================================================================
//
// This grammar extends the pest PEG syntax with action blocks that
// generate TypedAST nodes directly during parsing.
//
// ===================================================================

@language {
    name: "Zig",
    version: "0.11",
    file_extensions: [".zig", ".zyn"],
}

@imports {
    use zyntax_typed_ast::*;
    use zyntax_typed_ast::typed_ast::*;
    use zyntax_typed_ast::arena::AstArena;
    use zyntax_typed_ast::types::Type;
}

@context {
    arena: &mut AstArena,
    type_registry: &mut TypeRegistry,
    scope: &mut ScopeStack,
}

@type_helpers {
    fn fold_binary(first: TypedExpression, rest: Vec<(String, TypedExpression)>, default_op: BinaryOp) -> TypedExpression {
        rest.into_iter().fold(first, |left, (op_str, right)| {
            let op = match op_str.as_str() {
                "+" => BinaryOp::Add,
                "-" => BinaryOp::Sub,
                "*" => BinaryOp::Mul,
                "/" => BinaryOp::Div,
                "%" => BinaryOp::Mod,
                "==" => BinaryOp::Eq,
                "!=" => BinaryOp::Ne,
                "<" => BinaryOp::Lt,
                "<=" => BinaryOp::Le,
                ">" => BinaryOp::Gt,
                ">=" => BinaryOp::Ge,
                "and" => BinaryOp::And,
                "or" => BinaryOp::Or,
                "|" => BinaryOp::BitOr,
                "&" => BinaryOp::BitAnd,
                "^" => BinaryOp::BitXor,
                "<<" => BinaryOp::Shl,
                ">>" => BinaryOp::Shr,
                "orelse" => BinaryOp::Orelse,
                "catch" => BinaryOp::Catch,
                _ => default_op,
            };
            let result_ty = Self::infer_binary_type(&left.ty, op, &right.ty);
            TypedExpression {
                expr: Expression::BinaryOp(op, Box::new(left.clone()), Box::new(right.clone())),
                ty: result_ty,
                span: Span::merge(&left.span, &right.span),
            }
        })
    }

    fn infer_binary_type(left: &Type, op: BinaryOp, right: &Type) -> Type {
        match op {
            BinaryOp::Eq | BinaryOp::Ne | BinaryOp::Lt | BinaryOp::Le |
            BinaryOp::Gt | BinaryOp::Ge | BinaryOp::And | BinaryOp::Or => Type::Bool,
            BinaryOp::Orelse => left.unwrap_optional(),
            BinaryOp::Catch => left.unwrap_result(),
            _ => left.clone(),
        }
    }

    fn fold_postfix(base: TypedExpression, ops: Vec<PostfixOp>) -> TypedExpression {
        ops.into_iter().fold(base, |expr, op| {
            match op {
                PostfixOp::Deref => TypedExpression {
                    ty: expr.ty.deref(),
                    expr: Expression::Deref(Box::new(expr.clone())),
                    span: expr.span.clone(),
                },
                PostfixOp::Field(name) => TypedExpression {
                    ty: Type::Unknown,
                    expr: Expression::FieldAccess(Box::new(expr.clone()), name),
                    span: expr.span.clone(),
                },
                PostfixOp::Index(index) => TypedExpression {
                    ty: expr.ty.element_type(),
                    expr: Expression::Index(Box::new(expr.clone()), Box::new(index)),
                    span: expr.span.clone(),
                },
                PostfixOp::Call(args) => TypedExpression {
                    ty: expr.ty.return_type(),
                    expr: Expression::Call(Box::new(expr.clone()), args),
                    span: expr.span.clone(),
                },
            }
        })
    }

    fn unwrap_result_type(ty: Type) -> Type {
        match ty {
            Type::Result(inner, _) => *inner,
            _ => ty,
        }
    }
}

// ===== Program Structure =====

program = { SOI ~ declaration* ~ EOI }
  -> TypedProgram {
      declarations: $2,
      span: span($1, $3),
  }

declaration = {
    const_decl
  | var_decl
  | fn_decl
  | struct_decl
  | enum_decl
  | union_decl
  | error_set_decl
}

// ===== Declarations =====

const_decl = { "const" ~ identifier ~ (":" ~ type_expr)? ~ "=" ~ expr ~ ";" }
  -> TypedDeclaration {
      decl: Declaration::Const(ConstDecl {
          name: intern($2),
          ty: $3,
          value: $5,
          is_pub: false,
      }),
      span: span($1, $6),
  }

var_decl = { "var" ~ identifier ~ (":" ~ type_expr)? ~ "=" ~ expr ~ ";" }
  -> TypedDeclaration {
      decl: Declaration::Var(VarDecl {
          name: intern($2),
          ty: $3,
          value: $5,
          is_pub: false,
      }),
      span: span($1, $6),
  }

fn_decl = {
    "fn" ~ identifier ~
    "(" ~ fn_params? ~ ")" ~ type_expr ~
    block
}
  -> TypedDeclaration {
      decl: Declaration::Function(FnDecl {
          name: intern($2),
          params: $4.unwrap_or_default(),
          return_type: $6,
          body: Some($7.statements),
          is_pub: false,
          is_export: false,
          is_extern: false,
      }),
      span: span($1, $7),
  }

fn_params = { fn_param ~ ("," ~ fn_param)* }
fn_param  = { comptime_param | regular_param }
comptime_param = { "comptime" ~ identifier ~ ":" ~ "type" }
  -> TypedParam {
      name: intern($2),
      ty: Type::Type,
      is_comptime: true,
  }

regular_param = { identifier ~ ":" ~ type_expr }
  -> TypedParam {
      name: intern($1),
      ty: $3,
      is_comptime: false,
  }

struct_decl = {
    "const" ~ identifier ~ "=" ~ "struct" ~ "{" ~
    field_decl* ~
    "}" ~ ";"
}
  -> TypedDeclaration {
      decl: Declaration::Struct(StructDecl {
          name: intern($2),
          fields: $6,
          is_packed: false,
      }),
      span: span($1, $8),
  }

field_decl = { identifier ~ ":" ~ type_expr ~ "," }
  -> TypedField {
      name: intern($1),
      ty: $3,
      default: None,
  }

enum_decl = {
    "const" ~ identifier ~ "=" ~ "enum" ~ ("(" ~ type_expr ~ ")")? ~ "{" ~
    enum_variant ~ ("," ~ enum_variant)* ~ ","? ~
    "}" ~ ";"
}

enum_variant = { identifier ~ ("=" ~ expr)? }

union_decl = {
    "const" ~ identifier ~ "=" ~ "union" ~ ("(" ~ "enum" ~ ")")? ~ "{" ~
    union_field ~ ("," ~ union_field)* ~ ","? ~
    "}" ~ ";"
}

union_field = { identifier ~ ":" ~ type_expr }

error_set_decl = {
    "const" ~ identifier ~ "=" ~ "error" ~ "{" ~
    identifier ~ ("," ~ identifier)* ~ ","? ~
    "}" ~ ";"
}

// ===== Type Expressions =====

type_expr = {
    primitive_type
  | identifier
  | array_type
  | pointer_type
  | optional_type
  | error_union_type
}

primitive_type = {
    "i8" | "i16" | "i32" | "i64" | "i128"
  | "u8" | "u16" | "u32" | "u64" | "u128"
  | "f32" | "f64"
  | "bool"
  | "void"
}
  -> Type {
      match $1 {
          "i8" => Type::I8,
          "i16" => Type::I16,
          "i32" => Type::I32,
          "i64" => Type::I64,
          "u8" => Type::U8,
          "u16" => Type::U16,
          "u32" => Type::U32,
          "u64" => Type::U64,
          "f32" => Type::F32,
          "f64" => Type::F64,
          "bool" => Type::Bool,
          "void" => Type::Void,
          _ => Type::Unknown,
      }
  }

array_type = { "[" ~ integer_literal? ~ "]" ~ type_expr }
  -> Type {
      Type::Array(Box::new($4), $2.map(|s| parse_int(s)))
  }

pointer_type = { "*" ~ type_expr }
  -> Type {
      Type::Pointer(Box::new($2))
  }

optional_type = { "?" ~ type_expr }
  -> Type {
      Type::Optional(Box::new($2))
  }

error_union_type = { "!" ~ type_expr }
  -> Type {
      Type::Result(Box::new($2), Box::new(Type::Error))
  }

// ===== Statements =====

statement = {
    const_decl
  | var_decl
  | assignment
  | if_stmt
  | while_stmt
  | for_stmt
  | break_stmt
  | continue_stmt
  | return_stmt
  | defer_stmt
  | errdefer_stmt
  | expr_stmt
}

defer_stmt = { "defer" ~ (block | expr_stmt) }
errdefer_stmt = { "errdefer" ~ (block | expr_stmt) }

assignment = { assign_target ~ assign_op ~ expr ~ ";" }
  -> TypedStatement {
      stmt: Assignment {
          target: $1,
          op: parse_assign_op($2),
          value: $3,
      },
      span: span($1, $4),
  }

assign_target = { identifier ~ ("[" ~ expr ~ "]")* }
assign_op = { "<<=" | ">>=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "=" }

return_stmt = { "return" ~ expr? ~ ";" }
  -> TypedStatement {
      stmt: Return { value: $2 },
      span: span($1, $3),
  }

expr_stmt = { expr ~ ";" }
  -> TypedStatement {
      stmt: ExprStmt { expr: $1 },
      span: span($1, $2),
  }

if_stmt = {
    if_let_stmt
  | if_regular_stmt
}

if_let_stmt = {
    "if" ~ "(" ~ "let" ~ pattern ~ "=" ~ expr ~ ")" ~ block ~
    ("else" ~ (if_stmt | block))?
}
  -> TypedStatement {
      stmt: Match {
          scrutinee: $6,
          arms: vec![
              MatchArm { pattern: $4, body: $8 },
              MatchArm { pattern: Pattern::Wildcard, body: $9.unwrap_or_default() },
          ],
      },
      span: span($1, $9),
  }

if_regular_stmt = {
    "if" ~ "(" ~ expr ~ ")" ~ block ~
    ("else" ~ (if_stmt | block))?
}
  -> TypedStatement {
      stmt: If {
          condition: $3,
          then_branch: $5,
          else_branch: $6,
      },
      span: span($1, $6),
  }

while_stmt = {
    "while" ~ "(" ~ expr ~ ")" ~ block
}
  -> TypedStatement {
      stmt: While {
          condition: $3,
          body: $5,
      },
      span: span($1, $5),
  }

for_stmt = {
    "for" ~ "(" ~ identifier ~ "in" ~ expr ~ ")" ~ block
}

break_stmt = { "break" ~ ";" }
  -> TypedStatement {
      stmt: Break,
      span: span($1, $2),
  }

continue_stmt = { "continue" ~ ";" }
  -> TypedStatement {
      stmt: Continue,
      span: span($1, $2),
  }

block = { "{" ~ statement* ~ "}" }
  -> TypedBlock {
      statements: $2,
      span: span($1, $3),
  }

// ===== Expressions =====

expr = { orelse_expr }

orelse_expr = { catch_expr ~ (orelse_op ~ catch_expr)* }
  -> TypedExpression {
      fold_binary($1, $2, BinaryOp::Orelse)
  }

catch_expr = { logical_or ~ (catch_op ~ logical_or)* }
  -> TypedExpression {
      fold_binary($1, $2, BinaryOp::Catch)
  }

logical_or = { logical_and ~ (log_or_op ~ logical_and)* }
  -> TypedExpression {
      fold_binary($1, $2, BinaryOp::Or)
  }

logical_and = { equality ~ (log_and_op ~ equality)* }
  -> TypedExpression {
      fold_binary($1, $2, BinaryOp::And)
  }

equality = { comparison ~ (eq_op ~ comparison)* }
  -> TypedExpression {
      fold_binary($1, $2, parse_eq_op)
  }

comparison = { bitwise_or ~ (cmp_op ~ bitwise_or)* }
  -> TypedExpression {
      fold_binary($1, $2, parse_cmp_op)
  }

bitwise_or = { bitwise_xor ~ (bit_or_op ~ bitwise_xor)* }
  -> TypedExpression {
      fold_binary($1, $2, BinaryOp::BitOr)
  }

bitwise_xor = { bitwise_and ~ (bit_xor_op ~ bitwise_and)* }
  -> TypedExpression {
      fold_binary($1, $2, BinaryOp::BitXor)
  }

bitwise_and = { bit_shift ~ (bit_and_op ~ bit_shift)* }
  -> TypedExpression {
      fold_binary($1, $2, BinaryOp::BitAnd)
  }

bit_shift = { addition ~ (shift_op ~ addition)* }
  -> TypedExpression {
      fold_binary($1, $2, parse_shift_op)
  }

addition = { multiplication ~ (add_op ~ multiplication)* }
  -> TypedExpression {
      fold_binary($1, $2, parse_add_op)
  }

multiplication = { unary ~ (mul_op ~ unary)* }
  -> TypedExpression {
      fold_binary($1, $2, parse_mul_op)
  }

unary = {
    unary_op ~ unary
  | postfix
}
  -> TypedExpression {
      match $1 {
          Some(op) => TypedExpression {
              expr: UnaryOp(parse_unary_op(op), Box::new($2)),
              ty: $2.ty.clone(),
              span: span($1, $2),
          },
          None => $2,
      }
  }

postfix = {
    primary ~ postfix_op*
}
  -> TypedExpression {
      fold_postfix($1, $2)
  }

postfix_op = {
    ".*"
  | "." ~ identifier
  | "[" ~ expr ~ "]"
  | "(" ~ args? ~ ")"
}

args = { expr ~ ("," ~ expr)* }

primary = {
    literal
  | struct_literal
  | switch_expr
  | try_expr
  | lambda_expr
  | "(" ~ expr ~ ")"
  | identifier
}

// ===== Lambda/Closure Expression =====

lambda_expr = {
    "|" ~ lambda_params? ~ "|" ~ (block | expr)
}
  -> TypedExpression {
      expr: Lambda {
          params: $2.unwrap_or_default(),
          body: $4,
          captures: vec![],
      },
      ty: Type::Function(vec![], Box::new(Type::Unknown)),
      span: span($1, $4),
  }

lambda_params = { lambda_param ~ ("," ~ lambda_param)* }
lambda_param = { identifier ~ (":" ~ type_expr)? }

// ===== Try Expression =====

try_expr = { "try" ~ postfix }
  -> TypedExpression {
      expr: Try { expr: Box::new($2) },
      ty: unwrap_result_type($2.ty),
      span: span($1, $2),
  }

// ===== Switch Expression =====

switch_expr = {
    "switch" ~ "(" ~ expr ~ ")" ~ "{" ~
    switch_case ~ ("," ~ switch_case)* ~ ","? ~
    "}"
}
  -> TypedExpression {
      expr: Switch {
          scrutinee: Box::new($3),
          cases: collect_cases($6, $7),
      },
      ty: infer_switch_type($6, $7),
      span: span($1, $9),
  }

switch_case = {
    switch_pattern ~ "=>" ~ expr
}

switch_pattern = {
    integer_literal
  | switch_else
  | identifier
}

switch_else = { "else" }

// ===== Literals =====

literal = {
    bool_literal
  | null_literal
  | undefined_literal
  | float_literal     // Must be before integer_literal (3.14 vs 3)
  | integer_literal
  | string_literal
  | array_literal
}

null_literal = { "null" }
  -> TypedExpression {
      expr: Literal(TypedLiteral::Null),
      ty: Type::Optional(Box::new(Type::Unknown)),
      span: $1.span,
  }

undefined_literal = { "undefined" }
  -> TypedExpression {
      expr: Literal(TypedLiteral::Undefined),
      ty: Type::Unknown,
      span: $1.span,
  }

bool_literal = { "true" | "false" }
  -> TypedExpression {
      expr: Literal(TypedLiteral::Bool($1 == "true")),
      ty: Type::Bool,
      span: $1.span,
  }

integer_literal = @{ "-"? ~ ASCII_DIGIT+ }
  -> TypedExpression {
      expr: Literal(TypedLiteral::Int(parse_int($1))),
      ty: Type::I32,
      span: $1.span,
  }

float_literal = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
  -> TypedExpression {
      expr: Literal(TypedLiteral::Float(parse_float($1))),
      ty: Type::F64,
      span: $1.span,
  }

string_literal = { "\"" ~ string_inner ~ "\"" }
  -> TypedExpression {
      expr: Literal(TypedLiteral::String(intern($2))),
      ty: Type::Pointer(Box::new(Type::I8)),
      span: span($1, $3),
  }

string_inner = @{ (!("\"" | "\\") ~ ANY)* }

array_literal = { "[" ~ "_" ~ "]" ~ type_expr ~ "{" ~ (expr ~ ("," ~ expr)*)? ~ "}" }
  -> TypedExpression {
      let elements = $6.map(|(first, rest)| {
          let mut v = vec![first];
          v.extend(rest);
          v
      }).unwrap_or_default();
      TypedExpression {
          expr: Array(elements.clone()),
          ty: Type::Array(Box::new($4), Some(elements.len())),
          span: span($1, $7),
      }
  }

struct_literal = {
    identifier ~ "{" ~ struct_field_init? ~ ("," ~ struct_field_init)* ~ ","? ~ "}"
}
  -> TypedExpression {
      expr: StructLiteral {
          name: intern($1),
          fields: collect_fields($3, $4),
      },
      ty: Type::Named(intern($1)),
      span: span($1, $6),
  }

struct_field_init = { "." ~ identifier ~ "=" ~ expr }

// ===== Patterns =====

pattern = {
    wildcard_pattern
  | identifier_pattern
  | literal_pattern
  | enum_pattern
}

wildcard_pattern = { "_" }
  -> Pattern {
      Pattern::Wildcard
  }

identifier_pattern = { ("mut" ~ identifier) | identifier }
  -> Pattern {
      Pattern::Binding(intern($1))
  }

literal_pattern = { literal }
  -> Pattern {
      Pattern::Literal($1)
  }

enum_pattern = {
    identifier ~ "(" ~ pattern ~ ")"
}
  -> Pattern {
      Pattern::Variant(intern($1), Box::new($3))
  }

// ===== Identifiers =====

identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// ===== Operators =====

orelse_op = { "orelse" }
catch_op = { "catch" }

log_or_op = { "or" }
log_and_op = { "and" }

cmp_op = { "<=" | ">=" | "<" | ">" }
eq_op = { "==" | "!=" }

bit_or_op = { "|" }
bit_xor_op = { "^" }
bit_and_op = { "&" }
shift_op = { "<<" | ">>" }

add_op = { "+" | "-" }
mul_op = { "*" | "/" | "%" }

unary_op = { "-" | "!" | "~" | "&" }

// ===== Whitespace and Comments =====

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n"? }
