// ===================================================================
// Zig Grammar with Grammar2 Named Bindings
// ===================================================================
//
// This grammar uses ZynPEG 2.0 named bindings for direct TypedAST construction.
// Compatible with Grammar2 runtime (GrammarInterpreter).
//
// Usage:
//   zyntax compile --source file.zig --grammar zig.zyn --format zyn --jit
//
// ===================================================================

@language {
    name: "Zig",
    version: "0.11",
    file_extensions: [".zig"],
    entry_point: "main",
}

// ===== Program Structure =====

program = { SOI ~ decls:declarations ~ EOI }
  -> decls

declarations = { decl:declaration* }
  -> TypedProgram {
      declarations: decl,
  }

declaration = { struct_decl | enum_decl | extern_fn_decl | fn_decl | const_decl | var_decl }

// ===== Struct Declaration =====

struct_decl = { "const" ~ name:identifier ~ "=" ~ "struct" ~ "{" ~ fields:struct_field_list? ~ "}" ~ ";" }
  -> TypedDeclaration::Class {
      name: intern(name),
      fields: fields,
      type_params: [],
  }

struct_field_list = { f:struct_field* }
  -> f

struct_field = { name:identifier ~ ":" ~ ty:type_expr ~ ","? }
  -> TypedField {
      name: intern(name),
      ty: ty,
  }

// ===== Enum Declaration =====

enum_decl = { "const" ~ name:identifier ~ "=" ~ "enum" ~ "{" ~ variants:enum_variant_list? ~ "}" ~ ";" }
  -> TypedDeclaration::Enum {
      name: intern(name),
      variants: variants,
      type_params: [],
  }

enum_variant_list = { v:enum_variant* }
  -> v

enum_variant = { name:identifier ~ ","? }
  -> TypedVariant {
      name: intern(name),
      fields: TypedVariantFields::Unit,
  }

// ===== Function Declaration =====

extern_fn_decl = { extern_fn_decl_with_params | extern_fn_decl_no_params }

extern_fn_decl_with_params = { "extern" ~ "fn" ~ name:identifier ~ "(" ~ params:fn_param_list ~ ")" ~ ret:type_expr ~ ";" }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: params,
      return_type: ret,
      body: None,
      is_extern: true,
  }

extern_fn_decl_no_params = { "extern" ~ "fn" ~ name:identifier ~ "(" ~ ")" ~ ret:type_expr ~ ";" }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: [],
      return_type: ret,
      body: None,
      is_extern: true,
  }

fn_decl = { async_fn_decl | sync_fn_decl }

sync_fn_decl = { fn_decl_with_params | fn_decl_no_params }

async_fn_decl = { async_fn_decl_with_params | async_fn_decl_no_params }

async_fn_decl_with_params = { "async" ~ "fn" ~ name:identifier ~ "(" ~ params:fn_param_list ~ ")" ~ ret:type_expr ~ body:block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: params,
      return_type: ret,
      body: Some(body),
      is_async: true,
  }

async_fn_decl_no_params = { "async" ~ "fn" ~ name:identifier ~ "(" ~ ")" ~ ret:type_expr ~ body:block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: [],
      return_type: ret,
      body: Some(body),
      is_async: true,
  }

fn_decl_with_params = { "fn" ~ name:identifier ~ "(" ~ params:fn_param_list ~ ")" ~ ret:type_expr ~ body:block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: params,
      return_type: ret,
      body: Some(body),
  }

fn_decl_no_params = { "fn" ~ name:identifier ~ "(" ~ ")" ~ ret:type_expr ~ body:block }
  -> TypedDeclaration::Function {
      name: intern(name),
      params: [],
      return_type: ret,
      body: Some(body),
  }

fn_param_list = { p:fn_param_item* }
  -> p

fn_param_item = { fn_param_any ~ ","? }
  -> fn_param_any

fn_param_any = { comptime_param | fn_param }

comptime_param = { "comptime" ~ name:identifier ~ ":" ~ ty:type_expr }
  -> TypedParameter {
      name: intern(name),
      ty: ty,
      kind: ParameterKind::Comptime,
  }

fn_param = { name:identifier ~ ":" ~ ty:type_expr }
  -> TypedParameter {
      name: intern(name),
      ty: ty,
  }

// ===== Variable Declarations =====

const_decl = { const_decl_typed | const_decl_untyped }

const_decl_typed = { "const" ~ name:identifier ~ ":" ~ ty:type_expr ~ "=" ~ init:expr ~ ";" }
  -> TypedDeclaration::Variable {
      name: intern(name),
      ty: ty,
      initializer: Some(init),
      mutability: Mutability::Immutable,
  }

const_decl_untyped = { "const" ~ name:identifier ~ "=" ~ init:expr ~ ";" }
  -> TypedDeclaration::Variable {
      name: intern(name),
      initializer: Some(init),
      mutability: Mutability::Immutable,
  }

var_decl = { var_decl_typed | var_decl_untyped }

var_decl_typed = { "var" ~ name:identifier ~ ":" ~ ty:type_expr ~ "=" ~ init:expr ~ ";" }
  -> TypedDeclaration::Variable {
      name: intern(name),
      ty: ty,
      initializer: Some(init),
      mutability: Mutability::Mutable,
  }

var_decl_untyped = { "var" ~ name:identifier ~ "=" ~ init:expr ~ ";" }
  -> TypedDeclaration::Variable {
      name: intern(name),
      initializer: Some(init),
      mutability: Mutability::Mutable,
  }

// ===== Type Expressions =====

type_expr = { pointer_type | optional_type | error_union_type | array_type | primitive_type | named_type }

pointer_type = { "*" ~ "const"? ~ inner:type_expr }
  -> Type::Pointer {
      pointee: inner,
  }

optional_type = { "?" ~ inner:type_expr }
  -> Type::Optional {
      inner: inner,
  }

error_union_type = { "!" ~ inner:type_expr }
  -> Type::ErrorUnion {
      payload: inner,
  }

array_type = { "[" ~ size:integer_literal? ~ "]" ~ element:type_expr }
  -> Type::Array {
      element: element,
      size: size,
  }

primitive_type = @{ "i8" | "i16" | "i32" | "i64" | "u8" | "u16" | "u32" | "u64" | "f32" | "f64" | "bool" | "void" | "type" }
  -> Type::Primitive {
      name: intern(text),
  }

named_type = { name:identifier }
  -> Type::Named {
      name: intern(name),
  }

// ===== Statements =====

statement = { if_stmt | while_stmt | for_stmt | return_stmt | break_stmt | continue_stmt | local_const | local_var | assign_stmt | expr_stmt }

break_stmt = { "break" ~ ";" }
  -> TypedStatement::Break {
      value: None,
  }

continue_stmt = { "continue" ~ ";" }
  -> TypedStatement::Continue {}

if_stmt = { if_else | if_only }

if_only = { "if" ~ "(" ~ cond:expr ~ ")" ~ then_block:block }
  -> TypedStatement::If {
      condition: cond,
      then_block: then_block,
      else_block: None,
  }

if_else = { "if" ~ "(" ~ cond:expr ~ ")" ~ then_block:block ~ "else" ~ else_block:block }
  -> TypedStatement::If {
      condition: cond,
      then_block: then_block,
      else_block: Some(else_block),
  }

while_stmt = { "while" ~ "(" ~ cond:expr ~ ")" ~ body:block }
  -> TypedStatement::While {
      condition: cond,
      body: body,
  }

for_stmt = { "for" ~ "(" ~ iter:expr ~ ")" ~ "|" ~ binding:identifier ~ "|" ~ body:block }
  -> TypedStatement::For {
      variable: intern(binding),
      iterable: iter,
      body: body,
  }

assign_stmt = { target:identifier ~ "=" ~ value:expr ~ ";" }
  -> TypedStatement::Assignment {
      target: intern(target),
      value: value,
  }

return_stmt = { "return" ~ value:expr? ~ ";" }
  -> TypedStatement::Return {
      value: value,
  }

local_const = { local_const_typed | local_const_untyped }

local_const_typed = { "const" ~ name:identifier ~ ":" ~ ty:type_expr ~ "=" ~ init:expr ~ ";" }
  -> TypedStatement::Let {
      name: intern(name),
      type_annotation: Some(ty),
      initializer: Some(init),
      is_mutable: false,
  }

local_const_untyped = { "const" ~ name:identifier ~ "=" ~ init:expr ~ ";" }
  -> TypedStatement::Let {
      name: intern(name),
      initializer: Some(init),
      is_mutable: false,
  }

local_var = { local_var_typed | local_var_untyped }

local_var_typed = { "var" ~ name:identifier ~ ":" ~ ty:type_expr ~ "=" ~ init:expr ~ ";" }
  -> TypedStatement::Let {
      name: intern(name),
      type_annotation: Some(ty),
      initializer: Some(init),
      is_mutable: true,
  }

local_var_untyped = { "var" ~ name:identifier ~ "=" ~ init:expr ~ ";" }
  -> TypedStatement::Let {
      name: intern(name),
      initializer: Some(init),
      is_mutable: true,
  }

expr_stmt = { e:expr ~ ";" }
  -> TypedStatement::Expression {
      expr: e,
  }

block = { "{" ~ stmts:statement* ~ "}" }
  -> TypedBlock {
      statements: stmts,
  }

// ===== Expressions =====
// For now, simplified to avoid complex binary folding

expr = { e:comparison_expr }
  -> e

comparison_expr = { left:add_expr ~ (op:comparison_op ~ right:add_expr)? }
  -> left

comparison_op = @{ "==" | "!=" | "<=" | ">=" | "<" | ">" }

add_expr = { left:mul_expr ~ (op:add_op ~ right:mul_expr)? }
  -> left

add_op = @{ "+" | "-" }

mul_expr = { left:unary_expr ~ (op:mul_op ~ right:unary_expr)? }
  -> left

mul_op = @{ "*" | "/" }

unary_expr = { unary_with_op | primary }

unary_with_op = { op:unary_op ~ operand:primary }
  -> TypedExpression::Unary {
      op: op,
      operand: operand,
  }

unary_op = { "-" | "!" }

primary = { postfix_expr }

// Postfix expressions
postfix_expr = { call_expr | field_expr | index_expr | atom }

call_expr = { callee:atom ~ "(" ~ args:call_arg_list? ~ ")" }
  -> TypedExpression::Call {
      callee: callee,
      args: args,
  }

call_arg_list = { a:call_arg* }
  -> a

call_arg = { e:expr ~ ","? }
  -> e

field_expr = { object:atom ~ "." ~ field:identifier }
  -> TypedExpression::FieldAccess {
      object: object,
      field: intern(field),
  }

index_expr = { object:atom ~ "[" ~ index:expr ~ "]" }
  -> TypedExpression::Index {
      object: object,
      index: index,
  }

// Atom: base expressions
atom = { try_expr | await_expr | struct_init | array_literal | bool_literal | string_literal | integer_literal | identifier_expr | paren_expr }

// Try expression
try_expr = { "try" ~ e:primary }
  -> TypedExpression::Try {
      expr: e,
  }

// Await expression
await_expr = { "await" ~ e:primary }
  -> TypedExpression::Await {
      expr: e,
  }

// Struct initialization
struct_init = { type_name:identifier ~ "{" ~ fields:struct_init_field_list? ~ "}" }
  -> TypedExpression::StructLiteral {
      type_name: intern(type_name),
      fields: fields,
  }

struct_init_field_list = { f:struct_init_field* }
  -> f

struct_init_field = { "." ~ name:identifier ~ "=" ~ value:expr ~ ","? }
  -> TypedFieldInit {
      name: intern(name),
      value: value,
  }

// Array literal
array_literal = { "[" ~ elements:array_element_list? ~ "]" }
  -> TypedExpression::Array {
      elements: elements,
  }

array_element_list = { e:array_element* }
  -> e

array_element = { v:expr ~ ","? }
  -> v

paren_expr = _{ "(" ~ expr ~ ")" }

identifier_expr = { name:identifier }
  -> TypedExpression::Variable {
      name: intern(name),
  }

// ===== Literals =====

bool_literal = { "true" | "false" }
  -> TypedExpression::Literal {
      value: TypedLiteral::Bool { value: text },
  }

integer_literal = @{ "-"? ~ ASCII_DIGIT+ }
  -> TypedExpression::Literal {
      value: TypedLiteral::Int { value: parse_int(text) },
  }

string_literal = @{ "\"" ~ string_inner* ~ "\"" }
  -> TypedExpression::Literal {
      value: TypedLiteral::String { value: intern(text) },
  }

string_inner = { (!("\"" | "\\") ~ ANY) | escape_seq }

escape_seq = { "\\" ~ ("n" | "r" | "t" | "\\" | "\"" | "0") }

// ===== Identifiers =====

keyword = @{
    ("struct" | "enum" | "fn" | "const" | "var" | "if" | "else" | "while" | "for" |
     "return" | "break" | "continue" | "try" | "await" | "async" | "and" | "or" | "true" | "false" |
     "comptime" | "type" | "switch" | "extern" | "error" |
     "i8" | "i16" | "i32" | "i64" | "u8" | "u16" | "u32" | "u64" | "f32" | "f64" | "bool" | "void")
    ~ !(ASCII_ALPHANUMERIC | "_")
}

identifier = @{ !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// ===== Whitespace and Comments =====

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n"? }
