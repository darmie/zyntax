// ZynPEG Grammar Definition
// This grammar parses .zyn files which extend pest PEG syntax with TypedAST action blocks

program = { SOI ~ directive* ~ rule_def* ~ EOI }

// ===== Directives =====

directive = {
    language_directive
  | imports_directive
  | context_directive
  | type_helpers_directive
  | error_messages_directive
  | builtin_directive
}

// @language { name: "Zig", version: "0.11", file_extensions: [".zig", ".zyn"] }
language_directive = {
    "@language" ~ "{" ~ language_field ~ ("," ~ language_field)* ~ ","? ~ "}"
}

language_field = {
    "name" ~ ":" ~ string_literal
  | "version" ~ ":" ~ string_literal
  | "file_extensions" ~ ":" ~ "[" ~ string_literal ~ ("," ~ string_literal)* ~ "]"
  | "entry_point" ~ ":" ~ string_literal
}

// @imports { use zyntax_typed_ast::*; }
imports_directive = {
    "@imports" ~ "{" ~ rust_code ~ "}"
}

// @context { arena: &mut AstArena, type_registry: &mut TypeRegistry }
context_directive = {
    "@context" ~ "{" ~ context_field ~ ("," ~ context_field)* ~ ","? ~ "}"
}

context_field = {
    identifier ~ ":" ~ rust_type
}

// @type_helpers { fn infer_type(...) -> Type { ... } }
type_helpers_directive = {
    "@type_helpers" ~ "{" ~ rust_code ~ "}"
}

// @error_messages { type_mismatch(...) { message: "...", ... } }
error_messages_directive = {
    "@error_messages" ~ "{" ~ error_def* ~ "}"
}

error_def = {
    identifier ~ "(" ~ error_params? ~ ")" ~ "{" ~ error_field* ~ "}"
}

error_params = { identifier ~ ":" ~ rust_type ~ ("," ~ identifier ~ ":" ~ rust_type)* }

error_field = {
    "message" ~ ":" ~ (string_literal | format_expr)
  | "primary" ~ ":" ~ "(" ~ identifier ~ "," ~ (string_literal | format_expr) ~ ")"
  | "hints" ~ ":" ~ "[" ~ (string_literal | format_expr) ~ ("," ~ (string_literal | format_expr))* ~ "]"
}

format_expr = { "format!" ~ "(" ~ string_literal ~ ("," ~ rust_expr)* ~ ")" }

// @builtin { trace: "$haxe$trace$int", print: "$io$print" }
// Simple function name -> runtime symbol mappings for built-in functions
builtin_directive = {
    "@builtin" ~ "{" ~ builtin_def* ~ "}"
}

builtin_def = {
    identifier ~ ":" ~ string_literal ~ ","?
}

// ===== Rule Definitions =====

// rule_name = { pattern } -> Type { action }
rule_def = {
    identifier ~ "=" ~ rule_modifier? ~ "{" ~ pattern ~ "}" ~ action_block?
}

rule_modifier = { "@" | "!" | "$" | "_" }

// Action block: -> TypedExpression { JSON commands }
// JSON-based action mappings that call host functions at runtime
action_block = {
    "->" ~ rust_type ~ "{" ~ action_body ~ "}"
}

// action_body: JSON object or legacy field syntax
// NEW: Supports JSON command syntax for runtime interpretation
// LEGACY: Also supports simple field: value syntax for compatibility
action_body = {
    json_action                                   // JSON command object
  | action_field ~ ("," ~ action_field)* ~ ","?  // Legacy: structured fields
  | action_code                                   // Legacy: direct Rust code
}

// JSON-based action commands
// Example: "call": "int_literal", "args": [...]
json_action = {
    json_field ~ ("," ~ json_field)* ~ ","?
}

json_field = {
    string_literal ~ ":" ~ json_value
}

json_value = {
    string_literal
  | json_number
  | json_bool
  | json_null
  | json_array
  | json_object
  | capture_ref_string  // "$1", "$name" as string
}

json_number = @{ "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
json_bool = { "true" | "false" }
json_null = { "null" }
json_array = { "[" ~ (json_value ~ ("," ~ json_value)*)? ~ ","? ~ "]" }
json_object = { "{" ~ (json_field ~ ("," ~ json_field)*)? ~ ","? ~ "}" }

// Capture reference in JSON context (as a string like "$1" or "$name")
capture_ref_string = ${ "\"$" ~ (ASCII_DIGIT+ | identifier) ~ "\"" }

// Legacy: Field assignment in action block - colon must NOT be followed by another colon (::)
action_field = {
    identifier ~ ":" ~ !(":") ~ rust_expr
}

// Legacy: Direct Rust code in action block (for match expressions, function calls, etc.)
action_code = { rust_action_inner+ }
rust_action_inner = {
    "{" ~ rust_action_inner* ~ "}"     // Nested braces
  | "(" ~ rust_action_inner* ~ ")"     // Nested parens
  | "[" ~ rust_action_inner* ~ "]"     // Nested brackets
  | !("{" | "}" | "(" | ")" | "[" | "]") ~ ANY
}

// ===== PEG Patterns (pest-compatible) =====

pattern = { choice }

choice = { sequence ~ ("|" ~ sequence)* }

sequence = { prefix ~ ("~" ~ prefix)* }

prefix = {
    ("!" | "&")? ~ postfix
}

postfix = {
    primary ~ ("*" | "+" | "?" | repeat)?
}

repeat = { "{" ~ integer ~ ("," ~ integer?)? ~ "}" }

primary = {
    "(" ~ pattern ~ ")"
  | string_literal
  | char_range
  | rule_ref
  | builtin_rule
}

rule_ref = { identifier }

builtin_rule = {
    "SOI" | "EOI" | "ANY"
  | "ASCII_DIGIT" | "ASCII_ALPHA" | "ASCII_ALPHANUMERIC"
  | "ASCII_HEX_DIGIT" | "ASCII_NONZERO_DIGIT"
  | "NEWLINE" | "WHITESPACE" | "COMMENT"
}

char_range = { "'" ~ char_inner ~ "'" ~ ".." ~ "'" ~ char_inner ~ "'" }
char_inner = { !("'" | "\\") ~ ANY | "\\" ~ ANY }

// ===== Rust Code Embedding =====

rust_code = { rust_code_inner* }
rust_code_inner = {
    !("{" | "}") ~ ANY
  | "{" ~ rust_code_inner* ~ "}"
}

rust_type = { rust_type_ref? ~ rust_type_segment ~ ("::" ~ rust_type_segment)* ~ rust_type_generics? }
rust_type_segment = @{ identifier }
rust_type_generics = { "<" ~ rust_type ~ ("," ~ rust_type)* ~ ">" }
rust_type_ref = { "&" ~ "mut"? }

rust_expr = { rust_expr_atom+ }
rust_expr_atom = {
    "{" ~ rust_expr_any* ~ "}"    // Balanced braces - consume everything inside
  | "(" ~ rust_expr_any* ~ ")"    // Balanced parens - consume everything inside
  | "[" ~ rust_expr_any* ~ "]"    // Balanced brackets - consume everything inside
  | !("," | "}") ~ ANY            // Anything else except field/block terminators
}
// Inside balanced delimiters, we can have commas and closing braces
rust_expr_any = {
    "{" ~ rust_expr_any* ~ "}"
  | "(" ~ rust_expr_any* ~ ")"
  | "[" ~ rust_expr_any* ~ "]"
  | !("{" | "}" | "(" | ")" | "[" | "]") ~ ANY
}

// ===== Capture References =====
// $1, $2, $name - references to pattern captures
capture_ref = { "$" ~ (integer | identifier) }

// ===== Lexical Elements =====

identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

string_literal = ${ "\"" ~ string_inner ~ "\"" }
string_inner = @{ (!("\"" | "\\") ~ ANY | "\\" ~ ANY)* }

integer = @{ ASCII_DIGIT+ }

// ===== Whitespace and Comments =====

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n"? | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
