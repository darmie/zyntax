// ZynPEG Grammar Definition
// This grammar parses .zyn files which extend pest PEG syntax with TypedAST action blocks

program = { SOI ~ directive* ~ rule_def* ~ EOI }

// ===== Directives =====

directive = {
    language_directive
  | imports_directive
  | context_directive
  | type_helpers_directive
  | error_messages_directive
  | builtin_directive
  | types_directive
}

// @language { name: "Zig", version: "0.11", file_extensions: [".zig", ".zyn"] }
language_directive = {
    "@language" ~ "{" ~ language_field ~ ("," ~ language_field)* ~ ","? ~ "}"
}

language_field = {
    "name" ~ ":" ~ string_literal
  | "version" ~ ":" ~ string_literal
  | "file_extensions" ~ ":" ~ "[" ~ string_literal ~ ("," ~ string_literal)* ~ "]"
  | "entry_point" ~ ":" ~ string_literal
}

// @imports { use zyntax_typed_ast::*; }
imports_directive = {
    "@imports" ~ "{" ~ rust_code ~ "}"
}

// @context { arena: &mut AstArena, type_registry: &mut TypeRegistry }
context_directive = {
    "@context" ~ "{" ~ context_field ~ ("," ~ context_field)* ~ ","? ~ "}"
}

context_field = {
    identifier ~ ":" ~ rust_type
}

// @type_helpers { fn infer_type(...) -> Type { ... } }
type_helpers_directive = {
    "@type_helpers" ~ "{" ~ rust_code ~ "}"
}

// @error_messages { type_mismatch(...) { message: "...", ... } }
error_messages_directive = {
    "@error_messages" ~ "{" ~ error_def* ~ "}"
}

error_def = {
    identifier ~ "(" ~ error_params? ~ ")" ~ "{" ~ error_field* ~ "}"
}

error_params = { identifier ~ ":" ~ rust_type ~ ("," ~ identifier ~ ":" ~ rust_type)* }

error_field = {
    "message" ~ ":" ~ (string_literal | format_expr)
  | "primary" ~ ":" ~ "(" ~ identifier ~ "," ~ (string_literal | format_expr) ~ ")"
  | "hints" ~ ":" ~ "[" ~ (string_literal | format_expr) ~ ("," ~ (string_literal | format_expr))* ~ "]"
}

format_expr = { "format!" ~ "(" ~ string_literal ~ ("," ~ rust_expr)* ~ ")" }

// @builtin { trace: "$haxe$trace$int", print: "$io$print" }
// Supports three types of mappings:
// - Functions (default): `println: "$IO$println"`
// - Methods (prefix @): `@sum: "tensor_sum"` transforms x.sum() -> tensor_sum(x)
// - Operators (prefix $): `$*: "vec_dot"` transforms x * y -> vec_dot(x, y)
builtin_directive = {
    "@builtin" ~ "{" ~ builtin_def* ~ "}"
}

builtin_def = {
    builtin_name ~ ":" ~ string_literal ~ ","?
}

// Builtin name can be: identifier, @identifier (method), or $op (operator)
builtin_name = @{
    "@" ~ identifier   // Method: @sum, @mean, @reshape
  | "$" ~ operator     // Operator: $*, $+, $-, $/, $==, $!=
  | identifier         // Function: println, tensor_sum
}

// Operators that can be overloaded
operator = @{
    "==" | "!=" | "<=" | ">=" | "&&" | "||"  // Multi-char first
  | "+" | "-" | "*" | "/" | "%" | "<" | ">" | "&" | "|" | "^" | "@"
}

// @types { opaque: [$Tensor, $Audio], returns: { tensor: $Tensor, audio_load: $Audio } }
// Declares opaque types and function return types for trait dispatch
types_directive = {
    "@types" ~ "{" ~ types_def* ~ "}"
}

types_def = {
    "opaque" ~ ":" ~ "[" ~ type_name ~ ("," ~ type_name)* ~ "]" ~ ","?
  | "returns" ~ ":" ~ "{" ~ return_def ~ ("," ~ return_def)* ~ ","? ~ "}" ~ ","?
}

return_def = { identifier ~ ":" ~ type_name }

type_name = @{ "$"? ~ identifier }

// ===== Rule Definitions =====

// rule_name = { pattern } -> Type { action }
rule_def = {
    identifier ~ "=" ~ rule_modifier? ~ "{" ~ pattern ~ "}" ~ action_block?
}

rule_modifier = { "@" | "!" | "$" | "_" }

// Action block: -> TypedExpression { fields } or -> binding_passthrough
// JSON-based action mappings that call host functions at runtime
action_block = {
    "->" ~ (
        // TypedAST construction: -> TypeName { fields } or -> Type::Variant { fields }
        type_path ~ "{" ~ action_body? ~ "}"
      | // Helper function call: -> intern(binding) or -> parse_int(text())
        identifier ~ "(" ~ action_args? ~ ")"
      | // Simple passthrough: -> binding_name (must come after function call)
        identifier
    )
}

// Type path with optional variant: TypedProgram or TypedDeclaration::Function or Type::Unit
type_path = { rust_type ~ ("::" ~ identifier)? }

// Arguments for helper function calls in actions
action_args = { action_arg ~ ("," ~ action_arg)* }
action_arg = {
    identifier ~ "(" ~ action_args? ~ ")"  // Nested function call: intern(name)
  | identifier                              // Binding reference: name
  | string_literal                          // String literal: "hello"
}

// action_body: JSON object or legacy field syntax
// NEW: Supports JSON command syntax for runtime interpretation
// LEGACY: Also supports simple field: value syntax for compatibility
action_body = {
    json_action                                   // JSON command object
  | action_field ~ ("," ~ action_field)* ~ ","?  // Legacy: structured fields
  | action_code                                   // Legacy: direct Rust code
}

// JSON-based action commands
// Example: "call": "int_literal", "args": [...]
json_action = {
    json_field ~ ("," ~ json_field)* ~ ","?
}

json_field = {
    string_literal ~ ":" ~ json_value
}

json_value = {
    string_literal
  | json_number
  | json_bool
  | json_null
  | json_array
  | json_object
  | capture_ref_string  // "$1", "$name" as string
}

json_number = @{ "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
json_bool = { "true" | "false" }
json_null = { "null" }
json_array = { "[" ~ (json_value ~ ("," ~ json_value)*)? ~ ","? ~ "]" }
json_object = { "{" ~ (json_field ~ ("," ~ json_field)*)? ~ ","? ~ "}" }

// Capture reference in JSON context (as a string like "$1" or "$name")
capture_ref_string = ${ "\"$" ~ (ASCII_DIGIT+ | identifier) ~ "\"" }

// Legacy: Field assignment in action block - colon must NOT be followed by another colon (::)
action_field = {
    identifier ~ ":" ~ !(":") ~ rust_expr
}

// Legacy: Direct Rust code in action block (for match expressions, function calls, etc.)
action_code = { rust_action_inner+ }
rust_action_inner = {
    "{" ~ rust_action_inner* ~ "}"     // Nested braces
  | "(" ~ rust_action_inner* ~ ")"     // Nested parens
  | "[" ~ rust_action_inner* ~ "]"     // Nested brackets
  | !("{" | "}" | "(" | ")" | "[" | "]") ~ ANY
}

// ===== PEG Patterns (pest-compatible) =====

pattern = { choice }

choice = { sequence ~ ("|" ~ sequence)* }

sequence = { prefix ~ ("~" ~ prefix)* }

prefix = {
    ("!" | "&")? ~ postfix
}

postfix = {
    primary ~ repeat_modifier?
}

// Repeat modifiers: *, +, ?, or {n} / {n,m}
repeat_modifier = { "*" | "+" | "?" | repeat }

repeat = { "{" ~ integer ~ ("," ~ integer?)? ~ "}" }

primary = {
    "(" ~ pattern ~ ")"
  | string_literal
  | char_range
  | named_rule_ref
  | rule_ref
  | builtin_rule
}

// Named binding: name:identifier or name:identifier* etc.
// The binding applies to the whole expression including repeat modifier
named_rule_ref = { identifier ~ ":" ~ identifier ~ repeat_modifier? }

rule_ref = { identifier }

builtin_rule = {
    "SOI" | "EOI" | "ANY"
  | "ASCII_DIGIT" | "ASCII_ALPHA" | "ASCII_ALPHANUMERIC"
  | "ASCII_HEX_DIGIT" | "ASCII_NONZERO_DIGIT"
  | "NEWLINE" | "WHITESPACE" | "COMMENT"
}

char_range = { "'" ~ char_inner ~ "'" ~ ".." ~ "'" ~ char_inner ~ "'" }
char_inner = { !("'" | "\\") ~ ANY | "\\" ~ ANY }

// ===== Rust Code Embedding =====

rust_code = { rust_code_inner* }
rust_code_inner = {
    !("{" | "}") ~ ANY
  | "{" ~ rust_code_inner* ~ "}"
}

rust_type = { rust_type_ref? ~ rust_type_segment ~ ("::" ~ rust_type_segment)* ~ rust_type_generics? }
rust_type_segment = @{ identifier }
rust_type_generics = { "<" ~ rust_type ~ ("," ~ rust_type)* ~ ">" }
rust_type_ref = { "&" ~ "mut"? }

rust_expr = { rust_expr_atom+ }
rust_expr_atom = {
    "{" ~ rust_expr_any* ~ "}"    // Balanced braces - consume everything inside
  | "(" ~ rust_expr_any* ~ ")"    // Balanced parens - consume everything inside
  | "[" ~ rust_expr_any* ~ "]"    // Balanced brackets - consume everything inside
  | !("," | "}") ~ ANY            // Anything else except field/block terminators
}
// Inside balanced delimiters, we can have commas and closing braces
rust_expr_any = {
    "{" ~ rust_expr_any* ~ "}"
  | "(" ~ rust_expr_any* ~ ")"
  | "[" ~ rust_expr_any* ~ "]"
  | !("{" | "}" | "(" | ")" | "[" | "]") ~ ANY
}

// ===== Capture References =====
// $1, $2, $name - references to pattern captures
capture_ref = { "$" ~ (integer | identifier) }

// ===== Lexical Elements =====

identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

string_literal = ${ "\"" ~ string_inner ~ "\"" }
string_inner = @{ (!("\"" | "\\") ~ ANY | "\\" ~ ANY)* }

integer = @{ ASCII_DIGIT+ }

// ===== Whitespace and Comments =====

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n"? | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
