// Generated by ZynPEG from zig.zyn

program = { SOI ~ declarations ~ EOI  }
declarations = { declaration*  }
declaration = { struct_decl | enum_decl | extern_fn_decl | fn_decl | const_decl | var_decl  }
struct_decl = { "const" ~ identifier ~ "=" ~ "struct" ~ "{" ~ struct_fields? ~ "}" ~ ";"  }
struct_fields = { struct_field ~ ("," ~ struct_field)* ~ ","?  }
struct_field = { identifier ~ ":" ~ type_expr  }
enum_decl = { "const" ~ identifier ~ "=" ~ "enum" ~ "{" ~ enum_variants? ~ "}" ~ ";"  }
enum_variants = { enum_variant ~ ("," ~ enum_variant)* ~ ","?  }
enum_variant = { identifier  }
extern_fn_decl = { extern_fn_decl_with_params | extern_fn_decl_no_params  }
extern_fn_decl_with_params = { "extern" ~ "fn" ~ identifier ~ "(" ~ fn_params ~ ")" ~ type_expr ~ ";"  }
extern_fn_decl_no_params = { "extern" ~ "fn" ~ identifier ~ "(" ~ ")" ~ type_expr ~ ";"  }
fn_decl = { async_fn_decl | sync_fn_decl  }
sync_fn_decl = { fn_decl_with_params | fn_decl_no_params  }
async_fn_decl = { async_fn_decl_with_params | async_fn_decl_no_params  }
async_fn_decl_with_params = { "async" ~ "fn" ~ identifier ~ "(" ~ fn_params ~ ")" ~ type_expr ~ block  }
async_fn_decl_no_params = { "async" ~ "fn" ~ identifier ~ "(" ~ ")" ~ type_expr ~ block  }
fn_decl_with_params = { "fn" ~ identifier ~ "(" ~ fn_params ~ ")" ~ type_expr ~ block  }
fn_decl_no_params = { "fn" ~ identifier ~ "(" ~ ")" ~ type_expr ~ block  }
fn_params = { fn_param_any ~ ("," ~ fn_param_any)*  }
fn_param_any = { comptime_param | fn_param  }
comptime_param = { "comptime" ~ identifier ~ ":" ~ type_expr  }
fn_param = { identifier ~ ":" ~ type_expr  }
const_decl = { const_decl_typed | const_decl_untyped  }
const_decl_typed = { "const" ~ identifier ~ ":" ~ type_expr ~ "=" ~ expr ~ ";"  }
const_decl_untyped = { "const" ~ identifier ~ "=" ~ expr ~ ";"  }
var_decl = { var_decl_typed | var_decl_untyped  }
var_decl_typed = { "var" ~ identifier ~ ":" ~ type_expr ~ "=" ~ expr ~ ";"  }
var_decl_untyped = { "var" ~ identifier ~ "=" ~ expr ~ ";"  }
type_expr = { pointer_type | optional_type | error_union_type | array_type | primitive_type | identifier  }
pointer_type = { "*" ~ "const"? ~ type_expr  }
optional_type = { "?" ~ type_expr  }
error_union_type = { "!" ~ type_expr  }
array_type = { "[" ~ integer_literal? ~ "]" ~ type_expr  }
primitive_type = { "i8" | "i16" | "i32" | "i64" | "u8" | "u16" | "u32" | "u64" | "f32" | "f64" | "bool" | "void" | "type"  }
statement = { if_stmt | while_stmt | for_stmt | return_stmt | break_stmt | continue_stmt | local_const | local_var | assign_stmt | expr_stmt  }
break_stmt = { "break" ~ ";"  }
continue_stmt = { "continue" ~ ";"  }
if_stmt = { if_else | if_only  }
if_only = { "if" ~ "(" ~ expr ~ ")" ~ block  }
if_else = { "if" ~ "(" ~ expr ~ ")" ~ block ~ "else" ~ block  }
while_stmt = { "while" ~ "(" ~ expr ~ ")" ~ block  }
for_stmt = { "for" ~ "(" ~ expr ~ ")" ~ "|" ~ identifier ~ "|" ~ block  }
assign_stmt = { identifier ~ "=" ~ expr ~ ";"  }
return_stmt = { "return" ~ expr? ~ ";"  }
local_const = { local_const_typed | local_const_untyped  }
local_const_typed = { "const" ~ identifier ~ ":" ~ type_expr ~ "=" ~ expr ~ ";"  }
local_const_untyped = { "const" ~ identifier ~ "=" ~ expr ~ ";"  }
local_var = { local_var_typed | local_var_untyped  }
local_var_typed = { "var" ~ identifier ~ ":" ~ type_expr ~ "=" ~ expr ~ ";"  }
local_var_untyped = { "var" ~ identifier ~ "=" ~ expr ~ ";"  }
expr_stmt = { expr ~ ";"  }
block = { "{" ~ statement* ~ "}"  }
expr = { logical_or  }
logical_or = { logical_and ~ (or_op ~ logical_and)*  }
logical_and = { comparison ~ (and_op ~ comparison)*  }
comparison = { addition ~ ((eq_op | neq_op | lte_op | gte_op | lt_op | gt_op) ~ addition)*  }
addition = { multiplication ~ ((add_op | sub_op) ~ multiplication)*  }
multiplication = { unary ~ ((mul_op | div_op) ~ unary)*  }
unary = { unary_with_op | primary  }
unary_with_op = { unary_op ~ primary  }
primary = { postfix_expr  }
postfix_expr = { call_expr | field_expr | index_expr | atom  }
call_expr = { atom ~ "(" ~ call_args? ~ ")"  }
field_expr = { atom ~ "." ~ identifier  }
index_expr = { atom ~ "[" ~ expr ~ "]"  }
call_args = { expr ~ ("," ~ expr)*  }
atom = { switch_expr | try_expr | await_expr | struct_init | array_literal | bool_literal | string_literal | integer_literal | type_value | identifier_expr | paren_expr  }
switch_expr = { "switch" ~ "(" ~ expr ~ ")" ~ "{" ~ switch_cases? ~ "}"  }
switch_cases = { switch_case ~ ("," ~ switch_case)* ~ ","?  }
switch_case = { switch_case_value | switch_case_else  }
switch_case_value = { switch_pattern ~ "=>" ~ expr  }
switch_case_else = { "else" ~ "=>" ~ expr  }
switch_pattern = { switch_or_pattern  }
switch_or_pattern = { switch_primary_pattern ~ ("|" ~ switch_primary_pattern)*  }
switch_primary_pattern = { switch_struct_pattern | switch_tagged_union_pattern | switch_error_pattern | switch_pointer_pattern | switch_range_pattern | switch_array_pattern | switch_literal_pattern | switch_wildcard_pattern | switch_identifier_pattern  }
switch_range_pattern = { switch_simple_literal ~ ".." ~ switch_simple_literal  }
switch_array_pattern = { ".{" ~ switch_array_elements? ~ "}"  }
switch_array_elements = { switch_pattern ~ ("," ~ switch_pattern)* ~ ","?  }
switch_literal_pattern = { switch_simple_literal  }
switch_simple_literal = { integer_literal | string_literal  }
switch_wildcard_pattern = { "_"  }
switch_identifier_pattern = { identifier  }
switch_struct_pattern = { identifier ~ "{" ~ switch_struct_field_patterns? ~ "}"  }
switch_struct_field_patterns = { switch_struct_field_pattern ~ ("," ~ switch_struct_field_pattern)* ~ ","?  }
switch_struct_field_pattern = { "." ~ identifier ~ ("=" ~ switch_pattern)?  }
switch_tagged_union_pattern = { "." ~ identifier  }
switch_error_pattern = { "error" ~ "." ~ identifier  }
switch_pointer_pattern = { "*" ~ switch_primary_pattern  }
type_value = { type_expr_as_value  }
type_expr_as_value = { primitive_type  }
struct_init = { identifier ~ "{" ~ struct_init_fields? ~ "}"  }
struct_init_fields = { struct_init_field ~ ("," ~ struct_init_field)* ~ ","?  }
struct_init_field = { "." ~ identifier ~ "=" ~ expr  }
try_expr = { "try" ~ primary  }
await_expr = { "await" ~ primary  }
paren_expr = _{ "(" ~ expr ~ ")"  }
array_literal = { "[" ~ array_elements? ~ "]"  }
array_elements = { expr ~ ("," ~ expr)*  }
identifier_expr = { identifier  }
bool_literal = { "true" | "false"  }
integer_literal = @{ "-"? ~ ASCII_DIGIT+  }
string_literal = @{ "\"" ~ string_inner* ~ "\""  }
string_inner = { (!("\"" | "\\") ~ ANY) | escape_seq  }
escape_seq = { "\\" ~ ("n" | "r" | "t" | "\\" | "\"" | "0")  }
keyword = @{ ("struct" | "enum" | "fn" | "const" | "var" | "if" | "else" | "while" | "for" |
     "return" | "break" | "continue" | "try" | "await" | "async" | "and" | "or" | "true" | "false" |
     "comptime" | "type" | "switch" |
     "i8" | "i16" | "i32" | "i64" | "u8" | "u16" | "u32" | "u64" | "f32" | "f64" | "bool" | "void")
    ~ !(ASCII_ALPHANUMERIC | "_")
 }
identifier = @{ !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")*  }
and_op = { "and"  }
or_op = { "or"  }
eq_op = { "=="  }
neq_op = { "!="  }
lte_op = { "<="  }
gte_op = { ">="  }
lt_op = { "<"  }
gt_op = { ">"  }
add_op = { "+"  }
sub_op = { "-"  }
mul_op = { "*"  }
div_op = { "/"  }
unary_op = { "-" | "!"  }
WHITESPACE = _{ " " | "\t" | "\n" | "\r"  }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n"?  }