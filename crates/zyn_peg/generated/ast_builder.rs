#![doc = r" Generated AST builder for zyntax_typed_ast"]
#![doc = r""]
#![doc = r" This file is auto-generated by ZynPEG. Do not edit manually."]
#![doc = r" Uses zyntax_typed_ast types for JIT compilation compatibility."]
#![allow(dead_code, unused_variables, unused_imports, unused_mut)]
use super::Rule;
use zyntax_typed_ast::{
    typed_node, AsyncKind, BinaryOp, CallingConvention, ConstValue, InternedString, Mutability,
    NullabilityKind, ParameterKind, PrimitiveType, Span, Type, TypeId, TypedBinary, TypedBlock,
    TypedCall, TypedCast, TypedClass, TypedDeclaration, TypedDefer, TypedEnum, TypedExpression,
    TypedField, TypedFieldAccess, TypedFieldInit, TypedFor, TypedFunction, TypedIf, TypedIfExpr,
    TypedIndex, TypedLambda, TypedLambdaBody, TypedLet, TypedLiteral, TypedLiteralPattern,
    TypedMatch, TypedMatchArm, TypedMatchExpr, TypedMethodCall, TypedNode, TypedParameter,
    TypedPattern, TypedProgram, TypedRange, TypedReference, TypedStatement, TypedStructLiteral,
    TypedTypeParam, TypedUnary, TypedVariable, TypedVariant, TypedWhile, UnaryOp, Variance,
    Visibility,
};
#[doc = r" Postfix operation for expression building"]
#[derive(Debug, Clone)]
pub enum PostfixOp {
    Deref,
    Field(InternedString),
    Index(TypedNode<TypedExpression>),
    Call(Vec<TypedNode<TypedExpression>>),
    OptionalUnwrap,
    TryUnwrap,
}
#[doc = r" Parse error type"]
#[derive(Debug)]
pub struct ParseError(pub String);
impl std::fmt::Display for ParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}
impl std::error::Error for ParseError {}
impl<R: pest::RuleType> From<pest::error::Error<R>> for ParseError {
    fn from(e: pest::error::Error<R>) -> Self {
        ParseError(e.to_string())
    }
}
#[doc = r" Helper: Create Span from pest span"]
fn span_from_pest(pest_span: pest::Span) -> Span {
    Span::new(pest_span.start(), pest_span.end())
}
#[doc = r" Helper: Intern a string using the global interner"]
fn intern(s: &str) -> InternedString {
    InternedString::new_global(s)
}
#[doc = r" Helper: Parse primitive type from string"]
fn parse_primitive_type(s: &str) -> Type {
    match s {
        "i8" => Type::Primitive(PrimitiveType::I8),
        "i16" => Type::Primitive(PrimitiveType::I16),
        "i32" => Type::Primitive(PrimitiveType::I32),
        "i64" => Type::Primitive(PrimitiveType::I64),
        "i128" => Type::Primitive(PrimitiveType::I128),
        "u8" => Type::Primitive(PrimitiveType::U8),
        "u16" => Type::Primitive(PrimitiveType::U16),
        "u32" => Type::Primitive(PrimitiveType::U32),
        "u64" => Type::Primitive(PrimitiveType::U64),
        "u128" => Type::Primitive(PrimitiveType::U128),
        "f32" => Type::Primitive(PrimitiveType::F32),
        "f64" => Type::Primitive(PrimitiveType::F64),
        "bool" => Type::Primitive(PrimitiveType::Bool),
        "char" => Type::Primitive(PrimitiveType::Char),
        "void" | "()" => Type::Primitive(PrimitiveType::Unit),
        "usize" => Type::Primitive(PrimitiveType::USize),
        "isize" => Type::Primitive(PrimitiveType::ISize),
        _ => Type::Never,
    }
}
#[doc = r" TypedAST builder context"]
pub struct AstBuilderContext;
impl AstBuilderContext {
    pub fn new() -> Self {
        Self
    }
    pub fn build_program(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<decls, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_decls_declarations = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::decls_declarations)
            .cloned();
        Ok(decls::default())
    }
    pub fn build_declarations(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedProgram, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_decl_declaration: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::decl_declaration)
            .cloned()
            .collect();
        Ok(TypedProgram { declarations: decl })
    }
    pub fn build_struct_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration::Class, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        let child_fields_struct_field_list = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::fields_struct_field_list)
            .cloned();
        Ok(TypedDeclaration::Class {
            name: InternedString::new_global(name),
            fields: fields,
            type_params: [],
        })
    }
    pub fn build_struct_field_list(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<f, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_f_struct_field: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::f_struct_field)
            .cloned()
            .collect();
        Ok(f::default())
    }
    pub fn build_struct_field(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedField, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        let child_ty_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::ty_type_expr)
            .cloned();
        Ok(TypedField {
            name: InternedString::new_global(name),
            ty: ty,
        })
    }
    pub fn build_enum_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration::Enum, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        let child_variants_enum_variant_list = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::variants_enum_variant_list)
            .cloned();
        Ok(TypedDeclaration::Enum {
            name: InternedString::new_global(name),
            variants: variants,
            type_params: [],
        })
    }
    pub fn build_enum_variant_list(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<v, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_v_enum_variant: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::v_enum_variant)
            .cloned()
            .collect();
        Ok(v::default())
    }
    pub fn build_enum_variant(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedVariant, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        Ok(TypedVariant {
            name: InternedString::new_global(name),
            fields: TypedVariantFields::Unit,
        })
    }
    pub fn build_extern_fn_decl_with_params(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration::Function, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        let child_params_fn_param_list = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::params_fn_param_list)
            .cloned();
        let child_ret_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::ret_type_expr)
            .cloned();
        Ok(TypedDeclaration::Function {
            name: InternedString::new_global(name),
            params: params,
            return_type: ret,
            body: None,
            is_extern: true,
        })
    }
    pub fn build_extern_fn_decl_no_params(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration::Function, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        let child_ret_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::ret_type_expr)
            .cloned();
        Ok(TypedDeclaration::Function {
            name: InternedString::new_global(name),
            params: [],
            return_type: ret,
            body: None,
            is_extern: true,
        })
    }
    pub fn build_async_fn_decl_with_params(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration::Function, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        let child_params_fn_param_list = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::params_fn_param_list)
            .cloned();
        let child_ret_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::ret_type_expr)
            .cloned();
        let child_body_block = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::body_block)
            .cloned();
        Ok(TypedDeclaration::Function {
            name: InternedString::new_global(name),
            params: params,
            return_type: ret,
            body: Some(body),
            is_async: true,
        })
    }
    pub fn build_async_fn_decl_no_params(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration::Function, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        let child_ret_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::ret_type_expr)
            .cloned();
        let child_body_block = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::body_block)
            .cloned();
        Ok(TypedDeclaration::Function {
            name: InternedString::new_global(name),
            params: [],
            return_type: ret,
            body: Some(body),
            is_async: true,
        })
    }
    pub fn build_fn_decl_with_params(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration::Function, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        let child_params_fn_param_list = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::params_fn_param_list)
            .cloned();
        let child_ret_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::ret_type_expr)
            .cloned();
        let child_body_block = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::body_block)
            .cloned();
        Ok(TypedDeclaration::Function {
            name: InternedString::new_global(name),
            params: params,
            return_type: ret,
            body: Some(body),
        })
    }
    pub fn build_fn_decl_no_params(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration::Function, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        let child_ret_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::ret_type_expr)
            .cloned();
        let child_body_block = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::body_block)
            .cloned();
        Ok(TypedDeclaration::Function {
            name: InternedString::new_global(name),
            params: [],
            return_type: ret,
            body: Some(body),
        })
    }
    pub fn build_fn_param_list(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<p, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_p_fn_param_item: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::p_fn_param_item)
            .cloned()
            .collect();
        Ok(p::default())
    }
    pub fn build_fn_param_item(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<fn_param_any, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_fn_param_any = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::fn_param_any)
            .cloned();
        Ok(fn_param_any::default())
    }
    pub fn build_comptime_param(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedParameter, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        let child_ty_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::ty_type_expr)
            .cloned();
        Ok(TypedParameter {
            name: InternedString::new_global(name),
            ty: ty,
            kind: ParameterKind::Comptime,
        })
    }
    pub fn build_fn_param(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedParameter, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        let child_ty_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::ty_type_expr)
            .cloned();
        Ok(TypedParameter {
            name: InternedString::new_global(name),
            ty: ty,
        })
    }
    pub fn build_const_decl_typed(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration::Variable, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        let child_ty_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::ty_type_expr)
            .cloned();
        let child_init_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::init_expr)
            .cloned();
        Ok(TypedDeclaration::Variable {
            name: InternedString::new_global(name),
            ty: ty,
            initializer: Some(init),
            mutability: Mutability::Immutable,
        })
    }
    pub fn build_const_decl_untyped(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration::Variable, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        let child_init_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::init_expr)
            .cloned();
        Ok(TypedDeclaration::Variable {
            name: InternedString::new_global(name),
            initializer: Some(init),
            mutability: Mutability::Immutable,
        })
    }
    pub fn build_var_decl_typed(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration::Variable, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        let child_ty_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::ty_type_expr)
            .cloned();
        let child_init_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::init_expr)
            .cloned();
        Ok(TypedDeclaration::Variable {
            name: InternedString::new_global(name),
            ty: ty,
            initializer: Some(init),
            mutability: Mutability::Mutable,
        })
    }
    pub fn build_var_decl_untyped(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration::Variable, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        let child_init_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::init_expr)
            .cloned();
        Ok(TypedDeclaration::Variable {
            name: InternedString::new_global(name),
            initializer: Some(init),
            mutability: Mutability::Mutable,
        })
    }
    pub fn build_pointer_type(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Type::Pointer, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_inner_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::inner_type_expr)
            .cloned();
        Ok(Type::Pointer { pointee: inner })
    }
    pub fn build_optional_type(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Type::Optional, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_inner_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::inner_type_expr)
            .cloned();
        Ok(Type::Optional { inner: inner })
    }
    pub fn build_error_union_type(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Type::ErrorUnion, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_inner_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::inner_type_expr)
            .cloned();
        Ok(Type::ErrorUnion { payload: inner })
    }
    pub fn build_array_type(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Type::Array, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_size_integer_literal = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::size_integer_literal)
            .cloned();
        let child_element_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::element_type_expr)
            .cloned();
        Ok(Type::Array {
            element: element,
            size: size,
        })
    }
    pub fn build_primitive_type(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Type::Primitive, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok(Type::Primitive {
            name: InternedString::new_global(text),
        })
    }
    pub fn build_named_type(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Type::Named, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        Ok(Type::Named {
            name: InternedString::new_global(name),
        })
    }
    pub fn build_break_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement::Break, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok(TypedStatement::Break { value: None })
    }
    pub fn build_continue_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement::Continue, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok(TypedStatement::Continue::default())
    }
    pub fn build_if_only(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement::If, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_cond_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::cond_expr)
            .cloned();
        let child_then_block_block = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::then_block_block)
            .cloned();
        Ok(TypedStatement::If {
            condition: cond,
            then_block: then_block,
            else_block: None,
        })
    }
    pub fn build_if_else(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement::If, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_cond_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::cond_expr)
            .cloned();
        let child_then_block_block = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::then_block_block)
            .cloned();
        let child_else_block_block = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::else_block_block)
            .cloned();
        Ok(TypedStatement::If {
            condition: cond,
            then_block: then_block,
            else_block: Some(else_block),
        })
    }
    pub fn build_while_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement::While, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_cond_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::cond_expr)
            .cloned();
        let child_body_block = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::body_block)
            .cloned();
        Ok(TypedStatement::While {
            condition: cond,
            body: body,
        })
    }
    pub fn build_for_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement::For, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_iter_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::iter_expr)
            .cloned();
        Ok(TypedStatement::For {
            variable: InternedString::new_global(binding),
            iterable: iter,
            body: body,
        })
    }
    pub fn build_assign_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement::Assignment, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_target_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::target_identifier)
            .cloned();
        let child_value_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::value_expr)
            .cloned();
        Ok(TypedStatement::Assignment {
            target: InternedString::new_global(target),
            value: value,
        })
    }
    pub fn build_return_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement::Return, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_value_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::value_expr)
            .cloned();
        Ok(TypedStatement::Return { value: value })
    }
    pub fn build_local_const_typed(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement::Let, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        let child_ty_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::ty_type_expr)
            .cloned();
        let child_init_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::init_expr)
            .cloned();
        Ok(TypedStatement::Let {
            name: InternedString::new_global(name),
            type_annotation: Some(ty),
            initializer: Some(init),
            is_mutable: false,
        })
    }
    pub fn build_local_const_untyped(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement::Let, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        let child_init_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::init_expr)
            .cloned();
        Ok(TypedStatement::Let {
            name: InternedString::new_global(name),
            initializer: Some(init),
            is_mutable: false,
        })
    }
    pub fn build_local_var_typed(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement::Let, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        let child_ty_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::ty_type_expr)
            .cloned();
        let child_init_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::init_expr)
            .cloned();
        Ok(TypedStatement::Let {
            name: InternedString::new_global(name),
            type_annotation: Some(ty),
            initializer: Some(init),
            is_mutable: true,
        })
    }
    pub fn build_local_var_untyped(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement::Let, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        let child_init_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::init_expr)
            .cloned();
        Ok(TypedStatement::Let {
            name: InternedString::new_global(name),
            initializer: Some(init),
            is_mutable: true,
        })
    }
    pub fn build_expr_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement::Expression, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_e_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::e_expr)
            .cloned();
        Ok(TypedStatement::Expression { expr: e })
    }
    pub fn build_block(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedBlock, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_stmts_statement: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::stmts_statement)
            .cloned()
            .collect();
        Ok(TypedBlock { statements: stmts })
    }
    pub fn build_expr(&mut self, pair: pest::iterators::Pair<Rule>) -> Result<e, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_e_comparison_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::e_comparison_expr)
            .cloned();
        Ok(e::default())
    }
    pub fn build_comparison_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<left, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_left_add_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::left_add_expr)
            .cloned();
        let child_op_comparison_op = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::op_comparison_op)
            .cloned();
        Ok(left::default())
    }
    pub fn build_add_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<left, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_left_mul_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::left_mul_expr)
            .cloned();
        let child_op_add_op = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::op_add_op)
            .cloned();
        Ok(left::default())
    }
    pub fn build_mul_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<left, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_left_unary_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::left_unary_expr)
            .cloned();
        let child_op_mul_op = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::op_mul_op)
            .cloned();
        Ok(left::default())
    }
    pub fn build_unary_with_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression::Unary, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_op_unary_op = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::op_unary_op)
            .cloned();
        let child_operand_primary = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::operand_primary)
            .cloned();
        Ok(TypedExpression::Unary {
            op: op,
            operand: operand,
        })
    }
    pub fn build_call_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression::Call, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_callee_atom = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::callee_atom)
            .cloned();
        let child_args_call_arg_list = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::args_call_arg_list)
            .cloned();
        Ok(TypedExpression::Call {
            callee: callee,
            args: args,
        })
    }
    pub fn build_call_arg_list(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<a, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_a_call_arg: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::a_call_arg)
            .cloned()
            .collect();
        Ok(a::default())
    }
    pub fn build_call_arg(&mut self, pair: pest::iterators::Pair<Rule>) -> Result<e, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_e_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::e_expr)
            .cloned();
        Ok(e::default())
    }
    pub fn build_field_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression::FieldAccess, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_object_atom = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::object_atom)
            .cloned();
        let child_field_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::field_identifier)
            .cloned();
        Ok(TypedExpression::FieldAccess {
            object: object,
            field: InternedString::new_global(field),
        })
    }
    pub fn build_index_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression::Index, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_object_atom = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::object_atom)
            .cloned();
        let child_index_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::index_expr)
            .cloned();
        Ok(TypedExpression::Index {
            object: object,
            index: index,
        })
    }
    pub fn build_try_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression::Try, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_e_primary = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::e_primary)
            .cloned();
        Ok(TypedExpression::Try { expr: e })
    }
    pub fn build_await_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression::Await, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_e_primary = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::e_primary)
            .cloned();
        Ok(TypedExpression::Await { expr: e })
    }
    pub fn build_struct_init(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression::StructLiteral, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_type_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_name_identifier)
            .cloned();
        let child_fields_struct_init_field_list = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::fields_struct_init_field_list)
            .cloned();
        Ok(TypedExpression::StructLiteral {
            type_name: InternedString::new_global(type_name),
            fields: fields,
        })
    }
    pub fn build_struct_init_field_list(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<f, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_f_struct_init_field: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::f_struct_init_field)
            .cloned()
            .collect();
        Ok(f::default())
    }
    pub fn build_struct_init_field(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedFieldInit, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        let child_value_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::value_expr)
            .cloned();
        Ok(TypedFieldInit {
            name: InternedString::new_global(name),
            value: value,
        })
    }
    pub fn build_array_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression::Array, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_elements_array_element_list = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::elements_array_element_list)
            .cloned();
        Ok(TypedExpression::Array { elements: elements })
    }
    pub fn build_array_element_list(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<e, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_e_array_element: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::e_array_element)
            .cloned()
            .collect();
        Ok(e::default())
    }
    pub fn build_array_element(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<v, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_v_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::v_expr)
            .cloned();
        Ok(v::default())
    }
    pub fn build_identifier_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression::Variable, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_name_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::name_identifier)
            .cloned();
        Ok(TypedExpression::Variable {
            name: InternedString::new_global(name),
        })
    }
    pub fn build_bool_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression::Literal, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok(TypedExpression::Literal {
            value: TypedLiteral::Bool { value: text },
        })
    }
    pub fn build_integer_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression::Literal, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok(TypedExpression::Literal {
            value: TypedLiteral::Int {
                value: parse_int(text),
            },
        })
    }
    pub fn build_string_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression::Literal, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_string_inner: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::string_inner)
            .cloned()
            .collect();
        Ok(TypedExpression::Literal {
            value: TypedLiteral::String {
                value: InternedString::new_global(text),
            },
        })
    }
    pub fn build_declaration(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration::Class, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::struct_decl => self.build_struct_decl(inner),
                Rule::enum_decl => self.build_enum_decl(inner),
                Rule::extern_fn_decl => self.build_extern_fn_decl(inner),
                Rule::fn_decl => self.build_fn_decl(inner),
                Rule::const_decl => self.build_const_decl(inner),
                Rule::var_decl => self.build_var_decl(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_declaration),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_declaration)
            )))
        }
    }
    pub fn build_extern_fn_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration::Function, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::extern_fn_decl_with_params => self.build_extern_fn_decl_with_params(inner),
                Rule::extern_fn_decl_no_params => self.build_extern_fn_decl_no_params(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_extern_fn_decl),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_extern_fn_decl)
            )))
        }
    }
    pub fn build_fn_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::async_fn_decl => self.build_async_fn_decl(inner),
                Rule::sync_fn_decl => self.build_sync_fn_decl(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_fn_decl),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_fn_decl)
            )))
        }
    }
    pub fn build_sync_fn_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration::Function, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::fn_decl_with_params => self.build_fn_decl_with_params(inner),
                Rule::fn_decl_no_params => self.build_fn_decl_no_params(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_sync_fn_decl),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_sync_fn_decl)
            )))
        }
    }
    pub fn build_async_fn_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration::Function, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::async_fn_decl_with_params => self.build_async_fn_decl_with_params(inner),
                Rule::async_fn_decl_no_params => self.build_async_fn_decl_no_params(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_async_fn_decl),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_async_fn_decl)
            )))
        }
    }
    pub fn build_fn_param_any(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedParameter, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::comptime_param => self.build_comptime_param(inner),
                Rule::fn_param => self.build_fn_param(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_fn_param_any),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_fn_param_any)
            )))
        }
    }
    pub fn build_const_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration::Variable, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::const_decl_typed => self.build_const_decl_typed(inner),
                Rule::const_decl_untyped => self.build_const_decl_untyped(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_const_decl),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_const_decl)
            )))
        }
    }
    pub fn build_var_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration::Variable, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::var_decl_typed => self.build_var_decl_typed(inner),
                Rule::var_decl_untyped => self.build_var_decl_untyped(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_var_decl),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_var_decl)
            )))
        }
    }
    pub fn build_type_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Type::Pointer, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::pointer_type => self.build_pointer_type(inner),
                Rule::optional_type => self.build_optional_type(inner),
                Rule::error_union_type => self.build_error_union_type(inner),
                Rule::array_type => self.build_array_type(inner),
                Rule::primitive_type => self.build_primitive_type(inner),
                Rule::named_type => self.build_named_type(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_type_expr),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_type_expr)
            )))
        }
    }
    pub fn build_statement(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement::While, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::if_stmt => self.build_if_stmt(inner),
                Rule::while_stmt => self.build_while_stmt(inner),
                Rule::for_stmt => self.build_for_stmt(inner),
                Rule::return_stmt => self.build_return_stmt(inner),
                Rule::break_stmt => self.build_break_stmt(inner),
                Rule::continue_stmt => self.build_continue_stmt(inner),
                Rule::local_const => self.build_local_const(inner),
                Rule::local_var => self.build_local_var(inner),
                Rule::assign_stmt => self.build_assign_stmt(inner),
                Rule::expr_stmt => self.build_expr_stmt(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_statement),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_statement)
            )))
        }
    }
    pub fn build_if_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement::If, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::if_else => self.build_if_else(inner),
                Rule::if_only => self.build_if_only(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_if_stmt),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_if_stmt)
            )))
        }
    }
    pub fn build_local_const(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement::Let, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::local_const_typed => self.build_local_const_typed(inner),
                Rule::local_const_untyped => self.build_local_const_untyped(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_local_const),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_local_const)
            )))
        }
    }
    pub fn build_local_var(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement::Let, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::local_var_typed => self.build_local_var_typed(inner),
                Rule::local_var_untyped => self.build_local_var_untyped(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_local_var),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_local_var)
            )))
        }
    }
    pub fn build_unary_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression::Unary, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::unary_with_op => self.build_unary_with_op(inner),
                Rule::primary => self.build_primary(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_unary_expr),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_unary_expr)
            )))
        }
    }
    pub fn build_unary_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i128>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Integer(n)),
                Type::Primitive(PrimitiveType::I64),
                span,
            ));
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Float(n)),
                Type::Primitive(PrimitiveType::F64),
                span,
            ));
        }
        if text == "true" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(true)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        if text == "false" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(false)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        Ok(typed_node(
            TypedExpression::Variable(intern(text)),
            Type::Never,
            span,
        ))
    }
    pub fn build_primary(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::postfix_expr => self.build_postfix_expr(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_primary),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_primary)
            )))
        }
    }
    pub fn build_postfix_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression::Call, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::call_expr => self.build_call_expr(inner),
                Rule::field_expr => self.build_field_expr(inner),
                Rule::index_expr => self.build_index_expr(inner),
                Rule::atom => self.build_atom(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_postfix_expr),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_postfix_expr)
            )))
        }
    }
    pub fn build_atom(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression::Try, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::try_expr => self.build_try_expr(inner),
                Rule::await_expr => self.build_await_expr(inner),
                Rule::struct_init => self.build_struct_init(inner),
                Rule::array_literal => self.build_array_literal(inner),
                Rule::bool_literal => self.build_bool_literal(inner),
                Rule::string_literal => self.build_string_literal(inner),
                Rule::integer_literal => self.build_integer_literal(inner),
                Rule::identifier_expr => self.build_identifier_expr(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_atom),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!("Empty {} rule", stringify!(build_atom))))
        }
    }
    pub fn build_string_inner(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::escape_seq => self.build_escape_seq(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_string_inner),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_string_inner)
            )))
        }
    }
    pub fn build_escape_seq(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i128>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Integer(n)),
                Type::Primitive(PrimitiveType::I64),
                span,
            ));
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Float(n)),
                Type::Primitive(PrimitiveType::F64),
                span,
            ));
        }
        if text == "true" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(true)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        if text == "false" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(false)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        Ok(typed_node(
            TypedExpression::Variable(intern(text)),
            Type::Never,
            span,
        ))
    }
}
