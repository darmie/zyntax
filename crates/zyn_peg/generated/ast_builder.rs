# ! [doc = r" Generated AST builder for zyntax_typed_ast"] # ! [doc = r""] # ! [doc = r" This file is auto-generated by ZynPEG. Do not edit manually."] # ! [doc = r" Uses zyntax_typed_ast types for JIT compilation compatibility."] # ! [allow (dead_code , unused_variables , unused_imports , unused_mut)] use zyntax_typed_ast :: { Type , PrimitiveType , TypedNode , TypedProgram , TypedDeclaration , TypedFunction , TypedVariable , TypedStatement , TypedExpression , TypedLiteral , TypedBlock , TypedLet , TypedIf , TypedWhile , TypedFor , TypedBinary , TypedUnary , TypedCall , TypedParameter , TypedMatch , TypedMatchExpr , TypedMatchArm , TypedFieldAccess , TypedIndex , TypedLambda , TypedLambdaBody , TypedMethodCall , TypedRange , TypedStructLiteral , TypedFieldInit , TypedPattern , TypedLiteralPattern , TypedReference , TypedCast , TypedIfExpr , TypedDefer , TypedClass , TypedEnum , TypedField , TypedVariant , TypedTypeParam , BinaryOp , UnaryOp , Span , InternedString , Mutability , Visibility , CallingConvention , ParameterKind , typed_node , NullabilityKind , AsyncKind , TypeId , ConstValue , Variance , } ; use super :: Rule ; # [doc = r" Postfix operation for expression building"] # [derive (Debug , Clone)] pub enum PostfixOp { Deref , Field (InternedString) , Index (TypedNode < TypedExpression >) , Call (Vec < TypedNode < TypedExpression >>) , OptionalUnwrap , TryUnwrap , } # [doc = r" Parse error type"] # [derive (Debug)] pub struct ParseError (pub String) ; impl std :: fmt :: Display for ParseError { fn fmt (& self , f : & mut std :: fmt :: Formatter < '_ >) -> std :: fmt :: Result { write ! (f , "{}" , self . 0) } } impl std :: error :: Error for ParseError { } impl < R : pest :: RuleType > From < pest :: error :: Error < R >> for ParseError { fn from (e : pest :: error :: Error < R >) -> Self { ParseError (e . to_string ()) } } # [doc = r" Helper: Create Span from pest span"] fn span_from_pest (pest_span : pest :: Span) -> Span { Span :: new (pest_span . start () , pest_span . end ()) } # [doc = r" Helper: Intern a string using the global interner"] fn intern (s : & str) -> InternedString { InternedString :: new_global (s) } # [doc = r" Helper: Parse primitive type from string"] fn parse_primitive_type (s : & str) -> Type { match s { "i8" => Type :: Primitive (PrimitiveType :: I8) , "i16" => Type :: Primitive (PrimitiveType :: I16) , "i32" => Type :: Primitive (PrimitiveType :: I32) , "i64" => Type :: Primitive (PrimitiveType :: I64) , "i128" => Type :: Primitive (PrimitiveType :: I128) , "u8" => Type :: Primitive (PrimitiveType :: U8) , "u16" => Type :: Primitive (PrimitiveType :: U16) , "u32" => Type :: Primitive (PrimitiveType :: U32) , "u64" => Type :: Primitive (PrimitiveType :: U64) , "u128" => Type :: Primitive (PrimitiveType :: U128) , "f32" => Type :: Primitive (PrimitiveType :: F32) , "f64" => Type :: Primitive (PrimitiveType :: F64) , "bool" => Type :: Primitive (PrimitiveType :: Bool) , "char" => Type :: Primitive (PrimitiveType :: Char) , "void" | "()" => Type :: Primitive (PrimitiveType :: Unit) , "usize" => Type :: Primitive (PrimitiveType :: USize) , "isize" => Type :: Primitive (PrimitiveType :: ISize) , _ => Type :: Never , } } # [doc = r" TypedAST builder context"] pub struct AstBuilderContext ; impl AstBuilderContext { pub fn new () -> Self { Self } pub fn build_program (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedProgram , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_declarations = all_children . iter () . find (| p | p . as_rule () == Rule :: declarations) . cloned () ; Ok (TypedProgram :: default ()) } pub fn build_declarations (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedProgram , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_declaration : Vec < _ > = all_children . iter () . filter (| p | p . as_rule () == Rule :: declaration) . cloned () . collect () ; Ok (TypedProgram :: default ()) } pub fn build_declaration (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedDeclaration > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_struct_decl = all_children . iter () . find (| p | p . as_rule () == Rule :: struct_decl) . cloned () ; Ok (TypedNode < TypedDeclaration > :: default ()) } pub fn build_struct_decl (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedDeclaration > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_struct_fields = all_children . iter () . find (| p | p . as_rule () == Rule :: struct_fields) . cloned () ; Ok (TypedNode < TypedDeclaration > :: default ()) } pub fn build_struct_fields (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < List , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_struct_field = all_children . iter () . find (| p | p . as_rule () == Rule :: struct_field) . cloned () ; Ok (List :: default ()) } pub fn build_struct_field (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedField , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_type_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: type_expr) . cloned () ; Ok (TypedField :: default ()) } pub fn build_enum_decl (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedDeclaration > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_enum_variants = all_children . iter () . find (| p | p . as_rule () == Rule :: enum_variants) . cloned () ; Ok (TypedNode < TypedDeclaration > :: default ()) } pub fn build_enum_variants (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < List , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_enum_variant = all_children . iter () . find (| p | p . as_rule () == Rule :: enum_variant) . cloned () ; Ok (List :: default ()) } pub fn build_enum_variant (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedVariant , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; Ok (TypedVariant :: default ()) } pub fn build_extern_fn_decl (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedDeclaration > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_extern_fn_decl_with_params = all_children . iter () . find (| p | p . as_rule () == Rule :: extern_fn_decl_with_params) . cloned () ; Ok (TypedNode < TypedDeclaration > :: default ()) } pub fn build_extern_fn_decl_with_params (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedDeclaration > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_fn_params = all_children . iter () . find (| p | p . as_rule () == Rule :: fn_params) . cloned () ; let child_type_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: type_expr) . cloned () ; Ok (TypedNode < TypedDeclaration > :: default ()) } pub fn build_extern_fn_decl_no_params (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedDeclaration > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_type_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: type_expr) . cloned () ; Ok (TypedNode < TypedDeclaration > :: default ()) } pub fn build_fn_decl (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedDeclaration > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_async_fn_decl = all_children . iter () . find (| p | p . as_rule () == Rule :: async_fn_decl) . cloned () ; Ok (TypedNode < TypedDeclaration > :: default ()) } pub fn build_sync_fn_decl (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedDeclaration > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_fn_decl_with_params = all_children . iter () . find (| p | p . as_rule () == Rule :: fn_decl_with_params) . cloned () ; Ok (TypedNode < TypedDeclaration > :: default ()) } pub fn build_async_fn_decl (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedDeclaration > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_async_fn_decl_with_params = all_children . iter () . find (| p | p . as_rule () == Rule :: async_fn_decl_with_params) . cloned () ; Ok (TypedNode < TypedDeclaration > :: default ()) } pub fn build_async_fn_decl_with_params (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedDeclaration > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_fn_params = all_children . iter () . find (| p | p . as_rule () == Rule :: fn_params) . cloned () ; let child_type_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: type_expr) . cloned () ; let child_block = all_children . iter () . find (| p | p . as_rule () == Rule :: block) . cloned () ; Ok (TypedNode < TypedDeclaration > :: default ()) } pub fn build_async_fn_decl_no_params (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedDeclaration > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_type_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: type_expr) . cloned () ; let child_block = all_children . iter () . find (| p | p . as_rule () == Rule :: block) . cloned () ; Ok (TypedNode < TypedDeclaration > :: default ()) } pub fn build_fn_decl_with_params (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedDeclaration > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_fn_params = all_children . iter () . find (| p | p . as_rule () == Rule :: fn_params) . cloned () ; let child_type_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: type_expr) . cloned () ; let child_block = all_children . iter () . find (| p | p . as_rule () == Rule :: block) . cloned () ; Ok (TypedNode < TypedDeclaration > :: default ()) } pub fn build_fn_decl_no_params (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedDeclaration > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_type_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: type_expr) . cloned () ; let child_block = all_children . iter () . find (| p | p . as_rule () == Rule :: block) . cloned () ; Ok (TypedNode < TypedDeclaration > :: default ()) } pub fn build_fn_params (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < List , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_fn_param_any = all_children . iter () . find (| p | p . as_rule () == Rule :: fn_param_any) . cloned () ; Ok (List :: default ()) } pub fn build_fn_param_any (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedParameter , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_comptime_param = all_children . iter () . find (| p | p . as_rule () == Rule :: comptime_param) . cloned () ; Ok (TypedParameter :: default ()) } pub fn build_comptime_param (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedParameter , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_type_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: type_expr) . cloned () ; Ok (TypedParameter :: default ()) } pub fn build_fn_param (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedParameter , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_type_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: type_expr) . cloned () ; Ok (TypedParameter :: default ()) } pub fn build_const_decl (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedDeclaration > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_const_decl_typed = all_children . iter () . find (| p | p . as_rule () == Rule :: const_decl_typed) . cloned () ; Ok (TypedNode < TypedDeclaration > :: default ()) } pub fn build_const_decl_typed (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedDeclaration > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_type_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: type_expr) . cloned () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; Ok (TypedNode < TypedDeclaration > :: default ()) } pub fn build_const_decl_untyped (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedDeclaration > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; Ok (TypedNode < TypedDeclaration > :: default ()) } pub fn build_var_decl (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedDeclaration > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_var_decl_typed = all_children . iter () . find (| p | p . as_rule () == Rule :: var_decl_typed) . cloned () ; Ok (TypedNode < TypedDeclaration > :: default ()) } pub fn build_var_decl_typed (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedDeclaration > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_type_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: type_expr) . cloned () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; Ok (TypedNode < TypedDeclaration > :: default ()) } pub fn build_var_decl_untyped (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedDeclaration > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; Ok (TypedNode < TypedDeclaration > :: default ()) } pub fn build_type_expr (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < Type , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_pointer_type = all_children . iter () . find (| p | p . as_rule () == Rule :: pointer_type) . cloned () ; Ok (Type :: default ()) } pub fn build_pointer_type (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < Type , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_type_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: type_expr) . cloned () ; Ok (Type :: default ()) } pub fn build_optional_type (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < Type , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_type_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: type_expr) . cloned () ; Ok (Type :: default ()) } pub fn build_error_union_type (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < Type , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_type_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: type_expr) . cloned () ; Ok (Type :: default ()) } pub fn build_array_type (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < Type , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_integer_literal = all_children . iter () . find (| p | p . as_rule () == Rule :: integer_literal) . cloned () ; let child_type_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: type_expr) . cloned () ; Ok (Type :: default ()) } pub fn build_primitive_type (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < Type , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; Ok (Type :: default ()) } pub fn build_statement (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedStatement > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_if_stmt = all_children . iter () . find (| p | p . as_rule () == Rule :: if_stmt) . cloned () ; Ok (TypedNode < TypedStatement > :: default ()) } pub fn build_break_stmt (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedStatement > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; Ok (TypedNode < TypedStatement > :: default ()) } pub fn build_continue_stmt (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedStatement > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; Ok (TypedNode < TypedStatement > :: default ()) } pub fn build_if_stmt (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedStatement > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_if_else = all_children . iter () . find (| p | p . as_rule () == Rule :: if_else) . cloned () ; Ok (TypedNode < TypedStatement > :: default ()) } pub fn build_if_only (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedStatement > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; let child_block = all_children . iter () . find (| p | p . as_rule () == Rule :: block) . cloned () ; Ok (TypedNode < TypedStatement > :: default ()) } pub fn build_if_else (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedStatement > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; let child_block = all_children . iter () . find (| p | p . as_rule () == Rule :: block) . cloned () ; Ok (TypedNode < TypedStatement > :: default ()) } pub fn build_while_stmt (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedStatement > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; let child_block = all_children . iter () . find (| p | p . as_rule () == Rule :: block) . cloned () ; Ok (TypedNode < TypedStatement > :: default ()) } pub fn build_for_stmt (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedStatement > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; Ok (TypedNode < TypedStatement > :: default ()) } pub fn build_assign_stmt (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedStatement > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; Ok (TypedNode < TypedStatement > :: default ()) } pub fn build_return_stmt (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedStatement > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; Ok (TypedNode < TypedStatement > :: default ()) } pub fn build_local_const (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedStatement > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_local_const_typed = all_children . iter () . find (| p | p . as_rule () == Rule :: local_const_typed) . cloned () ; Ok (TypedNode < TypedStatement > :: default ()) } pub fn build_local_const_typed (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedStatement > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_type_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: type_expr) . cloned () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; Ok (TypedNode < TypedStatement > :: default ()) } pub fn build_local_const_untyped (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedStatement > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; Ok (TypedNode < TypedStatement > :: default ()) } pub fn build_local_var (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedStatement > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_local_var_typed = all_children . iter () . find (| p | p . as_rule () == Rule :: local_var_typed) . cloned () ; Ok (TypedNode < TypedStatement > :: default ()) } pub fn build_local_var_typed (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedStatement > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_type_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: type_expr) . cloned () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; Ok (TypedNode < TypedStatement > :: default ()) } pub fn build_local_var_untyped (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedStatement > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; Ok (TypedNode < TypedStatement > :: default ()) } pub fn build_expr_stmt (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedStatement > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; Ok (TypedNode < TypedStatement > :: default ()) } pub fn build_block (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedBlock , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_statement : Vec < _ > = all_children . iter () . filter (| p | p . as_rule () == Rule :: statement) . cloned () . collect () ; Ok (TypedBlock :: default ()) } pub fn build_expr (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_logical_or = all_children . iter () . find (| p | p . as_rule () == Rule :: logical_or) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_logical_or (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_logical_and = all_children . iter () . find (| p | p . as_rule () == Rule :: logical_and) . cloned () ; let child_or_op : Vec < _ > = all_children . iter () . filter (| p | p . as_rule () == Rule :: or_op) . cloned () . collect () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_logical_and (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_comparison = all_children . iter () . find (| p | p . as_rule () == Rule :: comparison) . cloned () ; let child_and_op : Vec < _ > = all_children . iter () . filter (| p | p . as_rule () == Rule :: and_op) . cloned () . collect () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_comparison (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_addition = all_children . iter () . find (| p | p . as_rule () == Rule :: addition) . cloned () ; let child_eq_op : Vec < _ > = all_children . iter () . filter (| p | p . as_rule () == Rule :: eq_op) . cloned () . collect () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_addition (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_multiplication = all_children . iter () . find (| p | p . as_rule () == Rule :: multiplication) . cloned () ; let child_add_op : Vec < _ > = all_children . iter () . filter (| p | p . as_rule () == Rule :: add_op) . cloned () . collect () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_multiplication (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_unary = all_children . iter () . find (| p | p . as_rule () == Rule :: unary) . cloned () ; let child_mul_op : Vec < _ > = all_children . iter () . filter (| p | p . as_rule () == Rule :: mul_op) . cloned () . collect () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_unary (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_unary_with_op = all_children . iter () . find (| p | p . as_rule () == Rule :: unary_with_op) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_unary_with_op (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_unary_op = all_children . iter () . find (| p | p . as_rule () == Rule :: unary_op) . cloned () ; let child_primary = all_children . iter () . find (| p | p . as_rule () == Rule :: primary) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_primary (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_postfix_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: postfix_expr) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_postfix_expr (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_call_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: call_expr) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_call_expr (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_atom = all_children . iter () . find (| p | p . as_rule () == Rule :: atom) . cloned () ; let child_call_args = all_children . iter () . find (| p | p . as_rule () == Rule :: call_args) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_field_expr (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_atom = all_children . iter () . find (| p | p . as_rule () == Rule :: atom) . cloned () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_index_expr (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_atom = all_children . iter () . find (| p | p . as_rule () == Rule :: atom) . cloned () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_call_args (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < List , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; Ok (List :: default ()) } pub fn build_atom (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_switch_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: switch_expr) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_switch_expr (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; let child_switch_cases = all_children . iter () . find (| p | p . as_rule () == Rule :: switch_cases) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_switch_cases (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < List , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_switch_case = all_children . iter () . find (| p | p . as_rule () == Rule :: switch_case) . cloned () ; Ok (List :: default ()) } pub fn build_switch_case (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_switch_case_value = all_children . iter () . find (| p | p . as_rule () == Rule :: switch_case_value) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_switch_case_value (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_switch_pattern = all_children . iter () . find (| p | p . as_rule () == Rule :: switch_pattern) . cloned () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_switch_case_else (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_switch_pattern (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_switch_or_pattern = all_children . iter () . find (| p | p . as_rule () == Rule :: switch_or_pattern) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_switch_or_pattern (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_switch_primary_pattern = all_children . iter () . find (| p | p . as_rule () == Rule :: switch_primary_pattern) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_switch_primary_pattern (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_switch_struct_pattern = all_children . iter () . find (| p | p . as_rule () == Rule :: switch_struct_pattern) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_switch_range_pattern (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_switch_simple_literal = all_children . iter () . find (| p | p . as_rule () == Rule :: switch_simple_literal) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_switch_array_pattern (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_switch_array_elements = all_children . iter () . find (| p | p . as_rule () == Rule :: switch_array_elements) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_switch_array_elements (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < List , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_switch_pattern = all_children . iter () . find (| p | p . as_rule () == Rule :: switch_pattern) . cloned () ; Ok (List :: default ()) } pub fn build_switch_literal_pattern (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_switch_simple_literal = all_children . iter () . find (| p | p . as_rule () == Rule :: switch_simple_literal) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_switch_simple_literal (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_integer_literal = all_children . iter () . find (| p | p . as_rule () == Rule :: integer_literal) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_switch_wildcard_pattern (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_switch_identifier_pattern (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_switch_struct_pattern (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_switch_struct_field_patterns = all_children . iter () . find (| p | p . as_rule () == Rule :: switch_struct_field_patterns) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_switch_struct_field_patterns (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < List , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_switch_struct_field_pattern = all_children . iter () . find (| p | p . as_rule () == Rule :: switch_struct_field_pattern) . cloned () ; Ok (List :: default ()) } pub fn build_switch_struct_field_pattern (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_switch_pattern = all_children . iter () . find (| p | p . as_rule () == Rule :: switch_pattern) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_switch_tagged_union_pattern (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_switch_error_pattern (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_switch_pointer_pattern (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_switch_primary_pattern = all_children . iter () . find (| p | p . as_rule () == Rule :: switch_primary_pattern) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_type_value (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_type_expr_as_value = all_children . iter () . find (| p | p . as_rule () == Rule :: type_expr_as_value) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_type_expr_as_value (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < Type , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_primitive_type = all_children . iter () . find (| p | p . as_rule () == Rule :: primitive_type) . cloned () ; Ok (Type :: default ()) } pub fn build_struct_init (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_struct_init_fields = all_children . iter () . find (| p | p . as_rule () == Rule :: struct_init_fields) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_struct_init_fields (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < List , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_struct_init_field = all_children . iter () . find (| p | p . as_rule () == Rule :: struct_init_field) . cloned () ; Ok (List :: default ()) } pub fn build_struct_init_field (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_try_expr (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_primary = all_children . iter () . find (| p | p . as_rule () == Rule :: primary) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_await_expr (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_primary = all_children . iter () . find (| p | p . as_rule () == Rule :: primary) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_array_literal (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_array_elements = all_children . iter () . find (| p | p . as_rule () == Rule :: array_elements) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_array_elements (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < List , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_expr = all_children . iter () . find (| p | p . as_rule () == Rule :: expr) . cloned () ; Ok (List :: default ()) } pub fn build_identifier_expr (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_identifier = all_children . iter () . find (| p | p . as_rule () == Rule :: identifier) . cloned () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_bool_literal (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_integer_literal (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_string_literal (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_string_inner : Vec < _ > = all_children . iter () . filter (| p | p . as_rule () == Rule :: string_inner) . cloned () . collect () ; Ok (TypedNode < TypedExpression > :: default ()) } pub fn build_identifier (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < String , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; let child_keyword = all_children . iter () . find (| p | p . as_rule () == Rule :: keyword) . cloned () ; Ok (String :: default ()) } pub fn build_and_op (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < String , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; Ok (String :: default ()) } pub fn build_or_op (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < String , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; Ok (String :: default ()) } pub fn build_eq_op (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < String , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; Ok (String :: default ()) } pub fn build_neq_op (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < String , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; Ok (String :: default ()) } pub fn build_lte_op (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < String , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; Ok (String :: default ()) } pub fn build_gte_op (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < String , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; Ok (String :: default ()) } pub fn build_lt_op (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < String , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; Ok (String :: default ()) } pub fn build_gt_op (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < String , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; Ok (String :: default ()) } pub fn build_add_op (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < String , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; Ok (String :: default ()) } pub fn build_sub_op (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < String , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; Ok (String :: default ()) } pub fn build_mul_op (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < String , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; Ok (String :: default ()) } pub fn build_div_op (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < String , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; Ok (String :: default ()) } pub fn build_unary_op (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < String , ParseError > { let span = span_from_pest (pair . as_span ()) ; let pair_str = pair . as_str () ; let mut children = pair . into_inner () . peekable () ; let all_children : Vec < _ > = children . collect () ; let mut child_iter = all_children . iter () ; Ok (String :: default ()) } pub fn build_string_inner (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; if let Some (inner) = pair . into_inner () . next () { match inner . as_rule () { Rule :: escape_seq => self . build_escape_seq (inner) , _ => Err (ParseError (format ! ("Unexpected rule in {}: {:?}" , stringify ! (build_string_inner) , inner . as_rule ()))) , } } else { Err (ParseError (format ! ("Empty {} rule" , stringify ! (build_string_inner)))) } } pub fn build_escape_seq (& mut self , pair : pest :: iterators :: Pair < Rule >) -> Result < TypedNode < TypedExpression > , ParseError > { let span = span_from_pest (pair . as_span ()) ; let text = pair . as_str () . trim () ; if let Ok (n) = text . parse :: < i128 > () { return Ok (typed_node (TypedExpression :: Literal (TypedLiteral :: Integer (n)) , Type :: Primitive (PrimitiveType :: I64) , span ,)) ; } if let Ok (n) = text . parse :: < f64 > () { return Ok (typed_node (TypedExpression :: Literal (TypedLiteral :: Float (n)) , Type :: Primitive (PrimitiveType :: F64) , span ,)) ; } if text == "true" { return Ok (typed_node (TypedExpression :: Literal (TypedLiteral :: Bool (true)) , Type :: Primitive (PrimitiveType :: Bool) , span ,)) ; } if text == "false" { return Ok (typed_node (TypedExpression :: Literal (TypedLiteral :: Bool (false)) , Type :: Primitive (PrimitiveType :: Bool) , span ,)) ; } Ok (typed_node (TypedExpression :: Variable (intern (text)) , Type :: Never , span ,)) } }