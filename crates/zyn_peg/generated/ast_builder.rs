#![doc = r" Generated AST builder for zyntax_typed_ast"]
#![doc = r""]
#![doc = r" This file is auto-generated by ZynPEG. Do not edit manually."]
#![doc = r" Uses zyntax_typed_ast types for JIT compilation compatibility."]
#![allow(dead_code, unused_variables, unused_imports, unused_mut)]
use super::Rule;
use zyntax_typed_ast::{
    typed_node, AsyncKind, BinaryOp, CallingConvention, ConstValue, InternedString, Mutability,
    NullabilityKind, ParameterKind, PrimitiveType, Span, Type, TypeId, TypedBinary, TypedBlock,
    TypedCall, TypedCast, TypedClass, TypedDeclaration, TypedDefer, TypedEnum, TypedExpression,
    TypedField, TypedFieldAccess, TypedFieldInit, TypedFor, TypedFunction, TypedIf, TypedIfExpr,
    TypedIndex, TypedLambda, TypedLambdaBody, TypedLet, TypedLiteral, TypedLiteralPattern,
    TypedMatch, TypedMatchArm, TypedMatchExpr, TypedMethodCall, TypedNode, TypedParameter,
    TypedPattern, TypedProgram, TypedRange, TypedReference, TypedStatement, TypedStructLiteral,
    TypedTypeParam, TypedUnary, TypedVariable, TypedVariant, TypedWhile, UnaryOp, Variance,
    Visibility,
};
#[doc = r" Postfix operation for expression building"]
#[derive(Debug, Clone)]
pub enum PostfixOp {
    Deref,
    Field(InternedString),
    Index(TypedNode<TypedExpression>),
    Call(Vec<TypedNode<TypedExpression>>),
    OptionalUnwrap,
    TryUnwrap,
}
#[doc = r" Parse error type"]
#[derive(Debug)]
pub struct ParseError(pub String);
impl std::fmt::Display for ParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}
impl std::error::Error for ParseError {}
impl<R: pest::RuleType> From<pest::error::Error<R>> for ParseError {
    fn from(e: pest::error::Error<R>) -> Self {
        ParseError(e.to_string())
    }
}
#[doc = r" Helper: Create Span from pest span"]
fn span_from_pest(pest_span: pest::Span) -> Span {
    Span::new(pest_span.start(), pest_span.end())
}
#[doc = r" Helper: Intern a string using the global interner"]
fn intern(s: &str) -> InternedString {
    InternedString::new_global(s)
}
#[doc = r" Helper: Parse primitive type from string"]
fn parse_primitive_type(s: &str) -> Type {
    match s {
        "i8" => Type::Primitive(PrimitiveType::I8),
        "i16" => Type::Primitive(PrimitiveType::I16),
        "i32" => Type::Primitive(PrimitiveType::I32),
        "i64" => Type::Primitive(PrimitiveType::I64),
        "i128" => Type::Primitive(PrimitiveType::I128),
        "u8" => Type::Primitive(PrimitiveType::U8),
        "u16" => Type::Primitive(PrimitiveType::U16),
        "u32" => Type::Primitive(PrimitiveType::U32),
        "u64" => Type::Primitive(PrimitiveType::U64),
        "u128" => Type::Primitive(PrimitiveType::U128),
        "f32" => Type::Primitive(PrimitiveType::F32),
        "f64" => Type::Primitive(PrimitiveType::F64),
        "bool" => Type::Primitive(PrimitiveType::Bool),
        "char" => Type::Primitive(PrimitiveType::Char),
        "void" | "()" => Type::Primitive(PrimitiveType::Unit),
        "usize" => Type::Primitive(PrimitiveType::USize),
        "isize" => Type::Primitive(PrimitiveType::ISize),
        _ => Type::Never,
    }
}
#[doc = r" TypedAST builder context"]
pub struct AstBuilderContext;
impl AstBuilderContext {
    pub fn new() -> Self {
        Self
    }
    fn fold_binary(
        first: TypedNode<TypedExpression>,
        rest: Vec<(String, TypedNode<TypedExpression>)>,
        default_op: BinaryOp,
    ) -> TypedNode<TypedExpression> {
        rest.into_iter().fold(first, |left, (op_str, right)| {
            let op = match op_str.as_str() {
                "+" => BinaryOp::Add,
                "-" => BinaryOp::Sub,
                "*" => BinaryOp::Mul,
                "/" => BinaryOp::Div,
                "%" => BinaryOp::Rem,
                "==" => BinaryOp::Eq,
                "!=" => BinaryOp::Ne,
                "<" => BinaryOp::Lt,
                "<=" => BinaryOp::Le,
                ">" => BinaryOp::Gt,
                ">=" => BinaryOp::Ge,
                "and" => BinaryOp::And,
                "or" => BinaryOp::Or,
                "|" => BinaryOp::BitOr,
                "&" => BinaryOp::BitAnd,
                "^" => BinaryOp::BitXor,
                "<<" => BinaryOp::Shl,
                ">>" => BinaryOp::Shr,
                _ => default_op,
            };
            let result_ty = Self::infer_binary_type(&left.ty, op, &right.ty);
            let span = Span::new(left.span.start, right.span.end);
            typed_node(
                TypedExpression::Binary(TypedBinary {
                    op,
                    left: Box::new(left),
                    right: Box::new(right),
                }),
                result_ty,
                span,
            )
        })
    }
    fn infer_binary_type(left: &Type, op: BinaryOp, _right: &Type) -> Type {
        match op {
            BinaryOp::Eq
            | BinaryOp::Ne
            | BinaryOp::Lt
            | BinaryOp::Le
            | BinaryOp::Gt
            | BinaryOp::Ge
            | BinaryOp::And
            | BinaryOp::Or => Type::Primitive(PrimitiveType::Bool),
            _ => left.clone(),
        }
    }
    fn fold_postfix(
        base: TypedNode<TypedExpression>,
        ops: Vec<PostfixOp>,
    ) -> TypedNode<TypedExpression> {
        ops.into_iter().fold(base, |expr, op| {
            let span = expr.span;
            match op {
                PostfixOp::Deref => typed_node(
                    TypedExpression::Dereference(Box::new(expr)),
                    Type::Never,
                    span,
                ),
                PostfixOp::Field(name) => typed_node(
                    TypedExpression::Field(TypedFieldAccess {
                        object: Box::new(expr),
                        field: name,
                    }),
                    Type::Never,
                    span,
                ),
                PostfixOp::Index(index) => typed_node(
                    TypedExpression::Index(TypedIndex {
                        object: Box::new(expr),
                        index: Box::new(index),
                    }),
                    Type::Never,
                    span,
                ),
                PostfixOp::Call(args) => typed_node(
                    TypedExpression::Call(TypedCall {
                        callee: Box::new(expr),
                        positional_args: args,
                        named_args: vec![],
                        type_args: vec![],
                    }),
                    Type::Never,
                    span,
                ),
                PostfixOp::OptionalUnwrap => {
                    typed_node(TypedExpression::Try(Box::new(expr)), Type::Never, span)
                }
                PostfixOp::TryUnwrap => {
                    typed_node(TypedExpression::Try(Box::new(expr)), Type::Never, span)
                }
            }
        })
    }
    fn parse_int(s: &str) -> i128 {
        s.trim().parse().unwrap_or(0)
    }
    fn parse_float(s: &str) -> f64 {
        s.trim().parse().unwrap_or(0.0)
    }
    fn unwrap_result_type(ty: &Type) -> Type {
        match ty {
            Type::Result { ok_type, .. } => (**ok_type).clone(),
            _ => ty.clone(),
        }
    }
    fn collect_cases<T, U>(_first: T, _rest: U) -> Vec<TypedMatchArm> {
        vec![]
    }
    fn infer_switch_type<T, U>(_first: T, _rest: U) -> Type {
        Type::Never
    }
    fn parse_unary_op(op: &str) -> UnaryOp {
        match op {
            "+" => UnaryOp::Plus,
            "-" => UnaryOp::Minus,
            "!" => UnaryOp::Not,
            "~" => UnaryOp::BitNot,
            _ => UnaryOp::Minus,
        }
    }
    fn collect_exprs(
        first: TypedNode<TypedExpression>,
        rest: Vec<TypedNode<TypedExpression>>,
    ) -> Vec<TypedNode<TypedExpression>> {
        let mut exprs = vec![first];
        exprs.extend(rest);
        exprs
    }
    pub fn build_program(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedProgram, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_declaration: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::declaration)
            .cloned()
            .collect();
        Ok({
            TypedProgram {
                declarations: child_declaration
                    .iter()
                    .filter_map(|p| self.build_declaration(p.clone()).ok())
                    .collect::<Vec<_>>(),
                span: span,
            }
        })
    }
    pub fn build_const_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedDeclaration>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        Ok({
            typed_node(
                TypedDeclaration::Variable(TypedVariable {
                    name: InternedString::new_global(
                        child_identifier.as_ref().map(|p| p.as_str()).unwrap_or(""),
                    ),
                    ty: child_type_expr
                        .as_ref()
                        .and_then(|p| self.build_type_expr(p.clone()).ok())
                        .unwrap_or(Type::Never),
                    mutability: Mutability::Immutable,
                    initializer: Some(Box::new(
                        child_expr
                            .as_ref()
                            .and_then(|p| self.build_expr(p.clone()).ok())
                            .unwrap_or_default(),
                    )),
                    visibility: Visibility::Private,
                }),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_var_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedDeclaration>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        Ok({
            typed_node(
                TypedDeclaration::Variable(TypedVariable {
                    name: InternedString::new_global(
                        child_identifier.as_ref().map(|p| p.as_str()).unwrap_or(""),
                    ),
                    ty: child_type_expr
                        .as_ref()
                        .and_then(|p| self.build_type_expr(p.clone()).ok())
                        .unwrap_or(Type::Never),
                    mutability: Mutability::Mutable,
                    initializer: Some(Box::new(
                        child_expr
                            .as_ref()
                            .and_then(|p| self.build_expr(p.clone()).ok())
                            .unwrap_or_default(),
                    )),
                    visibility: Visibility::Private,
                }),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_fn_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedDeclaration>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_fn_params = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::fn_params)
            .cloned();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        let child_block = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::block)
            .cloned();
        Ok({
            typed_node(
                TypedDeclaration::Function(TypedFunction {
                    name: InternedString::new_global(
                        child_identifier.as_ref().map(|p| p.as_str()).unwrap_or(""),
                    ),
                    type_params: vec![],
                    params: child_fn_params
                        .as_ref()
                        .and_then(|p| self.build_fn_params(p.clone()).ok())
                        .unwrap_or_default(),
                    return_type: child_type_expr
                        .as_ref()
                        .and_then(|p| self.build_type_expr(p.clone()).ok())
                        .unwrap_or_default(),
                    body: Some(
                        child_block
                            .as_ref()
                            .and_then(|p| self.build_block(p.clone()).ok())
                            .unwrap_or_default(),
                    ),
                    visibility: Visibility::Private,
                    is_async: false,
                    is_external: false,
                    calling_convention: CallingConvention::default(),
                    link_name: None,
                }),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_fn_params(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Vec<TypedParameter>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_fn_param = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::fn_param)
            .cloned();
        Ok({
            all_children
                .iter()
                .filter(|p| p.as_rule() == Rule::fn_param)
                .filter_map(|p| self.build_fn_param(p.clone()).ok())
                .collect()
        })
    }
    pub fn build_comptime_param(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedParameter, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        Ok({
            TypedParameter {
                name: InternedString::new_global(
                    child_identifier.as_ref().map(|p| p.as_str()).unwrap_or(""),
                ),
                ty: Type::Never,
                mutability: Mutability::Immutable,
                kind: ParameterKind::Regular,
                default_value: None,
                attributes: vec![],
                span: span,
            }
        })
    }
    pub fn build_regular_param(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedParameter, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        Ok({
            TypedParameter {
                name: InternedString::new_global(
                    child_identifier.as_ref().map(|p| p.as_str()).unwrap_or(""),
                ),
                ty: child_type_expr
                    .as_ref()
                    .and_then(|p| self.build_type_expr(p.clone()).ok())
                    .unwrap_or_default(),
                mutability: Mutability::Immutable,
                kind: ParameterKind::Regular,
                default_value: None,
                attributes: vec![],
                span: span,
            }
        })
    }
    pub fn build_struct_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedDeclaration>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_field_decl: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::field_decl)
            .cloned()
            .collect();
        Ok({
            typed_node(
                TypedDeclaration::Class(TypedClass {
                    name: InternedString::new_global(
                        child_identifier.as_ref().map(|p| p.as_str()).unwrap_or(""),
                    ),
                    type_params: vec![],
                    extends: None,
                    implements: vec![],
                    fields: child_field_decl
                        .iter()
                        .filter_map(|p| self.build_field_decl(p.clone()).ok())
                        .collect::<Vec<_>>(),
                    methods: vec![],
                    constructors: vec![],
                    visibility: Visibility::Private,
                    is_abstract: false,
                    is_final: false,
                    span: span,
                }),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_field_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedField, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        Ok({
            TypedField {
                name: InternedString::new_global(
                    child_identifier.as_ref().map(|p| p.as_str()).unwrap_or(""),
                ),
                ty: child_type_expr
                    .as_ref()
                    .and_then(|p| self.build_type_expr(p.clone()).ok())
                    .unwrap_or_default(),
                initializer: None,
                visibility: Visibility::Private,
                mutability: Mutability::Immutable,
                is_static: false,
                span: span,
            }
        })
    }
    pub fn build_enum_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedDeclaration>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        let child_enum_variant = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::enum_variant)
            .cloned();
        Ok({
            typed_node(
                TypedDeclaration::Enum(TypedEnum {
                    name: InternedString::new_global(
                        child_identifier.as_ref().map(|p| p.as_str()).unwrap_or(""),
                    ),
                    type_params: vec![],
                    variants: vec![],
                    visibility: Visibility::Private,
                    span: span,
                }),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_enum_variant(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        Ok({
            let mut name = String::new();
            let mut value: Option<TypedNode<TypedExpression>> = None;
            for inner in all_children.iter() {
                match inner.as_rule() {
                    Rule::identifier => name = inner.as_str().to_string(),
                    Rule::expr => value = Some(self.build_expr(inner.clone())?),
                    _ => {}
                }
            }
            typed_node(
                TypedExpression::Variable(InternedString::new_global(&name)),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_union_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedDeclaration>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_union_field = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::union_field)
            .cloned();
        Ok({
            typed_node(
                TypedDeclaration::Class(TypedClass {
                    name: InternedString::new_global(
                        child_identifier.as_ref().map(|p| p.as_str()).unwrap_or(""),
                    ),
                    type_params: vec![],
                    extends: None,
                    implements: vec![],
                    fields: vec![],
                    methods: vec![],
                    constructors: vec![],
                    visibility: Visibility::Private,
                    is_abstract: false,
                    is_final: false,
                    span: span,
                }),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_union_field(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedField, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        Ok({
            TypedField {
                name: InternedString::new_global(
                    child_identifier.as_ref().map(|p| p.as_str()).unwrap_or(""),
                ),
                ty: child_type_expr
                    .as_ref()
                    .and_then(|p| self.build_type_expr(p.clone()).ok())
                    .unwrap_or_default(),
                initializer: None,
                visibility: Visibility::Private,
                mutability: Mutability::Immutable,
                is_static: false,
                span: span,
            }
        })
    }
    pub fn build_error_set_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedDeclaration>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        Ok({
            typed_node(
                TypedDeclaration::Enum(TypedEnum {
                    name: InternedString::new_global(
                        child_identifier.as_ref().map(|p| p.as_str()).unwrap_or(""),
                    ),
                    type_params: vec![],
                    variants: vec![],
                    visibility: Visibility::Private,
                    span: span,
                }),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_type_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Type, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_primitive_type = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::primitive_type)
            .cloned();
        Ok({
            if let Some(inner) = all_children.first() {
                match inner.as_rule() {
                    Rule::primitive_type => self.build_primitive_type(inner.clone())?,
                    Rule::array_type => self.build_array_type(inner.clone())?,
                    Rule::pointer_type => self.build_pointer_type(inner.clone())?,
                    Rule::optional_type => self.build_optional_type(inner.clone())?,
                    Rule::error_union_type => self.build_error_union_type(inner.clone())?,
                    Rule::identifier => Type::Named {
                        id: TypeId::new(0),
                        type_args: vec![],
                        const_args: vec![],
                        variance: vec![],
                        nullability: NullabilityKind::NonNull,
                    },
                    _ => Type::Named {
                        id: TypeId::new(0),
                        type_args: vec![],
                        const_args: vec![],
                        variance: vec![],
                        nullability: NullabilityKind::NonNull,
                    },
                }
            } else {
                Type::Named {
                    id: TypeId::new(0),
                    type_args: vec![],
                    const_args: vec![],
                    variance: vec![],
                    nullability: NullabilityKind::NonNull,
                }
            }
        })
    }
    pub fn build_primitive_type(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Type, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok({ parse_primitive_type(pair_str) })
    }
    pub fn build_array_type(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Type, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_integer_literal = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::integer_literal)
            .cloned();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        Ok({
            Type::Array {
                element_type: Box::new(
                    child_type_expr
                        .as_ref()
                        .and_then(|p| self.build_type_expr(p.clone()).ok())
                        .unwrap_or_default(),
                ),
                size: child_integer_literal
                    .as_ref()
                    .and_then(|p| self.build_integer_literal(p.clone()).ok())
                    .and_then(|e| {
                        if let TypedExpression::Literal(TypedLiteral::Integer(n)) = &e.node {
                            Some(ConstValue::Int(*n as i64))
                        } else {
                            None
                        }
                    }),
                nullability: NullabilityKind::NonNull,
            }
        })
    }
    pub fn build_pointer_type(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Type, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        Ok({
            Type::Reference {
                ty: Box::new(
                    child_type_expr
                        .as_ref()
                        .and_then(|p| self.build_type_expr(p.clone()).ok())
                        .unwrap_or_default(),
                ),
                mutability: Mutability::Immutable,
                lifetime: None,
                nullability: NullabilityKind::NonNull,
            }
        })
    }
    pub fn build_optional_type(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Type, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        Ok({
            Type::Optional(Box::new(
                child_type_expr
                    .as_ref()
                    .and_then(|p| self.build_type_expr(p.clone()).ok())
                    .unwrap_or_default(),
            ))
        })
    }
    pub fn build_error_union_type(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Type, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        Ok({
            Type::Result {
                ok_type: Box::new(
                    child_type_expr
                        .as_ref()
                        .and_then(|p| self.build_type_expr(p.clone()).ok())
                        .unwrap_or_default(),
                ),
                err_type: Box::new(Type::Never),
            }
        })
    }
    pub fn build_local_const(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedStatement>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        Ok({
            typed_node(
                TypedStatement::Let(TypedLet {
                    name: InternedString::new_global(
                        child_identifier.as_ref().map(|p| p.as_str()).unwrap_or(""),
                    ),
                    ty: child_type_expr
                        .as_ref()
                        .and_then(|p| self.build_type_expr(p.clone()).ok())
                        .unwrap_or(Type::Never),
                    mutability: Mutability::Immutable,
                    initializer: Some(Box::new(
                        child_expr
                            .as_ref()
                            .and_then(|p| self.build_expr(p.clone()).ok())
                            .unwrap_or_default(),
                    )),
                    span: span,
                }),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_local_var(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedStatement>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        Ok({
            typed_node(
                TypedStatement::Let(TypedLet {
                    name: InternedString::new_global(
                        child_identifier.as_ref().map(|p| p.as_str()).unwrap_or(""),
                    ),
                    ty: child_type_expr
                        .as_ref()
                        .and_then(|p| self.build_type_expr(p.clone()).ok())
                        .unwrap_or(Type::Never),
                    mutability: Mutability::Mutable,
                    initializer: Some(Box::new(
                        child_expr
                            .as_ref()
                            .and_then(|p| self.build_expr(p.clone()).ok())
                            .unwrap_or_default(),
                    )),
                    span: span,
                }),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_defer_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedStatement>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_block = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::block)
            .cloned();
        Ok({
            typed_node(
                TypedStatement::Defer(TypedDefer {
                    body: Box::new(typed_node(
                        TypedExpression::Block(
                            child_block
                                .as_ref()
                                .and_then(|p| self.build_block(p.clone()).ok())
                                .unwrap_or_default(),
                        ),
                        Type::Never,
                        span,
                    )),
                    span: span,
                }),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_errdefer_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedStatement>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_block = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::block)
            .cloned();
        Ok({
            typed_node(
                TypedStatement::Defer(TypedDefer {
                    body: Box::new(typed_node(
                        TypedExpression::Block(
                            child_block
                                .as_ref()
                                .and_then(|p| self.build_block(p.clone()).ok())
                                .unwrap_or_default(),
                        ),
                        Type::Never,
                        span,
                    )),
                    span: span,
                }),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_assignment(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedStatement>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_assign_target = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::assign_target)
            .cloned();
        let child_assign_op = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::assign_op)
            .cloned();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        Ok({
            typed_node(
                TypedStatement::Expression(Box::new(
                    child_expr
                        .as_ref()
                        .and_then(|p| self.build_expr(p.clone()).ok())
                        .unwrap_or_default(),
                )),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_assign_target(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_expr: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::expr)
            .cloned()
            .collect();
        Ok({
            let mut base: Option<TypedNode<TypedExpression>> = None;
            let mut indices: Vec<TypedNode<TypedExpression>> = Vec::new();
            for inner in all_children.iter() {
                match inner.as_rule() {
                    Rule::identifier => {
                        base = Some(typed_node(
                            TypedExpression::Variable(InternedString::new_global(inner.as_str())),
                            Type::Never,
                            span,
                        ));
                    }
                    Rule::expr => indices.push(self.build_expr(inner.clone())?),
                    _ => {}
                }
            }
            let mut result = base.unwrap_or_else(|| {
                typed_node(
                    TypedExpression::Variable(InternedString::new_global(pair_str)),
                    Type::Never,
                    span,
                )
            });
            for idx in indices {
                result = typed_node(
                    TypedExpression::Index(TypedIndex {
                        object: Box::new(result),
                        index: Box::new(idx),
                    }),
                    Type::Never,
                    span,
                );
            }
            result
        })
    }
    pub fn build_return_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedStatement>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        Ok({
            typed_node(
                TypedStatement::Return(
                    child_expr
                        .as_ref()
                        .and_then(|p| self.build_expr(p.clone()).ok())
                        .map(Box::new),
                ),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_expr_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedStatement>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        Ok({
            typed_node(
                TypedStatement::Expression(Box::new(
                    child_expr
                        .as_ref()
                        .and_then(|p| self.build_expr(p.clone()).ok())
                        .unwrap_or_default(),
                )),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_if_let_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedStatement>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_pattern = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::pattern)
            .cloned();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        let child_block = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::block)
            .cloned();
        Ok({
            typed_node(
                TypedStatement::If(TypedIf {
                    condition: Box::new(
                        child_expr
                            .as_ref()
                            .and_then(|p| self.build_expr(p.clone()).ok())
                            .unwrap_or_default(),
                    ),
                    then_block: child_block
                        .as_ref()
                        .and_then(|p| self.build_block(p.clone()).ok())
                        .unwrap_or_default(),
                    else_block: child_block
                        .as_ref()
                        .and_then(|p| self.build_block(p.clone()).ok()),
                    span: span,
                }),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_if_regular_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedStatement>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        let child_block = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::block)
            .cloned();
        Ok({
            typed_node(
                TypedStatement::If(TypedIf {
                    condition: Box::new(
                        child_expr
                            .as_ref()
                            .and_then(|p| self.build_expr(p.clone()).ok())
                            .unwrap_or_default(),
                    ),
                    then_block: child_block
                        .as_ref()
                        .and_then(|p| self.build_block(p.clone()).ok())
                        .unwrap_or_default(),
                    else_block: child_block
                        .as_ref()
                        .and_then(|p| self.build_block(p.clone()).ok()),
                    span: span,
                }),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_while_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedStatement>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        let child_block = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::block)
            .cloned();
        Ok({
            typed_node(
                TypedStatement::While(TypedWhile {
                    condition: Box::new(
                        child_expr
                            .as_ref()
                            .and_then(|p| self.build_expr(p.clone()).ok())
                            .unwrap_or_default(),
                    ),
                    body: child_block
                        .as_ref()
                        .and_then(|p| self.build_block(p.clone()).ok())
                        .unwrap_or_default(),
                    span: span,
                }),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_for_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedStatement>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        let child_block = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::block)
            .cloned();
        Ok({
            typed_node(
                TypedStatement::For(TypedFor {
                    pattern: Box::new(typed_node(
                        TypedPattern::immutable_var(InternedString::new_global(
                            child_identifier.as_ref().map(|p| p.as_str()).unwrap_or(""),
                        )),
                        Type::Never,
                        span,
                    )),
                    iterator: Box::new(
                        child_expr
                            .as_ref()
                            .and_then(|p| self.build_expr(p.clone()).ok())
                            .unwrap_or_default(),
                    ),
                    body: child_block
                        .as_ref()
                        .and_then(|p| self.build_block(p.clone()).ok())
                        .unwrap_or_default(),
                }),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_break_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedStatement>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok({ typed_node(TypedStatement::Break(None), Type::Never, span) })
    }
    pub fn build_continue_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedStatement>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok({ typed_node(TypedStatement::Continue, Type::Never, span) })
    }
    pub fn build_block(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedBlock, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_statement: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::statement)
            .cloned()
            .collect();
        Ok({
            TypedBlock {
                statements: child_statement
                    .iter()
                    .filter_map(|p| self.build_statement(p.clone()).ok())
                    .collect::<Vec<_>>(),
                span: span,
            }
        })
    }
    pub fn build_orelse_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_catch_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::catch_expr)
            .cloned();
        let child_orelse_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::orelse_op)
            .cloned()
            .collect();
        Ok({
            child_catch_expr
                .as_ref()
                .and_then(|p| self.build_catch_expr(p.clone()).ok())
                .unwrap_or_default()
                .clone()
        })
    }
    pub fn build_catch_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_logical_or = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::logical_or)
            .cloned();
        let child_catch_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::catch_op)
            .cloned()
            .collect();
        Ok({
            child_logical_or
                .as_ref()
                .and_then(|p| self.build_logical_or(p.clone()).ok())
                .unwrap_or_default()
                .clone()
        })
    }
    pub fn build_logical_or(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_logical_and = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::logical_and)
            .cloned();
        let child_log_or_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::log_or_op)
            .cloned()
            .collect();
        Ok({
            child_logical_and
                .as_ref()
                .and_then(|p| self.build_logical_and(p.clone()).ok())
                .unwrap_or_default()
                .clone()
        })
    }
    pub fn build_logical_and(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_equality = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::equality)
            .cloned();
        let child_log_and_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::log_and_op)
            .cloned()
            .collect();
        Ok({
            child_equality
                .as_ref()
                .and_then(|p| self.build_equality(p.clone()).ok())
                .unwrap_or_default()
                .clone()
        })
    }
    pub fn build_equality(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_comparison = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::comparison)
            .cloned();
        let child_eq_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::eq_op)
            .cloned()
            .collect();
        Ok({
            child_comparison
                .as_ref()
                .and_then(|p| self.build_comparison(p.clone()).ok())
                .unwrap_or_default()
                .clone()
        })
    }
    pub fn build_comparison(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_bitwise_or = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::bitwise_or)
            .cloned();
        let child_cmp_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::cmp_op)
            .cloned()
            .collect();
        Ok({
            child_bitwise_or
                .as_ref()
                .and_then(|p| self.build_bitwise_or(p.clone()).ok())
                .unwrap_or_default()
                .clone()
        })
    }
    pub fn build_bitwise_or(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_bitwise_xor = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::bitwise_xor)
            .cloned();
        let child_bit_or_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::bit_or_op)
            .cloned()
            .collect();
        Ok({
            child_bitwise_xor
                .as_ref()
                .and_then(|p| self.build_bitwise_xor(p.clone()).ok())
                .unwrap_or_default()
                .clone()
        })
    }
    pub fn build_bitwise_xor(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_bitwise_and = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::bitwise_and)
            .cloned();
        let child_bit_xor_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::bit_xor_op)
            .cloned()
            .collect();
        Ok({
            child_bitwise_and
                .as_ref()
                .and_then(|p| self.build_bitwise_and(p.clone()).ok())
                .unwrap_or_default()
                .clone()
        })
    }
    pub fn build_bitwise_and(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_bit_shift = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::bit_shift)
            .cloned();
        let child_bit_and_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::bit_and_op)
            .cloned()
            .collect();
        Ok({
            child_bit_shift
                .as_ref()
                .and_then(|p| self.build_bit_shift(p.clone()).ok())
                .unwrap_or_default()
                .clone()
        })
    }
    pub fn build_bit_shift(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_addition = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::addition)
            .cloned();
        let child_shift_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::shift_op)
            .cloned()
            .collect();
        Ok({
            child_addition
                .as_ref()
                .and_then(|p| self.build_addition(p.clone()).ok())
                .unwrap_or_default()
                .clone()
        })
    }
    pub fn build_addition(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_multiplication = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::multiplication)
            .cloned();
        let child_add_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::add_op)
            .cloned()
            .collect();
        Ok({
            let mut rest: Vec<(String, TypedNode<TypedExpression>)> = Vec::new();
            let mut iter = all_children.iter();
            if let Some(first) = iter.next() {
                while let Some(op_pair) = iter.next() {
                    if let Some(operand_pair) = iter.next() {
                        let op_str = op_pair.as_str().to_string();
                        if let Ok(operand) = self.build_multiplication(operand_pair.clone()) {
                            rest.push((op_str, operand));
                        }
                    }
                }
                Self::fold_binary(
                    self.build_multiplication(first.clone())?,
                    rest,
                    BinaryOp::Add,
                )
            } else {
                typed_node(
                    TypedExpression::Variable(InternedString::new_global("error")),
                    Type::Never,
                    span,
                )
            }
        })
    }
    pub fn build_multiplication(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_unary = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::unary)
            .cloned();
        let child_mul_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::mul_op)
            .cloned()
            .collect();
        Ok({
            let mut rest: Vec<(String, TypedNode<TypedExpression>)> = Vec::new();
            let mut iter = all_children.iter();
            if let Some(first) = iter.next() {
                while let Some(op_pair) = iter.next() {
                    if let Some(operand_pair) = iter.next() {
                        let op_str = op_pair.as_str().to_string();
                        if let Ok(operand) = self.build_unary(operand_pair.clone()) {
                            rest.push((op_str, operand));
                        }
                    }
                }
                Self::fold_binary(self.build_unary(first.clone())?, rest, BinaryOp::Mul)
            } else {
                typed_node(
                    TypedExpression::Variable(InternedString::new_global("error")),
                    Type::Never,
                    span,
                )
            }
        })
    }
    pub fn build_unary(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_unary_op = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::unary_op)
            .cloned();
        let child_postfix = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::postfix)
            .cloned();
        Ok({
            match child_unary_op
                .as_ref()
                .and_then(|p| self.build_unary_op(p.clone()).ok())
            {
                Some(op) => typed_node(
                    TypedExpression::Unary(TypedUnary {
                        op: Self::parse_unary_op(&op),
                        operand: Box::new(
                            child_postfix
                                .as_ref()
                                .and_then(|p| self.build_postfix(p.clone()).ok())
                                .unwrap_or_default()
                                .clone(),
                        ),
                    }),
                    child_postfix
                        .as_ref()
                        .and_then(|p| self.build_postfix(p.clone()).ok())
                        .unwrap_or_default()
                        .ty
                        .clone(),
                    span,
                ),
                None => child_postfix
                    .as_ref()
                    .and_then(|p| self.build_postfix(p.clone()).ok())
                    .unwrap_or_default(),
            }
        })
    }
    pub fn build_postfix(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_primary = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::primary)
            .cloned();
        let child_postfix_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::postfix_op)
            .cloned()
            .collect();
        Ok({
            Self::fold_postfix(
                child_primary
                    .as_ref()
                    .and_then(|p| self.build_primary(p.clone()).ok())
                    .unwrap_or_default(),
                child_postfix_op
                    .iter()
                    .filter_map(|p| self.build_postfix_op(p.clone()).ok())
                    .collect::<Vec<_>>(),
            )
        })
    }
    pub fn build_deref_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<PostfixOp, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok({ PostfixOp::Deref })
    }
    pub fn build_field_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<PostfixOp, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        Ok({
            PostfixOp::Field(InternedString::new_global(
                child_identifier.as_ref().map(|p| p.as_str()).unwrap_or(""),
            ))
        })
    }
    pub fn build_index_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<PostfixOp, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        Ok({
            PostfixOp::Index(
                child_expr
                    .as_ref()
                    .and_then(|p| self.build_expr(p.clone()).ok())
                    .unwrap_or_default(),
            )
        })
    }
    pub fn build_call_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<PostfixOp, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_arg_list = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::arg_list)
            .cloned();
        Ok({
            PostfixOp::Call(
                child_arg_list
                    .as_ref()
                    .and_then(|p| self.build_arg_list(p.clone()).ok())
                    .unwrap_or_default(),
            )
        })
    }
    pub fn build_arg_list(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Vec<TypedNode<TypedExpression>>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        Ok({
            Self::collect_exprs(
                child_expr
                    .as_ref()
                    .and_then(|p| self.build_expr(p.clone()).ok())
                    .unwrap_or_default(),
                child_expr
                    .iter()
                    .filter_map(|p| self.build_expr(p.clone()).ok())
                    .collect::<Vec<_>>(),
            )
        })
    }
    pub fn build_primary(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_literal = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::literal)
            .cloned();
        Ok({
            if let Some(inner) = all_children.first() {
                match inner.as_rule() {
                    Rule::literal => self.build_literal(inner.clone())?,
                    Rule::struct_literal => self.build_struct_literal(inner.clone())?,
                    Rule::switch_expr => self.build_switch_expr(inner.clone())?,
                    Rule::try_expr => self.build_try_expr(inner.clone())?,
                    Rule::lambda_expr => self.build_lambda_expr(inner.clone())?,
                    Rule::expr => self.build_expr(inner.clone())?,
                    Rule::identifier => {
                        let name = inner.as_str();
                        typed_node(
                            TypedExpression::Variable(InternedString::new_global(name)),
                            Type::Never,
                            span,
                        )
                    }
                    _ => typed_node(
                        TypedExpression::Variable(InternedString::new_global(pair_str)),
                        Type::Never,
                        span,
                    ),
                }
            } else {
                typed_node(
                    TypedExpression::Variable(InternedString::new_global(pair_str)),
                    Type::Never,
                    span,
                )
            }
        })
    }
    pub fn build_lambda_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_lambda_start = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::lambda_start)
            .cloned();
        let child_lambda_params = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::lambda_params)
            .cloned();
        let child_lambda_end = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::lambda_end)
            .cloned();
        let child_block = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::block)
            .cloned();
        Ok({
            typed_node(
                TypedExpression::Lambda(TypedLambda {
                    params: vec![],
                    body: TypedLambdaBody::Block(
                        child_block
                            .as_ref()
                            .and_then(|p| self.build_block(p.clone()).ok())
                            .unwrap_or_default(),
                    ),
                    captures: vec![],
                }),
                Type::Function {
                    params: vec![],
                    return_type: Box::new(Type::Never),
                    is_varargs: false,
                    has_named_params: false,
                    has_default_params: false,
                    async_kind: AsyncKind::Sync,
                    calling_convention: CallingConvention::Default,
                    nullability: NullabilityKind::NonNull,
                },
                span,
            )
        })
    }
    pub fn build_lambda_param(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedParameter, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        Ok(todo!("Failed to parse raw code"))
    }
    pub fn build_try_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_postfix = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::postfix)
            .cloned();
        Ok({
            typed_node(
                TypedExpression::Try(Box::new(
                    child_postfix
                        .as_ref()
                        .and_then(|p| self.build_postfix(p.clone()).ok())
                        .unwrap_or_default()
                        .clone(),
                )),
                Self::unwrap_result_type(
                    &child_postfix
                        .as_ref()
                        .and_then(|p| self.build_postfix(p.clone()).ok())
                        .unwrap_or_default()
                        .ty,
                ),
                span,
            )
        })
    }
    pub fn build_switch_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        let child_switch_case = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::switch_case)
            .cloned();
        Ok({
            typed_node(
                TypedExpression::Match(TypedMatchExpr {
                    scrutinee: Box::new(
                        child_expr
                            .as_ref()
                            .and_then(|p| self.build_expr(p.clone()).ok())
                            .unwrap_or_default(),
                    ),
                    arms: Self::collect_cases(
                        child_switch_case
                            .as_ref()
                            .and_then(|p| self.build_switch_case(p.clone()).ok())
                            .unwrap_or_default(),
                        child_switch_case
                            .iter()
                            .filter_map(|p| self.build_switch_case(p.clone()).ok())
                            .collect::<Vec<_>>(),
                    ),
                }),
                Self::infer_switch_type(
                    child_switch_case
                        .as_ref()
                        .and_then(|p| self.build_switch_case(p.clone()).ok())
                        .unwrap_or_default(),
                    child_switch_case
                        .iter()
                        .filter_map(|p| self.build_switch_case(p.clone()).ok())
                        .collect::<Vec<_>>(),
                ),
                span,
            )
        })
    }
    pub fn build_switch_pattern(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_integer_literal = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::integer_literal)
            .cloned();
        Ok({
            if let Some(inner) = all_children.first() {
                match inner.as_rule() {
                    Rule::integer_literal => self.build_integer_literal(inner.clone())?,
                    Rule::switch_else => self.build_switch_else(inner.clone())?,
                    Rule::identifier => {
                        let name = inner.as_str();
                        typed_node(
                            TypedExpression::Variable(InternedString::new_global(name)),
                            Type::Never,
                            span,
                        )
                    }
                    _ => typed_node(
                        TypedExpression::Variable(InternedString::new_global(pair_str)),
                        Type::Never,
                        span,
                    ),
                }
            } else {
                typed_node(
                    TypedExpression::Variable(InternedString::new_global(pair_str)),
                    Type::Never,
                    span,
                )
            }
        })
    }
    pub fn build_null_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok({
            typed_node(
                TypedExpression::Literal(TypedLiteral::Null),
                Type::Nullable(Box::new(Type::Never)),
                span,
            )
        })
    }
    pub fn build_undefined_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok({
            typed_node(
                TypedExpression::Literal(TypedLiteral::Undefined),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_bool_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok({
            typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(pair_str == "true")),
                Type::Primitive(PrimitiveType::Bool),
                span,
            )
        })
    }
    pub fn build_integer_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok({
            typed_node(
                TypedExpression::Literal(TypedLiteral::Integer(Self::parse_int(pair_str))),
                Type::Primitive(PrimitiveType::I32),
                span,
            )
        })
    }
    pub fn build_float_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok({
            typed_node(
                TypedExpression::Literal(TypedLiteral::Float(Self::parse_float(pair_str))),
                Type::Primitive(PrimitiveType::F64),
                span,
            )
        })
    }
    pub fn build_string_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_string_inner = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::string_inner)
            .cloned();
        Ok({
            typed_node(
                TypedExpression::Literal(TypedLiteral::String(InternedString::new_global(
                    pair_str.trim_matches('"'),
                ))),
                Type::Primitive(PrimitiveType::String),
                span,
            )
        })
    }
    pub fn build_array_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        Ok({
            typed_node(
                TypedExpression::Array(vec![]),
                Type::Array {
                    element_type: Box::new(
                        child_type_expr
                            .as_ref()
                            .and_then(|p| self.build_type_expr(p.clone()).ok())
                            .unwrap_or_default(),
                    ),
                    size: None,
                    nullability: NullabilityKind::NonNull,
                },
                span,
            )
        })
    }
    pub fn build_struct_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_struct_field_init = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::struct_field_init)
            .cloned();
        Ok({
            typed_node(
                TypedExpression::Struct(TypedStructLiteral {
                    name: InternedString::new_global(
                        child_identifier.as_ref().map(|p| p.as_str()).unwrap_or(""),
                    ),
                    fields: vec![],
                }),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_struct_field_init(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedFieldInit, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        Ok({
            let mut field_name = String::new();
            let mut value: Option<TypedNode<TypedExpression>> = None;
            for inner in all_children.iter() {
                match inner.as_rule() {
                    Rule::identifier => field_name = inner.as_str().to_string(),
                    Rule::expr => value = Some(self.build_expr(inner.clone())?),
                    _ => {}
                }
            }
            TypedFieldInit {
                name: InternedString::new_global(&field_name),
                value: Box::new(value.unwrap_or_else(|| {
                    typed_node(
                        TypedExpression::Variable(InternedString::new_global(&field_name)),
                        Type::Never,
                        span,
                    )
                })),
            }
        })
    }
    pub fn build_wildcard_pattern(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedPattern>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok({ typed_node(TypedPattern::Wildcard, Type::Never, span) })
    }
    pub fn build_identifier_pattern(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedPattern>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        Ok({
            let mut is_mut = false;
            let mut name = String::new();
            for inner in all_children.iter() {
                let text = inner.as_str();
                if text == "mut" {
                    is_mut = true;
                } else if inner.as_rule() == Rule::identifier {
                    name = text.to_string();
                }
            }
            if name.is_empty() {
                name = pair_str.to_string();
            }
            typed_node(
                TypedPattern::Identifier {
                    name: InternedString::new_global(&name),
                    mutability: if is_mut {
                        Mutability::Mutable
                    } else {
                        Mutability::Immutable
                    },
                },
                Type::Never,
                span,
            )
        })
    }
    pub fn build_literal_pattern(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedPattern>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_literal = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::literal)
            .cloned();
        Ok({
            typed_node(
                TypedPattern::Literal(TypedLiteralPattern::Integer(0)),
                Type::Never,
                span,
            )
        })
    }
    pub fn build_enum_pattern(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedPattern>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_pattern = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::pattern)
            .cloned();
        Ok({
            typed_node(
                TypedPattern::Enum {
                    name: InternedString::new_global(
                        child_identifier.as_ref().map(|p| p.as_str()).unwrap_or(""),
                    ),
                    variant: InternedString::new_global(
                        child_identifier.as_ref().map(|p| p.as_str()).unwrap_or(""),
                    ),
                    fields: vec![child_pattern
                        .as_ref()
                        .and_then(|p| self.build_pattern(p.clone()).ok())
                        .unwrap_or_default()],
                },
                Type::Never,
                span,
            )
        })
    }
    pub fn build_identifier(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<String, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok({ pair_str.to_string() })
    }
    pub fn build_unary_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<String, ParseError> {
        let span = span_from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok({ pair_str.to_string() })
    }
    pub fn build_declaration(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedDeclaration>, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::const_decl => self.build_const_decl(inner),
                Rule::var_decl => self.build_var_decl(inner),
                Rule::fn_decl => self.build_fn_decl(inner),
                Rule::struct_decl => self.build_struct_decl(inner),
                Rule::enum_decl => self.build_enum_decl(inner),
                Rule::union_decl => self.build_union_decl(inner),
                Rule::error_set_decl => self.build_error_set_decl(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_declaration),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_declaration)
            )))
        }
    }
    pub fn build_fn_param(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedParameter, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::comptime_param => self.build_comptime_param(inner),
                Rule::regular_param => self.build_regular_param(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_fn_param),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_fn_param)
            )))
        }
    }
    pub fn build_statement(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedStatement>, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::local_const => self.build_local_const(inner),
                Rule::local_var => self.build_local_var(inner),
                Rule::assignment => self.build_assignment(inner),
                Rule::if_stmt => self.build_if_stmt(inner),
                Rule::while_stmt => self.build_while_stmt(inner),
                Rule::for_stmt => self.build_for_stmt(inner),
                Rule::break_stmt => self.build_break_stmt(inner),
                Rule::continue_stmt => self.build_continue_stmt(inner),
                Rule::return_stmt => self.build_return_stmt(inner),
                Rule::defer_stmt => self.build_defer_stmt(inner),
                Rule::errdefer_stmt => self.build_errdefer_stmt(inner),
                Rule::expr_stmt => self.build_expr_stmt(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_statement),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_statement)
            )))
        }
    }
    pub fn build_assign_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i128>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Integer(n)),
                Type::Primitive(PrimitiveType::I64),
                span,
            ));
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Float(n)),
                Type::Primitive(PrimitiveType::F64),
                span,
            ));
        }
        if text == "true" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(true)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        if text == "false" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(false)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        Ok(typed_node(
            TypedExpression::Variable(intern(text)),
            Type::Never,
            span,
        ))
    }
    pub fn build_if_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedStatement>, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::if_let_stmt => self.build_if_let_stmt(inner),
                Rule::if_regular_stmt => self.build_if_regular_stmt(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_if_stmt),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_if_stmt)
            )))
        }
    }
    pub fn build_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::orelse_expr => self.build_orelse_expr(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_expr),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!("Empty {} rule", stringify!(build_expr))))
        }
    }
    pub fn build_postfix_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<PostfixOp, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::deref_op => self.build_deref_op(inner),
                Rule::field_op => self.build_field_op(inner),
                Rule::index_op => self.build_index_op(inner),
                Rule::call_op => self.build_call_op(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_postfix_op),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_postfix_op)
            )))
        }
    }
    pub fn build_args(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::expr => self.build_expr(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_args),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!("Empty {} rule", stringify!(build_args))))
        }
    }
    pub fn build_lambda_start(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i128>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Integer(n)),
                Type::Primitive(PrimitiveType::I64),
                span,
            ));
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Float(n)),
                Type::Primitive(PrimitiveType::F64),
                span,
            ));
        }
        if text == "true" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(true)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        if text == "false" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(false)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        Ok(typed_node(
            TypedExpression::Variable(intern(text)),
            Type::Never,
            span,
        ))
    }
    pub fn build_lambda_end(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i128>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Integer(n)),
                Type::Primitive(PrimitiveType::I64),
                span,
            ));
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Float(n)),
                Type::Primitive(PrimitiveType::F64),
                span,
            ));
        }
        if text == "true" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(true)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        if text == "false" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(false)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        Ok(typed_node(
            TypedExpression::Variable(intern(text)),
            Type::Never,
            span,
        ))
    }
    pub fn build_lambda_params(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedParameter, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::lambda_param => self.build_lambda_param(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_lambda_params),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_lambda_params)
            )))
        }
    }
    pub fn build_switch_case(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::switch_pattern => self.build_switch_pattern(inner),
                Rule::expr => self.build_expr(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_switch_case),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_switch_case)
            )))
        }
    }
    pub fn build_switch_else(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i128>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Integer(n)),
                Type::Primitive(PrimitiveType::I64),
                span,
            ));
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Float(n)),
                Type::Primitive(PrimitiveType::F64),
                span,
            ));
        }
        if text == "true" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(true)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        if text == "false" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(false)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        Ok(typed_node(
            TypedExpression::Variable(intern(text)),
            Type::Never,
            span,
        ))
    }
    pub fn build_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::bool_literal => self.build_bool_literal(inner),
                Rule::null_literal => self.build_null_literal(inner),
                Rule::undefined_literal => self.build_undefined_literal(inner),
                Rule::float_literal => self.build_float_literal(inner),
                Rule::integer_literal => self.build_integer_literal(inner),
                Rule::string_literal => self.build_string_literal(inner),
                Rule::array_literal => self.build_array_literal(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_literal),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_literal)
            )))
        }
    }
    pub fn build_pattern(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedPattern>, ParseError> {
        let span = span_from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::wildcard_pattern => self.build_wildcard_pattern(inner),
                Rule::identifier_pattern => self.build_identifier_pattern(inner),
                Rule::literal_pattern => self.build_literal_pattern(inner),
                Rule::enum_pattern => self.build_enum_pattern(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_pattern),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_pattern)
            )))
        }
    }
    pub fn build_orelse_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i128>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Integer(n)),
                Type::Primitive(PrimitiveType::I64),
                span,
            ));
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Float(n)),
                Type::Primitive(PrimitiveType::F64),
                span,
            ));
        }
        if text == "true" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(true)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        if text == "false" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(false)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        Ok(typed_node(
            TypedExpression::Variable(intern(text)),
            Type::Never,
            span,
        ))
    }
    pub fn build_catch_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i128>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Integer(n)),
                Type::Primitive(PrimitiveType::I64),
                span,
            ));
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Float(n)),
                Type::Primitive(PrimitiveType::F64),
                span,
            ));
        }
        if text == "true" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(true)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        if text == "false" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(false)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        Ok(typed_node(
            TypedExpression::Variable(intern(text)),
            Type::Never,
            span,
        ))
    }
    pub fn build_log_or_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i128>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Integer(n)),
                Type::Primitive(PrimitiveType::I64),
                span,
            ));
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Float(n)),
                Type::Primitive(PrimitiveType::F64),
                span,
            ));
        }
        if text == "true" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(true)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        if text == "false" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(false)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        Ok(typed_node(
            TypedExpression::Variable(intern(text)),
            Type::Never,
            span,
        ))
    }
    pub fn build_log_and_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i128>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Integer(n)),
                Type::Primitive(PrimitiveType::I64),
                span,
            ));
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Float(n)),
                Type::Primitive(PrimitiveType::F64),
                span,
            ));
        }
        if text == "true" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(true)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        if text == "false" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(false)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        Ok(typed_node(
            TypedExpression::Variable(intern(text)),
            Type::Never,
            span,
        ))
    }
    pub fn build_cmp_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i128>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Integer(n)),
                Type::Primitive(PrimitiveType::I64),
                span,
            ));
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Float(n)),
                Type::Primitive(PrimitiveType::F64),
                span,
            ));
        }
        if text == "true" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(true)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        if text == "false" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(false)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        Ok(typed_node(
            TypedExpression::Variable(intern(text)),
            Type::Never,
            span,
        ))
    }
    pub fn build_eq_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i128>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Integer(n)),
                Type::Primitive(PrimitiveType::I64),
                span,
            ));
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Float(n)),
                Type::Primitive(PrimitiveType::F64),
                span,
            ));
        }
        if text == "true" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(true)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        if text == "false" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(false)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        Ok(typed_node(
            TypedExpression::Variable(intern(text)),
            Type::Never,
            span,
        ))
    }
    pub fn build_bit_or_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i128>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Integer(n)),
                Type::Primitive(PrimitiveType::I64),
                span,
            ));
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Float(n)),
                Type::Primitive(PrimitiveType::F64),
                span,
            ));
        }
        if text == "true" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(true)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        if text == "false" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(false)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        Ok(typed_node(
            TypedExpression::Variable(intern(text)),
            Type::Never,
            span,
        ))
    }
    pub fn build_bit_xor_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i128>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Integer(n)),
                Type::Primitive(PrimitiveType::I64),
                span,
            ));
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Float(n)),
                Type::Primitive(PrimitiveType::F64),
                span,
            ));
        }
        if text == "true" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(true)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        if text == "false" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(false)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        Ok(typed_node(
            TypedExpression::Variable(intern(text)),
            Type::Never,
            span,
        ))
    }
    pub fn build_bit_and_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i128>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Integer(n)),
                Type::Primitive(PrimitiveType::I64),
                span,
            ));
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Float(n)),
                Type::Primitive(PrimitiveType::F64),
                span,
            ));
        }
        if text == "true" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(true)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        if text == "false" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(false)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        Ok(typed_node(
            TypedExpression::Variable(intern(text)),
            Type::Never,
            span,
        ))
    }
    pub fn build_shift_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i128>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Integer(n)),
                Type::Primitive(PrimitiveType::I64),
                span,
            ));
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Float(n)),
                Type::Primitive(PrimitiveType::F64),
                span,
            ));
        }
        if text == "true" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(true)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        if text == "false" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(false)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        Ok(typed_node(
            TypedExpression::Variable(intern(text)),
            Type::Never,
            span,
        ))
    }
    pub fn build_add_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i128>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Integer(n)),
                Type::Primitive(PrimitiveType::I64),
                span,
            ));
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Float(n)),
                Type::Primitive(PrimitiveType::F64),
                span,
            ));
        }
        if text == "true" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(true)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        if text == "false" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(false)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        Ok(typed_node(
            TypedExpression::Variable(intern(text)),
            Type::Never,
            span,
        ))
    }
    pub fn build_mul_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedNode<TypedExpression>, ParseError> {
        let span = span_from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i128>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Integer(n)),
                Type::Primitive(PrimitiveType::I64),
                span,
            ));
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Float(n)),
                Type::Primitive(PrimitiveType::F64),
                span,
            ));
        }
        if text == "true" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(true)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        if text == "false" {
            return Ok(typed_node(
                TypedExpression::Literal(TypedLiteral::Bool(false)),
                Type::Primitive(PrimitiveType::Bool),
                span,
            ));
        }
        Ok(typed_node(
            TypedExpression::Variable(intern(text)),
            Type::Never,
            span,
        ))
    }
}
