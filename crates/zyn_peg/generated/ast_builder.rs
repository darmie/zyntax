#![doc = r" Generated AST builder"]
#![doc = r""]
#![doc = r" This file is auto-generated by ZynPEG. Do not edit manually."]
#![allow(dead_code, unused_variables, unused_imports, unused_mut)]
use super::typed_ast::*;
use super::Rule;
fn fold_postfix_ops(base: TypedExpression, ops: Vec<PostfixOp>) -> TypedExpression {
    ops.into_iter().fold(base, |expr, op| {
        let span = expr.span;
        match op {
            PostfixOp::Deref => TypedExpression {
                ty: expr.ty.deref(),
                expr: Expression::Deref(Box::new(expr)),
                span,
            },
            PostfixOp::Field(name) => TypedExpression {
                ty: Type::Unknown,
                expr: Expression::FieldAccess(Box::new(expr), name),
                span,
            },
            PostfixOp::Index(index) => TypedExpression {
                ty: expr.ty.element_type(),
                expr: Expression::Index(Box::new(expr), Box::new(index)),
                span,
            },
            PostfixOp::Call(args) => TypedExpression {
                ty: expr.ty.return_type(),
                expr: Expression::Call(Box::new(expr), args),
                span,
            },
            PostfixOp::OptionalUnwrap => TypedExpression {
                ty: expr.ty.unwrap_optional(),
                expr: Expression::UnaryOp(UnaryOp::Try, Box::new(expr)),
                span,
            },
            PostfixOp::TryUnwrap => TypedExpression {
                ty: expr.ty.unwrap_result(),
                expr: Expression::UnaryOp(UnaryOp::Try, Box::new(expr)),
                span,
            },
        }
    })
}
#[doc = r" TypedAST builder context"]
pub struct AstBuilderContext;
impl AstBuilderContext {
    pub fn new() -> Self {
        Self
    }
    fn fold_binary(
        first: TypedExpression,
        rest: Vec<(String, TypedExpression)>,
        default_op: BinaryOp,
    ) -> TypedExpression {
        rest.into_iter().fold(first, |left, (op_str, right)| {
            let op = match op_str.as_str() {
                "+" => BinaryOp::Add,
                "-" => BinaryOp::Sub,
                "*" => BinaryOp::Mul,
                "/" => BinaryOp::Div,
                "%" => BinaryOp::Mod,
                "==" => BinaryOp::Eq,
                "!=" => BinaryOp::Ne,
                "<" => BinaryOp::Lt,
                "<=" => BinaryOp::Le,
                ">" => BinaryOp::Gt,
                ">=" => BinaryOp::Ge,
                "and" => BinaryOp::And,
                "or" => BinaryOp::Or,
                "|" => BinaryOp::BitOr,
                "&" => BinaryOp::BitAnd,
                "^" => BinaryOp::BitXor,
                "<<" => BinaryOp::Shl,
                ">>" => BinaryOp::Shr,
                "orelse" => BinaryOp::Orelse,
                "catch" => BinaryOp::Catch,
                _ => default_op,
            };
            let result_ty = Self::infer_binary_type(&left.ty, op, &right.ty);
            TypedExpression {
                expr: Expression::BinaryOp(op, Box::new(left.clone()), Box::new(right.clone())),
                ty: result_ty,
                span: Span::merge(&left.span, &right.span),
            }
        })
    }
    fn infer_binary_type(left: &Type, op: BinaryOp, right: &Type) -> Type {
        match op {
            BinaryOp::Eq
            | BinaryOp::Ne
            | BinaryOp::Lt
            | BinaryOp::Le
            | BinaryOp::Gt
            | BinaryOp::Ge
            | BinaryOp::And
            | BinaryOp::Or => Type::Bool,
            BinaryOp::Orelse => left.unwrap_optional(),
            BinaryOp::Catch => left.unwrap_result(),
            _ => left.clone(),
        }
    }
    fn fold_postfix(base: TypedExpression, ops: Vec<PostfixOp>) -> TypedExpression {
        ops.into_iter().fold(base, |expr, op| match op {
            PostfixOp::Deref => TypedExpression {
                ty: expr.ty.deref(),
                expr: Expression::Deref(Box::new(expr.clone())),
                span: expr.span.clone(),
            },
            PostfixOp::Field(name) => TypedExpression {
                ty: Type::Unknown,
                expr: Expression::FieldAccess(Box::new(expr.clone()), name),
                span: expr.span.clone(),
            },
            PostfixOp::Index(index) => TypedExpression {
                ty: expr.ty.element_type(),
                expr: Expression::Index(Box::new(expr.clone()), Box::new(index)),
                span: expr.span.clone(),
            },
            PostfixOp::Call(args) => TypedExpression {
                ty: expr.ty.return_type(),
                expr: Expression::Call(Box::new(expr.clone()), args),
                span: expr.span.clone(),
            },
            PostfixOp::OptionalUnwrap => TypedExpression {
                ty: expr.ty.unwrap_optional(),
                expr: Expression::UnaryOp(UnaryOp::Try, Box::new(expr.clone())),
                span: expr.span.clone(),
            },
            PostfixOp::TryUnwrap => TypedExpression {
                ty: expr.ty.unwrap_result(),
                expr: Expression::UnaryOp(UnaryOp::Try, Box::new(expr.clone())),
                span: expr.span.clone(),
            },
        })
    }
    fn unwrap_result_type(ty: Type) -> Type {
        match ty {
            Type::Result(inner, _) => *inner,
            _ => ty,
        }
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_program(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedProgram, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_declaration: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::declaration)
            .cloned()
            .collect();
        Ok(TypedProgram {
            declarations: child_declaration
                .iter()
                .filter_map(|p| self.build_declaration(p.clone()).ok())
                .collect::<Vec<_>>(),
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_const_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        Ok(TypedDeclaration {
            decl: Declaration::Const(ConstDecl {
                name: child_identifier
                    .as_ref()
                    .map(|p| p.as_str().to_string())
                    .unwrap_or_default(),
                ty: child_type_expr
                    .as_ref()
                    .and_then(|p| self.build_type_expr(p.clone()).ok()),
                value: child_expr
                    .as_ref()
                    .and_then(|p| self.build_expr(p.clone()).ok())
                    .unwrap_or_default(),
                is_pub: false,
            }),
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_var_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        Ok(TypedDeclaration {
            decl: Declaration::Var(VarDecl {
                name: child_identifier
                    .as_ref()
                    .map(|p| p.as_str().to_string())
                    .unwrap_or_default(),
                ty: child_type_expr
                    .as_ref()
                    .and_then(|p| self.build_type_expr(p.clone()).ok()),
                value: Some(
                    child_expr
                        .as_ref()
                        .and_then(|p| self.build_expr(p.clone()).ok())
                        .unwrap_or_default(),
                ),
                is_pub: false,
            }),
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_fn_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_fn_params = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::fn_params)
            .cloned();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        let child_block = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::block)
            .cloned();
        Ok(TypedDeclaration {
            decl: Declaration::Function(FnDecl {
                name: child_identifier
                    .as_ref()
                    .map(|p| p.as_str().to_string())
                    .unwrap_or_default(),
                params: child_fn_params
                    .as_ref()
                    .and_then(|p| self.build_fn_params(p.clone()).ok())
                    .unwrap_or_default(),
                return_type: child_type_expr
                    .as_ref()
                    .and_then(|p| self.build_type_expr(p.clone()).ok())
                    .unwrap_or_default(),
                body: Some(
                    child_block
                        .as_ref()
                        .and_then(|p| self.build_block(p.clone()).ok())
                        .map(|v| v.statements)
                        .unwrap_or_default(),
                ),
                is_pub: false,
                is_export: false,
                is_extern: false,
            }),
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_fn_params(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Vec<Param>, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_fn_param = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::fn_param)
            .cloned();
        Ok({
            child_fn_param
                .iter()
                .filter_map(|p| self.build_fn_param(p.clone()).ok())
                .collect()
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_comptime_param(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedParam, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        Ok(TypedParam {
            name: child_identifier
                .as_ref()
                .map(|p| p.as_str().to_string())
                .unwrap_or_default(),
            ty: Type::Type,
            is_comptime: true,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_regular_param(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedParam, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        Ok(TypedParam {
            name: child_identifier
                .as_ref()
                .map(|p| p.as_str().to_string())
                .unwrap_or_default(),
            ty: child_type_expr
                .as_ref()
                .and_then(|p| self.build_type_expr(p.clone()).ok())
                .unwrap_or_default(),
            is_comptime: false,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_struct_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_field_decl: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::field_decl)
            .cloned()
            .collect();
        Ok(TypedDeclaration {
            decl: Declaration::Struct(StructDecl {
                name: child_identifier
                    .as_ref()
                    .map(|p| p.as_str().to_string())
                    .unwrap_or_default(),
                fields: child_field_decl
                    .iter()
                    .filter_map(|p| self.build_field_decl(p.clone()).ok())
                    .collect::<Vec<_>>(),
                is_packed: false,
            }),
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_field_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedField, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        Ok(TypedField {
            name: child_identifier
                .as_ref()
                .map(|p| p.as_str().to_string())
                .unwrap_or_default(),
            ty: child_type_expr
                .as_ref()
                .and_then(|p| self.build_type_expr(p.clone()).ok())
                .unwrap_or_default(),
            default: None,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_primitive_type(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Type, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok({
            match pair_str {
                "i8" => Type::I8,
                "i16" => Type::I16,
                "i32" => Type::I32,
                "i64" => Type::I64,
                "u8" => Type::U8,
                "u16" => Type::U16,
                "u32" => Type::U32,
                "u64" => Type::U64,
                "f32" => Type::F32,
                "f64" => Type::F64,
                "bool" => Type::Bool,
                "void" => Type::Void,
                _ => Type::Unknown,
            }
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_array_type(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Type, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_integer_literal = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::integer_literal)
            .cloned();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        Ok({
            Type::Array(
                Box::new(
                    child_type_expr
                        .as_ref()
                        .and_then(|p| self.build_type_expr(p.clone()).ok())
                        .unwrap_or_default(),
                ),
                child_integer_literal
                    .as_ref()
                    .and_then(|p| self.build_integer_literal(p.clone()).ok())
                    .map(|s| parse_int(s)),
            )
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_pointer_type(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Type, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        Ok({
            Type::Pointer(Box::new(
                child_type_expr
                    .as_ref()
                    .and_then(|p| self.build_type_expr(p.clone()).ok())
                    .unwrap_or_default(),
            ))
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_optional_type(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Type, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        Ok({
            Type::Optional(Box::new(
                child_type_expr
                    .as_ref()
                    .and_then(|p| self.build_type_expr(p.clone()).ok())
                    .unwrap_or_default(),
            ))
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_error_union_type(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Type, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        Ok({
            Type::Result(
                Box::new(
                    child_type_expr
                        .as_ref()
                        .and_then(|p| self.build_type_expr(p.clone()).ok())
                        .unwrap_or_default(),
                ),
                Box::new(Type::Error),
            )
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_assignment(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_assign_target = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::assign_target)
            .cloned();
        let child_assign_op = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::assign_op)
            .cloned();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        Ok(TypedStatement {
            stmt: Statement::Assign(
                child_assign_target
                    .as_ref()
                    .and_then(|p| self.build_assign_target(p.clone()).ok())
                    .unwrap_or_default(),
                child_expr
                    .as_ref()
                    .and_then(|p| self.build_expr(p.clone()).ok())
                    .unwrap_or_default(),
            ),
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_return_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        Ok(TypedStatement {
            stmt: Statement::Return(
                child_expr
                    .as_ref()
                    .and_then(|p| self.build_expr(p.clone()).ok()),
            ),
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_expr_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        Ok(TypedStatement {
            stmt: Statement::Expression(
                child_expr
                    .as_ref()
                    .and_then(|p| self.build_expr(p.clone()).ok())
                    .unwrap_or_default(),
            ),
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_if_let_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_pattern = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::pattern)
            .cloned();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        let child_block = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::block)
            .cloned();
        Ok(TypedStatement {
            stmt: Statement::If(
                child_expr
                    .as_ref()
                    .and_then(|p| self.build_expr(p.clone()).ok())
                    .unwrap_or_default(),
                child_block
                    .as_ref()
                    .and_then(|p| self.build_block(p.clone()).ok())
                    .map(|v| v.statements)
                    .unwrap_or_default(),
                child_block
                    .as_ref()
                    .and_then(|p| self.build_block(p.clone()).ok())
                    .map(|t| t.statements),
            ),
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_if_regular_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        let child_block = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::block)
            .cloned();
        Ok(TypedStatement {
            stmt: Statement::If(
                child_expr
                    .as_ref()
                    .and_then(|p| self.build_expr(p.clone()).ok())
                    .unwrap_or_default(),
                child_block
                    .as_ref()
                    .and_then(|p| self.build_block(p.clone()).ok())
                    .map(|v| v.statements)
                    .unwrap_or_default(),
                child_block
                    .as_ref()
                    .and_then(|p| self.build_block(p.clone()).ok())
                    .map(|t| t.statements),
            ),
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_while_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        let child_block = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::block)
            .cloned();
        Ok(TypedStatement {
            stmt: Statement::While(
                child_expr
                    .as_ref()
                    .and_then(|p| self.build_expr(p.clone()).ok())
                    .unwrap_or_default(),
                child_block
                    .as_ref()
                    .and_then(|p| self.build_block(p.clone()).ok())
                    .map(|v| v.statements)
                    .unwrap_or_default(),
            ),
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_break_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok(TypedStatement {
            stmt: Statement::Break(None),
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_continue_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok(TypedStatement {
            stmt: Statement::Continue,
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_block(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedBlock, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_statement: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::statement)
            .cloned()
            .collect();
        Ok(TypedBlock {
            statements: child_statement
                .iter()
                .filter_map(|p| self.build_statement(p.clone()).ok())
                .collect::<Vec<_>>(),
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_orelse_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_catch_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::catch_expr)
            .cloned();
        let child_orelse_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::orelse_op)
            .cloned()
            .collect();
        Ok({
            fold_binary(
                child_catch_expr
                    .as_ref()
                    .and_then(|p| self.build_catch_expr(p.clone()).ok())
                    .unwrap_or_default(),
                child_orelse_op
                    .iter()
                    .filter_map(|p| self.build_orelse_op(p.clone()).ok())
                    .collect::<Vec<_>>(),
                BinaryOp::Orelse,
            )
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_catch_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_logical_or = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::logical_or)
            .cloned();
        let child_catch_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::catch_op)
            .cloned()
            .collect();
        Ok({
            fold_binary(
                child_logical_or
                    .as_ref()
                    .and_then(|p| self.build_logical_or(p.clone()).ok())
                    .unwrap_or_default(),
                child_catch_op
                    .iter()
                    .filter_map(|p| self.build_catch_op(p.clone()).ok())
                    .collect::<Vec<_>>(),
                BinaryOp::Catch,
            )
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_logical_or(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_logical_and = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::logical_and)
            .cloned();
        let child_log_or_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::log_or_op)
            .cloned()
            .collect();
        Ok({
            fold_binary(
                child_logical_and
                    .as_ref()
                    .and_then(|p| self.build_logical_and(p.clone()).ok())
                    .unwrap_or_default(),
                child_log_or_op
                    .iter()
                    .filter_map(|p| self.build_log_or_op(p.clone()).ok())
                    .collect::<Vec<_>>(),
                BinaryOp::Or,
            )
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_logical_and(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_equality = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::equality)
            .cloned();
        let child_log_and_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::log_and_op)
            .cloned()
            .collect();
        Ok({
            fold_binary(
                child_equality
                    .as_ref()
                    .and_then(|p| self.build_equality(p.clone()).ok())
                    .unwrap_or_default(),
                child_log_and_op
                    .iter()
                    .filter_map(|p| self.build_log_and_op(p.clone()).ok())
                    .collect::<Vec<_>>(),
                BinaryOp::And,
            )
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_equality(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_comparison = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::comparison)
            .cloned();
        let child_eq_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::eq_op)
            .cloned()
            .collect();
        Ok({
            fold_binary(
                child_comparison
                    .as_ref()
                    .and_then(|p| self.build_comparison(p.clone()).ok())
                    .unwrap_or_default(),
                child_eq_op
                    .iter()
                    .filter_map(|p| self.build_eq_op(p.clone()).ok())
                    .collect::<Vec<_>>(),
                parse_eq_op,
            )
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_comparison(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_bitwise_or = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::bitwise_or)
            .cloned();
        let child_cmp_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::cmp_op)
            .cloned()
            .collect();
        Ok({
            fold_binary(
                child_bitwise_or
                    .as_ref()
                    .and_then(|p| self.build_bitwise_or(p.clone()).ok())
                    .unwrap_or_default(),
                child_cmp_op
                    .iter()
                    .filter_map(|p| self.build_cmp_op(p.clone()).ok())
                    .collect::<Vec<_>>(),
                parse_cmp_op,
            )
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_bitwise_or(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_bitwise_xor = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::bitwise_xor)
            .cloned();
        let child_bit_or_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::bit_or_op)
            .cloned()
            .collect();
        Ok({
            fold_binary(
                child_bitwise_xor
                    .as_ref()
                    .and_then(|p| self.build_bitwise_xor(p.clone()).ok())
                    .unwrap_or_default(),
                child_bit_or_op
                    .iter()
                    .filter_map(|p| self.build_bit_or_op(p.clone()).ok())
                    .collect::<Vec<_>>(),
                BinaryOp::BitOr,
            )
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_bitwise_xor(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_bitwise_and = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::bitwise_and)
            .cloned();
        let child_bit_xor_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::bit_xor_op)
            .cloned()
            .collect();
        Ok({
            fold_binary(
                child_bitwise_and
                    .as_ref()
                    .and_then(|p| self.build_bitwise_and(p.clone()).ok())
                    .unwrap_or_default(),
                child_bit_xor_op
                    .iter()
                    .filter_map(|p| self.build_bit_xor_op(p.clone()).ok())
                    .collect::<Vec<_>>(),
                BinaryOp::BitXor,
            )
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_bitwise_and(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_bit_shift = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::bit_shift)
            .cloned();
        let child_bit_and_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::bit_and_op)
            .cloned()
            .collect();
        Ok({
            fold_binary(
                child_bit_shift
                    .as_ref()
                    .and_then(|p| self.build_bit_shift(p.clone()).ok())
                    .unwrap_or_default(),
                child_bit_and_op
                    .iter()
                    .filter_map(|p| self.build_bit_and_op(p.clone()).ok())
                    .collect::<Vec<_>>(),
                BinaryOp::BitAnd,
            )
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_bit_shift(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_addition = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::addition)
            .cloned();
        let child_shift_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::shift_op)
            .cloned()
            .collect();
        Ok({
            fold_binary(
                child_addition
                    .as_ref()
                    .and_then(|p| self.build_addition(p.clone()).ok())
                    .unwrap_or_default(),
                child_shift_op
                    .iter()
                    .filter_map(|p| self.build_shift_op(p.clone()).ok())
                    .collect::<Vec<_>>(),
                parse_shift_op,
            )
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_addition(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_multiplication = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::multiplication)
            .cloned();
        let child_add_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::add_op)
            .cloned()
            .collect();
        Ok({
            fold_binary(
                child_multiplication
                    .as_ref()
                    .and_then(|p| self.build_multiplication(p.clone()).ok())
                    .unwrap_or_default(),
                child_add_op
                    .iter()
                    .filter_map(|p| self.build_add_op(p.clone()).ok())
                    .collect::<Vec<_>>(),
                parse_add_op,
            )
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_multiplication(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_unary = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::unary)
            .cloned();
        let child_mul_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::mul_op)
            .cloned()
            .collect();
        Ok({
            fold_binary(
                child_unary
                    .as_ref()
                    .and_then(|p| self.build_unary(p.clone()).ok())
                    .unwrap_or_default(),
                child_mul_op
                    .iter()
                    .filter_map(|p| self.build_mul_op(p.clone()).ok())
                    .collect::<Vec<_>>(),
                parse_mul_op,
            )
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_unary(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_unary_op = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::unary_op)
            .cloned();
        let child_unary = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::unary)
            .cloned();
        Ok({
            match child_unary_op
                .as_ref()
                .and_then(|p| self.build_unary_op(p.clone()).ok())
                .unwrap_or_default()
            {
                Some(op) => TypedExpression {
                    expr: UnaryOp(
                        parse_unary_op(op),
                        Box::new(
                            child_unary
                                .as_ref()
                                .and_then(|p| self.build_unary(p.clone()).ok())
                                .unwrap_or_default(),
                        ),
                    ),
                    ty: child_unary
                        .as_ref()
                        .and_then(|p| self.build_unary(p.clone()).ok())
                        .map(|v| v.ty)
                        .unwrap_or_default()
                        .clone(),
                    span: span,
                },
                None => child_unary
                    .as_ref()
                    .and_then(|p| self.build_unary(p.clone()).ok())
                    .unwrap_or_default(),
            }
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_postfix(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_primary = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::primary)
            .cloned();
        let child_postfix_op: Vec<_> = all_children
            .iter()
            .filter(|p| p.as_rule() == Rule::postfix_op)
            .cloned()
            .collect();
        Ok({
            fold_postfix(
                child_primary
                    .as_ref()
                    .and_then(|p| self.build_primary(p.clone()).ok())
                    .unwrap_or_default(),
                child_postfix_op
                    .iter()
                    .filter_map(|p| self.build_postfix_op(p.clone()).ok())
                    .collect::<Vec<_>>(),
            )
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_lambda_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok(TypedExpression {
            expr: Lambda {
                params: Default::default(),
                body: pair_str,
                captures: vec![],
            },
            ty: Type::Function(vec![], Box::new(Type::Unknown)),
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_try_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_postfix = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::postfix)
            .cloned();
        Ok(TypedExpression {
            expr: Try {
                expr: Box::new(
                    child_postfix
                        .as_ref()
                        .and_then(|p| self.build_postfix(p.clone()).ok())
                        .unwrap_or_default(),
                ),
            },
            ty: unwrap_result_type(
                child_postfix
                    .as_ref()
                    .and_then(|p| self.build_postfix(p.clone()).ok())
                    .map(|v| v.ty)
                    .unwrap_or_default(),
            ),
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_switch_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        let child_switch_case = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::switch_case)
            .cloned();
        Ok(TypedExpression {
            expr: Switch {
                scrutinee: Box::new(
                    child_expr
                        .as_ref()
                        .and_then(|p| self.build_expr(p.clone()).ok())
                        .unwrap_or_default(),
                ),
                cases: collect_cases(
                    child_switch_case
                        .as_ref()
                        .and_then(|p| self.build_switch_case(p.clone()).ok())
                        .unwrap_or_default(),
                    child_switch_case
                        .iter()
                        .filter_map(|p| self.build_switch_case(p.clone()).ok())
                        .collect::<Vec<_>>(),
                ),
            },
            ty: infer_switch_type(
                child_switch_case
                    .as_ref()
                    .and_then(|p| self.build_switch_case(p.clone()).ok())
                    .unwrap_or_default(),
                child_switch_case
                    .iter()
                    .filter_map(|p| self.build_switch_case(p.clone()).ok())
                    .collect::<Vec<_>>(),
            ),
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_null_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok(TypedExpression {
            expr: Expression::NullLiteral,
            ty: Type::Optional(Box::new(Type::Unknown)),
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_undefined_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok(TypedExpression {
            expr: Expression::UndefinedLiteral,
            ty: Type::Unknown,
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_bool_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok(TypedExpression {
            expr: Expression::BoolLiteral(pair_str == "true"),
            ty: Type::Bool,
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_integer_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok(TypedExpression {
            expr: Expression::IntLiteral(parse_int(pair_str)),
            ty: Type::I32,
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_float_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok(TypedExpression {
            expr: Expression::FloatLiteral(parse_float(pair_str)),
            ty: Type::F64,
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_string_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_string_inner = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::string_inner)
            .cloned();
        Ok(TypedExpression {
            expr: Expression::StringLiteral(child_string_inner
                .as_ref()
                .and_then(|p| self.build_string_inner(p.clone()).ok())
                .map(|v| v.to_string)
                .unwrap_or_default()()),
            ty: Type::Pointer(Box::new(Type::I8)),
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_array_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_type_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::type_expr)
            .cloned();
        let child_expr = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::expr)
            .cloned();
        Ok(TypedExpression {
            expr: Expression::Array(Vec::new()),
            ty: Type::Array(
                Box::new(
                    child_type_expr
                        .as_ref()
                        .and_then(|p| self.build_type_expr(p.clone()).ok())
                        .unwrap_or_default(),
                ),
                None,
            ),
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_struct_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_struct_field_init = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::struct_field_init)
            .cloned();
        Ok(TypedExpression {
            expr: StructLiteral {
                name: child_identifier
                    .as_ref()
                    .map(|p| p.as_str().to_string())
                    .unwrap_or_default(),
                fields: collect_fields(
                    child_struct_field_init
                        .as_ref()
                        .and_then(|p| self.build_struct_field_init(p.clone()).ok()),
                    child_struct_field_init
                        .iter()
                        .filter_map(|p| self.build_struct_field_init(p.clone()).ok())
                        .collect::<Vec<_>>(),
                ),
            },
            ty: Type::Named(
                child_identifier
                    .as_ref()
                    .map(|p| p.as_str().to_string())
                    .unwrap_or_default(),
            ),
            span: span,
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_wildcard_pattern(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Pattern, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        Ok({ Pattern::Wildcard })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_identifier_pattern(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Pattern, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        Ok({
            Pattern::Binding(
                child_identifier
                    .as_ref()
                    .map(|p| p.as_str().to_string())
                    .unwrap_or_default(),
            )
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_literal_pattern(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Pattern, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_literal = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::literal)
            .cloned();
        Ok({
            Pattern::Literal(
                child_literal
                    .as_ref()
                    .and_then(|p| self.build_literal(p.clone()).ok())
                    .unwrap_or_default(),
            )
        })
    }
    #[doc = r" Build a #return_type from a parsed rule"]
    pub fn build_enum_pattern(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Pattern, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let pair_str = pair.as_str();
        let mut children = pair.into_inner().peekable();
        let all_children: Vec<_> = children.collect();
        let mut child_iter = all_children.iter();
        let child_identifier = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::identifier)
            .cloned();
        let child_pattern = all_children
            .iter()
            .find(|p| p.as_rule() == Rule::pattern)
            .cloned();
        Ok({
            Pattern::Variant(
                child_identifier
                    .as_ref()
                    .map(|p| p.as_str().to_string())
                    .unwrap_or_default(),
                Box::new(
                    child_pattern
                        .as_ref()
                        .and_then(|p| self.build_pattern(p.clone()).ok())
                        .unwrap_or_default(),
                ),
            )
        })
    }
    pub fn build_declaration(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::const_decl => self.build_const_decl(inner),
                Rule::var_decl => self.build_var_decl(inner),
                Rule::fn_decl => self.build_fn_decl(inner),
                Rule::struct_decl => self.build_struct_decl(inner),
                Rule::enum_decl => self.build_enum_decl(inner),
                Rule::union_decl => self.build_union_decl(inner),
                Rule::error_set_decl => self.build_error_set_decl(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_declaration),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_declaration)
            )))
        }
    }
    pub fn build_fn_param(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedParam, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::comptime_param => self.build_comptime_param(inner),
                Rule::regular_param => self.build_regular_param(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_fn_param),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_fn_param)
            )))
        }
    }
    pub fn build_enum_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::type_expr => self.build_type_expr(inner),
                Rule::enum_variant => self.build_enum_variant(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_enum_decl),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_enum_decl)
            )))
        }
    }
    pub fn build_enum_variant(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::expr => self.build_expr(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_enum_variant),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_enum_variant)
            )))
        }
    }
    pub fn build_union_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::union_field => self.build_union_field(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_union_decl),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_union_decl)
            )))
        }
    }
    pub fn build_union_field(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::type_expr => self.build_type_expr(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_union_field),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_union_field)
            )))
        }
    }
    pub fn build_error_set_decl(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i64>() {
            return Ok(TypedExpression {
                expr: Expression::IntLiteral(n),
                ty: Type::I64,
                span,
            });
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(TypedExpression {
                expr: Expression::FloatLiteral(n),
                ty: Type::F64,
                span,
            });
        }
        if text == "true" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(true),
                ty: Type::Bool,
                span,
            });
        }
        if text == "false" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(false),
                ty: Type::Bool,
                span,
            });
        }
        Ok(TypedExpression {
            expr: Expression::Identifier(text.to_string()),
            ty: Type::Unknown,
            span,
        })
    }
    pub fn build_type_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Type, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::primitive_type => self.build_primitive_type(inner),
                Rule::array_type => self.build_array_type(inner),
                Rule::pointer_type => self.build_pointer_type(inner),
                Rule::optional_type => self.build_optional_type(inner),
                Rule::error_union_type => self.build_error_union_type(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_type_expr),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_type_expr)
            )))
        }
    }
    pub fn build_statement(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedDeclaration, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::const_decl => self.build_const_decl(inner),
                Rule::var_decl => self.build_var_decl(inner),
                Rule::assignment => self.build_assignment(inner),
                Rule::if_stmt => self.build_if_stmt(inner),
                Rule::while_stmt => self.build_while_stmt(inner),
                Rule::for_stmt => self.build_for_stmt(inner),
                Rule::break_stmt => self.build_break_stmt(inner),
                Rule::continue_stmt => self.build_continue_stmt(inner),
                Rule::return_stmt => self.build_return_stmt(inner),
                Rule::defer_stmt => self.build_defer_stmt(inner),
                Rule::errdefer_stmt => self.build_errdefer_stmt(inner),
                Rule::expr_stmt => self.build_expr_stmt(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_statement),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_statement)
            )))
        }
    }
    pub fn build_defer_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedBlock, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::block => self.build_block(inner),
                Rule::expr_stmt => self.build_expr_stmt(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_defer_stmt),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_defer_stmt)
            )))
        }
    }
    pub fn build_errdefer_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedBlock, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::block => self.build_block(inner),
                Rule::expr_stmt => self.build_expr_stmt(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_errdefer_stmt),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_errdefer_stmt)
            )))
        }
    }
    pub fn build_assign_target(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::expr => self.build_expr(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_assign_target),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_assign_target)
            )))
        }
    }
    pub fn build_assign_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i64>() {
            return Ok(TypedExpression {
                expr: Expression::IntLiteral(n),
                ty: Type::I64,
                span,
            });
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(TypedExpression {
                expr: Expression::FloatLiteral(n),
                ty: Type::F64,
                span,
            });
        }
        if text == "true" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(true),
                ty: Type::Bool,
                span,
            });
        }
        if text == "false" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(false),
                ty: Type::Bool,
                span,
            });
        }
        Ok(TypedExpression {
            expr: Expression::Identifier(text.to_string()),
            ty: Type::Unknown,
            span,
        })
    }
    pub fn build_if_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedStatement, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::if_let_stmt => self.build_if_let_stmt(inner),
                Rule::if_regular_stmt => self.build_if_regular_stmt(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_if_stmt),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_if_stmt)
            )))
        }
    }
    pub fn build_for_stmt(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedBlock, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::expr => self.build_expr(inner),
                Rule::block => self.build_block(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_for_stmt),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_for_stmt)
            )))
        }
    }
    pub fn build_expr(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::orelse_expr => self.build_orelse_expr(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_expr),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!("Empty {} rule", stringify!(build_expr))))
        }
    }
    pub fn build_postfix_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::expr => self.build_expr(inner),
                Rule::args => self.build_args(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_postfix_op),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_postfix_op)
            )))
        }
    }
    pub fn build_args(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::expr => self.build_expr(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_args),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!("Empty {} rule", stringify!(build_args))))
        }
    }
    pub fn build_primary(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::literal => self.build_literal(inner),
                Rule::struct_literal => self.build_struct_literal(inner),
                Rule::switch_expr => self.build_switch_expr(inner),
                Rule::try_expr => self.build_try_expr(inner),
                Rule::lambda_expr => self.build_lambda_expr(inner),
                Rule::expr => self.build_expr(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_primary),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_primary)
            )))
        }
    }
    pub fn build_lambda_params(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::lambda_param => self.build_lambda_param(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_lambda_params),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_lambda_params)
            )))
        }
    }
    pub fn build_lambda_param(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::type_expr => self.build_type_expr(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_lambda_param),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_lambda_param)
            )))
        }
    }
    pub fn build_switch_case(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::switch_pattern => self.build_switch_pattern(inner),
                Rule::expr => self.build_expr(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_switch_case),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_switch_case)
            )))
        }
    }
    pub fn build_switch_pattern(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::integer_literal => self.build_integer_literal(inner),
                Rule::switch_else => self.build_switch_else(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_switch_pattern),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_switch_pattern)
            )))
        }
    }
    pub fn build_switch_else(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i64>() {
            return Ok(TypedExpression {
                expr: Expression::IntLiteral(n),
                ty: Type::I64,
                span,
            });
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(TypedExpression {
                expr: Expression::FloatLiteral(n),
                ty: Type::F64,
                span,
            });
        }
        if text == "true" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(true),
                ty: Type::Bool,
                span,
            });
        }
        if text == "false" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(false),
                ty: Type::Bool,
                span,
            });
        }
        Ok(TypedExpression {
            expr: Expression::Identifier(text.to_string()),
            ty: Type::Unknown,
            span,
        })
    }
    pub fn build_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::bool_literal => self.build_bool_literal(inner),
                Rule::null_literal => self.build_null_literal(inner),
                Rule::undefined_literal => self.build_undefined_literal(inner),
                Rule::float_literal => self.build_float_literal(inner),
                Rule::integer_literal => self.build_integer_literal(inner),
                Rule::string_literal => self.build_string_literal(inner),
                Rule::array_literal => self.build_array_literal(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_literal),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_literal)
            )))
        }
    }
    pub fn build_struct_field_init(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::expr => self.build_expr(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_struct_field_init),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_struct_field_init)
            )))
        }
    }
    pub fn build_pattern(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<Pattern, ParseError> {
        let span = Span::from_pest(pair.as_span());
        if let Some(inner) = pair.into_inner().next() {
            match inner.as_rule() {
                Rule::wildcard_pattern => self.build_wildcard_pattern(inner),
                Rule::identifier_pattern => self.build_identifier_pattern(inner),
                Rule::literal_pattern => self.build_literal_pattern(inner),
                Rule::enum_pattern => self.build_enum_pattern(inner),
                _ => Err(ParseError(format!(
                    "Unexpected rule in {}: {:?}",
                    stringify!(build_pattern),
                    inner.as_rule()
                ))),
            }
        } else {
            Err(ParseError(format!(
                "Empty {} rule",
                stringify!(build_pattern)
            )))
        }
    }
    pub fn build_orelse_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i64>() {
            return Ok(TypedExpression {
                expr: Expression::IntLiteral(n),
                ty: Type::I64,
                span,
            });
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(TypedExpression {
                expr: Expression::FloatLiteral(n),
                ty: Type::F64,
                span,
            });
        }
        if text == "true" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(true),
                ty: Type::Bool,
                span,
            });
        }
        if text == "false" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(false),
                ty: Type::Bool,
                span,
            });
        }
        Ok(TypedExpression {
            expr: Expression::Identifier(text.to_string()),
            ty: Type::Unknown,
            span,
        })
    }
    pub fn build_catch_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i64>() {
            return Ok(TypedExpression {
                expr: Expression::IntLiteral(n),
                ty: Type::I64,
                span,
            });
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(TypedExpression {
                expr: Expression::FloatLiteral(n),
                ty: Type::F64,
                span,
            });
        }
        if text == "true" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(true),
                ty: Type::Bool,
                span,
            });
        }
        if text == "false" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(false),
                ty: Type::Bool,
                span,
            });
        }
        Ok(TypedExpression {
            expr: Expression::Identifier(text.to_string()),
            ty: Type::Unknown,
            span,
        })
    }
    pub fn build_log_or_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i64>() {
            return Ok(TypedExpression {
                expr: Expression::IntLiteral(n),
                ty: Type::I64,
                span,
            });
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(TypedExpression {
                expr: Expression::FloatLiteral(n),
                ty: Type::F64,
                span,
            });
        }
        if text == "true" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(true),
                ty: Type::Bool,
                span,
            });
        }
        if text == "false" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(false),
                ty: Type::Bool,
                span,
            });
        }
        Ok(TypedExpression {
            expr: Expression::Identifier(text.to_string()),
            ty: Type::Unknown,
            span,
        })
    }
    pub fn build_log_and_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i64>() {
            return Ok(TypedExpression {
                expr: Expression::IntLiteral(n),
                ty: Type::I64,
                span,
            });
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(TypedExpression {
                expr: Expression::FloatLiteral(n),
                ty: Type::F64,
                span,
            });
        }
        if text == "true" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(true),
                ty: Type::Bool,
                span,
            });
        }
        if text == "false" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(false),
                ty: Type::Bool,
                span,
            });
        }
        Ok(TypedExpression {
            expr: Expression::Identifier(text.to_string()),
            ty: Type::Unknown,
            span,
        })
    }
    pub fn build_cmp_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i64>() {
            return Ok(TypedExpression {
                expr: Expression::IntLiteral(n),
                ty: Type::I64,
                span,
            });
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(TypedExpression {
                expr: Expression::FloatLiteral(n),
                ty: Type::F64,
                span,
            });
        }
        if text == "true" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(true),
                ty: Type::Bool,
                span,
            });
        }
        if text == "false" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(false),
                ty: Type::Bool,
                span,
            });
        }
        Ok(TypedExpression {
            expr: Expression::Identifier(text.to_string()),
            ty: Type::Unknown,
            span,
        })
    }
    pub fn build_eq_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i64>() {
            return Ok(TypedExpression {
                expr: Expression::IntLiteral(n),
                ty: Type::I64,
                span,
            });
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(TypedExpression {
                expr: Expression::FloatLiteral(n),
                ty: Type::F64,
                span,
            });
        }
        if text == "true" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(true),
                ty: Type::Bool,
                span,
            });
        }
        if text == "false" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(false),
                ty: Type::Bool,
                span,
            });
        }
        Ok(TypedExpression {
            expr: Expression::Identifier(text.to_string()),
            ty: Type::Unknown,
            span,
        })
    }
    pub fn build_bit_or_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i64>() {
            return Ok(TypedExpression {
                expr: Expression::IntLiteral(n),
                ty: Type::I64,
                span,
            });
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(TypedExpression {
                expr: Expression::FloatLiteral(n),
                ty: Type::F64,
                span,
            });
        }
        if text == "true" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(true),
                ty: Type::Bool,
                span,
            });
        }
        if text == "false" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(false),
                ty: Type::Bool,
                span,
            });
        }
        Ok(TypedExpression {
            expr: Expression::Identifier(text.to_string()),
            ty: Type::Unknown,
            span,
        })
    }
    pub fn build_bit_xor_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i64>() {
            return Ok(TypedExpression {
                expr: Expression::IntLiteral(n),
                ty: Type::I64,
                span,
            });
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(TypedExpression {
                expr: Expression::FloatLiteral(n),
                ty: Type::F64,
                span,
            });
        }
        if text == "true" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(true),
                ty: Type::Bool,
                span,
            });
        }
        if text == "false" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(false),
                ty: Type::Bool,
                span,
            });
        }
        Ok(TypedExpression {
            expr: Expression::Identifier(text.to_string()),
            ty: Type::Unknown,
            span,
        })
    }
    pub fn build_bit_and_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i64>() {
            return Ok(TypedExpression {
                expr: Expression::IntLiteral(n),
                ty: Type::I64,
                span,
            });
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(TypedExpression {
                expr: Expression::FloatLiteral(n),
                ty: Type::F64,
                span,
            });
        }
        if text == "true" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(true),
                ty: Type::Bool,
                span,
            });
        }
        if text == "false" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(false),
                ty: Type::Bool,
                span,
            });
        }
        Ok(TypedExpression {
            expr: Expression::Identifier(text.to_string()),
            ty: Type::Unknown,
            span,
        })
    }
    pub fn build_shift_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i64>() {
            return Ok(TypedExpression {
                expr: Expression::IntLiteral(n),
                ty: Type::I64,
                span,
            });
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(TypedExpression {
                expr: Expression::FloatLiteral(n),
                ty: Type::F64,
                span,
            });
        }
        if text == "true" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(true),
                ty: Type::Bool,
                span,
            });
        }
        if text == "false" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(false),
                ty: Type::Bool,
                span,
            });
        }
        Ok(TypedExpression {
            expr: Expression::Identifier(text.to_string()),
            ty: Type::Unknown,
            span,
        })
    }
    pub fn build_add_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i64>() {
            return Ok(TypedExpression {
                expr: Expression::IntLiteral(n),
                ty: Type::I64,
                span,
            });
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(TypedExpression {
                expr: Expression::FloatLiteral(n),
                ty: Type::F64,
                span,
            });
        }
        if text == "true" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(true),
                ty: Type::Bool,
                span,
            });
        }
        if text == "false" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(false),
                ty: Type::Bool,
                span,
            });
        }
        Ok(TypedExpression {
            expr: Expression::Identifier(text.to_string()),
            ty: Type::Unknown,
            span,
        })
    }
    pub fn build_mul_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i64>() {
            return Ok(TypedExpression {
                expr: Expression::IntLiteral(n),
                ty: Type::I64,
                span,
            });
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(TypedExpression {
                expr: Expression::FloatLiteral(n),
                ty: Type::F64,
                span,
            });
        }
        if text == "true" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(true),
                ty: Type::Bool,
                span,
            });
        }
        if text == "false" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(false),
                ty: Type::Bool,
                span,
            });
        }
        Ok(TypedExpression {
            expr: Expression::Identifier(text.to_string()),
            ty: Type::Unknown,
            span,
        })
    }
    pub fn build_unary_op(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> Result<TypedExpression, ParseError> {
        let span = Span::from_pest(pair.as_span());
        let text = pair.as_str().trim();
        if let Ok(n) = text.parse::<i64>() {
            return Ok(TypedExpression {
                expr: Expression::IntLiteral(n),
                ty: Type::I64,
                span,
            });
        }
        if let Ok(n) = text.parse::<f64>() {
            return Ok(TypedExpression {
                expr: Expression::FloatLiteral(n),
                ty: Type::F64,
                span,
            });
        }
        if text == "true" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(true),
                ty: Type::Bool,
                span,
            });
        }
        if text == "false" {
            return Ok(TypedExpression {
                expr: Expression::BoolLiteral(false),
                ty: Type::Bool,
                span,
            });
        }
        Ok(TypedExpression {
            expr: Expression::Identifier(text.to_string()),
            ty: Type::Unknown,
            span,
        })
    }
}
